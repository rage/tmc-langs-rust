<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="XML is a flexible markup language that is still used for sharing data between applications or for writing configuration files."><title>serde_xml_rs - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-1a91846b.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="serde_xml_rs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0 (6b00bc388 2025-06-23)" data-channel="1.88.0" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../serde_xml_rs/index.html">serde_<wbr>xml_<wbr>rs</a><span class="version">0.8.1</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#caveats" title="Caveats">Caveats</a></li><li><a href="#basic-example" title="Basic example">Basic example</a></li><li><a href="#correspondence-between-xml-and-rust" title="Correspondence between XML and Rust">Correspondence between XML and Rust</a><ul><li><a href="#document-root" title="Document root">Document root</a></li><li><a href="#strings-and-byte-arrays" title="Strings and byte arrays">Strings and byte arrays</a></li><li><a href="#primitive-types" title="Primitive types">Primitive types</a></li><li><a href="#child-elements" title="Child elements">Child elements</a></li><li><a href="#attributes" title="Attributes">Attributes</a></li><li><a href="#elements-with-attributes-and-text-content" title="Elements with attributes and text content">Elements with attributes and text content</a></li><li><a href="#repeated-tags-and-sequences" title="Repeated tags and sequences">Repeated tags and sequences</a></li><li><a href="#choices-and-enums" title="Choices and enums">Choices and enums</a></li><li><a href="#enums-in-attribute-values" title="Enums in attribute values">Enums in attribute values</a></li><li><a href="#sequences-of-choices-and-content" title="Sequences of choices and `#content`">Sequences of choices and <code>#content</code></a></li><li><a href="#xml-namespaces" title="XML Namespaces">XML Namespaces</a></li></ul></li><li><a href="#custom-eventreader" title="Custom EventReader">Custom EventReader</a></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#enums" title="Enums">Enums</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>serde_xml_rs</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/serde_xml_rs/lib.rs.html#1-17">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>XML is a flexible markup language that is still used for sharing data between applications or
for writing configuration files.</p>
<p>Serde XML provides a way to convert between text and strongly-typed Rust data structures.</p>
<h2 id="caveats"><a class="doc-anchor" href="#caveats">§</a>Caveats</h2>
<p>The Serde framework was mainly designed with formats such as JSON or YAML in mind.
As opposed to XML, these formats have the advantage of a stricter syntax which makes it
possible to know what type a field is without relying on an accompanying schema,
and disallows repeating the same tag multiple times in the same object.</p>
<p>For example, encoding the following document in YAML is not trivial.</p>
<div class="example-wrap"><pre class="language-xml"><code>&lt;document&gt;
  &lt;header&gt;A header&lt;/header&gt;
  &lt;section&gt;First section&lt;/section&gt;
  &lt;section&gt;Second section&lt;/section&gt;
  &lt;sidenote&gt;A sidenote&lt;/sidenote&gt;
  &lt;section&gt;Third section&lt;/section&gt;
  &lt;sidenote&gt;Another sidenote&lt;/sidenote&gt;
  &lt;section&gt;Fourth section&lt;/section&gt;
  &lt;footer&gt;The footer&lt;/footer&gt;
&lt;/document&gt;</code></pre></div>
<p>One possibility is the following YAML document.</p>
<div class="example-wrap"><pre class="language-yaml"><code>- header: A header
- section: First section
- section: Second section
- sidenote: A sidenote
- section: Third section
- sidenote: Another sidenote
- section: Fourth section
- footer: The footer</code></pre></div>
<p>Other notable differences:</p>
<ul>
<li>XML requires a named root node.</li>
<li>XML has a namespace system.</li>
<li>XML distinguishes between attributes, child tags and contents.</li>
<li>In XML, the order of nodes is sometimes important.</li>
</ul>
<h2 id="basic-example"><a class="doc-anchor" href="#basic-example">§</a>Basic example</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>serde::{Deserialize, Serialize};
<span class="kw">use </span>serde_xml_rs::{from_str, to_string};

<span class="attr">#[derive(Debug, Serialize, Deserialize, PartialEq)]
</span><span class="kw">struct </span>Item {
    name: String,
    source: String,
}

<span class="kw">let </span>src = <span class="string">r#"&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;Item&gt;&lt;name&gt;Banana&lt;/name&gt;&lt;source&gt;Store&lt;/source&gt;&lt;/Item&gt;"#</span>;
<span class="kw">let </span>should_be = Item {
    name: <span class="string">"Banana"</span>.to_string(),
    source: <span class="string">"Store"</span>.to_string(),
};

<span class="kw">let </span>item: Item = from_str(src).unwrap();
<span class="macro">assert_eq!</span>(item, should_be);

<span class="kw">let </span>reserialized_item = to_string(<span class="kw-2">&amp;</span>item).unwrap();
<span class="macro">assert_eq!</span>(src, reserialized_item);</code></pre></div>
<h2 id="correspondence-between-xml-and-rust"><a class="doc-anchor" href="#correspondence-between-xml-and-rust">§</a>Correspondence between XML and Rust</h2><h3 id="document-root"><a class="doc-anchor" href="#document-root">§</a>Document root</h3>
<p>As stated above, XML documents must have one and only one root element.
This puts a constraint on the range of types that can be supported at the root,
especially during serialization when a name has to be given to the root element.</p>
<p>In order to support serialization and deserialization, the root Rust type, that is the type of the value passed to <code>to_string</code> or returned by <code>from_str</code>, must be one of:</p>
<ul>
<li>a struct</li>
<li>a newtype struct</li>
<li>a unit struct (not very interesting)</li>
<li>an enum</li>
</ul>
<table>
<thead>
<tr><th>XML</th><th>Rust</th></tr>
</thead>
<tbody>
<tr>
<td>
<div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;
    ...
&lt;/Document&gt;</code></pre></div></td>
<td>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>Document { ... }</code></pre></div>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>Document(...);</code></pre></div>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">enum </span>Document { ... }</code></pre></div>
</td>
</tr>
</tbody>
</table>
<p>Other types must be encapsulated in order to be serialized, because the name of the struct or enum provides the name of the root element for the XML document.</p>
<p>The deserializer supports more Rust types directly:</p>
<ul>
<li>primitives (<code>bool</code>, <code>char</code>, integers, floats)</li>
<li>options</li>
<li>unit (<code>()</code>)</li>
</ul>
<p>Sequences, tuples and maps are not supported as root types for the moment, but could be in the future.</p>
<h3 id="strings-and-byte-arrays"><a class="doc-anchor" href="#strings-and-byte-arrays">§</a>Strings and byte arrays</h3><table>
<thead>
<tr><th>XML</th><th>Rust</th></tr>
</thead>
<tbody>
<tr>
<td>
<div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;
    Some text
&lt;/Document&gt;</code></pre></div><div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;
    &lt;![CDATA[Some text]]&gt;
&lt;/Document&gt;</code></pre></div><div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;
    Some &lt;![CDATA[text]]&gt;
&lt;/Document&gt;</code></pre></div></td>
<td>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Document(String);

<span class="kw">let </span>value = Document(<span class="string">"Some text"</span>.to_string());
</code></pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Document(<span class="attr">#[serde(with = <span class="string">"serde_bytes"</span>)] </span>Vec&lt;u8&gt;);

<span class="kw">let </span>value = Document(<span class="string">"Some text"</span>.as_bytes().to_vec());
</code></pre></div>
</td>
</tr>
</tbody>
</table>
<p>Borrowed strings are not supported.</p>
<h3 id="primitive-types"><a class="doc-anchor" href="#primitive-types">§</a>Primitive types</h3><table>
<thead>
<tr><th>XML</th><th>Rust</th></tr>
</thead>
<tbody>
<tr><th colspan="2">unit</th></tr>
<tr>
<td>
<div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;&lt;/Document&gt;</code></pre></div><div class="example-wrap"><pre class="language-xml"><code>&lt;Document /&gt;</code></pre></div></td>
<td>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Document(());

<span class="kw">let </span>value = Document(());
</code></pre></div>
</td>
</tr>
<tr><th colspan="2">boolean</th></tr>
<tr>
<td>
<div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;true&lt;/Document&gt;</code></pre></div><div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;1&lt;/Document&gt;</code></pre></div></td>
<td>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Document(bool);

<span class="kw">let </span>value = Document(<span class="bool-val">true</span>);
</code></pre></div>
</td>
</tr>
<tr><th colspan="2">char</th></tr>
<tr>
<td>
<div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;a&lt;/Document&gt;</code></pre></div></td>
<td>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Document(char);

<span class="kw">let </span>value = Document(<span class="string">'a'</span>);
</code></pre></div>
</td>
</tr>
<tr>
<td>
<div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;false&lt;/Document&gt;</code></pre></div><div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;0&lt;/Document&gt;</code></pre></div></td>
<td>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Serialize, Deserialize)]

</span><span class="kw">let </span>value = Document(<span class="bool-val">false</span>);
</code></pre></div>
</td>
</tr>
<tr><th colspan="2">integers</th></tr>
<tr>
<td>
<div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;123&lt;/Document&gt;</code></pre></div></td>
<td>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Document(i32);

<span class="kw">let </span>value = Document(<span class="number">123</span>);
</code></pre></div>
</td>
</tr>
<tr><th colspan="2">floats</th></tr>
<tr>
<td>
<div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;123&lt;/Document&gt;</code></pre></div><div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;123.0&lt;/Document&gt;</code></pre></div></td>
<td>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Document(f32);

<span class="kw">let </span>value = Document(<span class="number">123.0</span>);
</code></pre></div>
</td>
</tr>
</tbody>
</table>
<h3 id="child-elements"><a class="doc-anchor" href="#child-elements">§</a>Child elements</h3>
<p>Rust structs can be used to (de)serialize the contents of XML elements:
child elements, attributes, and text.
The name of the struct field must match the name of the corresponding child element.</p>
<table>
<thead>
<tr><th>XML</th><th>Rust</th></tr>
</thead>
<tbody>
<tr>
<td>
<div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;
  &lt;a&gt;abc&lt;/a&gt;
  &lt;b&gt;123&lt;/b&gt;
  &lt;c /&gt;
&lt;/Document&gt;</code></pre></div><div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;
  &lt;b&gt;123&lt;/b&gt;
  &lt;c /&gt;
  &lt;a&gt;abc&lt;/a&gt;
&lt;/Document&gt;</code></pre></div></td>
<td>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Document {
    a: String,
    b: i32,
    c: (),
}

<span class="kw">let </span>value = Document {
    a: <span class="string">"abc"</span>.to_string(),
    b: <span class="number">123</span>,
    c: (),
};
</code></pre></div>
</td>
</tr>
</tbody>
</table>
<h3 id="attributes"><a class="doc-anchor" href="#attributes">§</a>Attributes</h3>
<p>Fields that deserialize to and serialize from attributes must have a name starting with <code>@</code>.</p>
<table>
<thead>
<tr><th>XML</th><th>Rust</th></tr>
</thead>
<tbody>
<tr>
<td>
<div class="example-wrap"><pre class="language-xml"><code>&lt;Document a=&quot;abc&quot; b=&quot;123&quot; c=&quot;&quot; /&gt;</code></pre></div><div class="example-wrap"><pre class="language-xml"><code>&lt;Document c=&quot;&quot; b=&quot;123&quot; a=&quot;abc&quot; /&gt;</code></pre></div></td>
<td>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Document {
    <span class="attr">#[serde(rename = <span class="string">"@a"</span>)]
    </span>a: String,
    <span class="attr">#[serde(rename = <span class="string">"@b"</span>)]
    </span>b: i32,
    <span class="attr">#[serde(rename = <span class="string">"@c"</span>)]
    </span>c: (),
}

<span class="kw">let </span>value = Document {
    a: <span class="string">"abc"</span>.to_string(),
    b: <span class="number">123</span>,
    c: (),
};
</code></pre></div>
</td>
</tr>
</tbody>
</table>
<p>For serialization to work, all attributes must be declared before any child elements.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Document {
    <span class="attr">#[serde(rename = <span class="string">"@a"</span>)]
    </span>a: String,
    <span class="attr">#[serde(rename = <span class="string">"b"</span>)] </span><span class="comment">// This child element appears before an attribute
    </span>b: i32,
    <span class="attr">#[serde(rename = <span class="string">"@c"</span>)]
    </span>c: (),
}

<span class="kw">let </span>value = Document {
    a: <span class="string">"abc"</span>.to_string(),
    b: <span class="number">123</span>,
    c: (),
};

<span class="macro">assert!</span>(serde_xml_rs::to_string(<span class="kw-2">&amp;</span>value).is_err()); <span class="comment">// ERROR !</span></code></pre></div>
<h3 id="elements-with-attributes-and-text-content"><a class="doc-anchor" href="#elements-with-attributes-and-text-content">§</a>Elements with attributes and text content</h3>
<p>When an element (root or child) that contains both attributes and text content,
the struct type must have a field named <code>#text</code>.</p>
<p>Currently, mixed content with child elements and text is not supported.</p>
<table>
<thead>
<tr><th>XML</th><th>Rust</th></tr>
</thead>
<tbody>
<tr>
<td>
<div class="example-wrap"><pre class="language-xml"><code>&lt;Document id=&quot;123&quot;&gt;abc&lt;/Document&gt;</code></pre></div></td>
<td>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Document {
    <span class="attr">#[serde(rename = <span class="string">"@id"</span>)]
    </span>id: i32,
    <span class="attr">#[serde(rename = <span class="string">"#text"</span>)]
    </span>content: String,
}

<span class="kw">let </span>value = Document {
    id: <span class="number">123</span>,
    content: <span class="string">"abc"</span>.to_string(),
};
</code></pre></div>
</td>
</tr>
</tbody>
</table>
<h3 id="repeated-tags-and-sequences"><a class="doc-anchor" href="#repeated-tags-and-sequences">§</a>Repeated tags and sequences</h3>
<p>Repeated tags are handled by fields with a type of <code>Vec&lt;...&gt;</code>.
The name of the field must correspond to the name of the tag that is repeated.
All of the repeated tags must be consecutive, unless the <a href="config/struct.SerdeXml.html#method.overlapping_sequences" title="method serde_xml_rs::config::SerdeXml::overlapping_sequences">overlapping sequences</a> option is activated.</p>
<table>
<thead>
<tr><th>XML</th><th>Rust</th></tr>
</thead>
<tbody>
<tr>
<td>
<div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;
  &lt;item&gt;item1&lt;/item&gt;
  &lt;item&gt;item2&lt;/item&gt;
  &lt;item&gt;item3&lt;/item&gt;
&lt;/Document&gt;</code></pre></div></td>
<td>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Document {
    <span class="attr">#[serde(rename = <span class="string">"item"</span>)]
    </span>items: Vec&lt;String&gt;,
}

<span class="kw">let </span>value = Document {
    items: <span class="macro">vec!</span>[
        <span class="string">"item1"</span>.to_string(),
        <span class="string">"item2"</span>.to_string(),
        <span class="string">"item3"</span>.to_string(),
    ],
};
</code></pre></div>
</td>
</tr>
</tbody>
</table>
<h3 id="choices-and-enums"><a class="doc-anchor" href="#choices-and-enums">§</a>Choices and enums</h3>
<p>Enums can be used to represent different options.
The name of the variant must match the name of the child element.
Variants are handled much like their struct counterparts (unit, newtype, struct).</p>
<table>
<thead>
<tr><th>XML</th><th>Rust</th></tr>
</thead>
<tbody>
<tr>
<td>
<div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;
  &lt;message&gt;&lt;quit /&gt;&lt;/message&gt;
&lt;/Document&gt;</code></pre></div><div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;
  &lt;message&gt;
    &lt;move&gt;
      &lt;x&gt;1&lt;/x&gt;
      &lt;y&gt;2&lt;/y&gt;
    &lt;/move&gt;
  &lt;/message&gt;
&lt;/Document&gt;</code></pre></div><div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;
  &lt;message&gt;&lt;write&gt;a message&lt;/write&gt;&lt;/message&gt;
&lt;/Document&gt;</code></pre></div><div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;
  &lt;message&gt;&lt;change-color rgb=&quot;25 24 0&quot; /&gt;&lt;/message&gt;
&lt;/Document&gt;</code></pre></div></td>
<td>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Document {
    message: Message,
}

<span class="attr">#[derive(Serialize, Deserialize)]
#[serde(rename_all = <span class="string">"kebab-case"</span>)]
</span><span class="kw">enum </span>Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor {
        <span class="attr">#[serde(rename = <span class="string">"@rgb"</span>)]
        </span>rgb: (i32, i32, i32)
    },
}

<span class="kw">let </span>value = Document {
    message: Message::Move { x: <span class="number">1</span>, y: <span class="number">2 </span>},
};
</code></pre></div>
</td>
</tr>
</tbody>
</table>
<h3 id="enums-in-attribute-values"><a class="doc-anchor" href="#enums-in-attribute-values">§</a>Enums in attribute values</h3>
<p>Only unit variants can be used for attribute values.</p>
<table>
<thead>
<tr><th>XML</th><th>Rust</th></tr>
</thead>
<tbody>
<tr>
<td>
<div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;&lt;card rank=&quot;K&quot; suit=&quot;♣&quot; /&gt;&lt;/Document&gt;</code></pre></div></td>
<td>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Document {
    card: Card
}

<span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Card {
    <span class="attr">#[serde(rename = <span class="string">"@rank"</span>)]
    </span>rank: Rank,
    <span class="attr">#[serde(rename = <span class="string">"@suit"</span>)]
    </span>suit: Suit,
}

<span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">enum </span>Rank {
    <span class="attr">#[serde(rename = <span class="string">"2"</span>)] </span>_2,
    <span class="comment">// ...
    </span>K,
    A,
}

<span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">enum </span>Suit {
    <span class="attr">#[serde(rename = <span class="string">"♣"</span>)] </span>Clubs,
    <span class="comment">// ...
</span>}

<span class="kw">let </span>value = Document {
    card: Card { suit: Suit::Clubs, rank: Rank::K },
};
</code></pre></div>
</td>
</tr>
</tbody>
</table>
<h3 id="sequences-of-choices-and-content"><a class="doc-anchor" href="#sequences-of-choices-and-content">§</a>Sequences of choices and <code>#content</code></h3>
<p>Sequences of choices can be handled various ways:</p>
<ul>
<li>Without any configuration: a field named <code>item</code> with an enum type will be mapped to repeated element <code>&lt;item&gt;</code> containing a child element designating an enum variant and any parameters (<code>&lt;item&gt;&lt;variant-name&gt;content&lt;/variant-name&gt;&lt;/item&gt;</code>).</li>
<li>Using a field named <code>#content</code>: any child elements are treated as enum variants and are collected into the vector.</li>
<li>Container tag using an intermediate struct: <code>&lt;items&gt;&lt;item&gt;...&lt;/item&gt;&lt;item&gt;...&lt;/item&gt;...&lt;/items&gt;</code>. The ergonomics of this option may be improved in the future. In the meantime, look at <a href="https://docs.rs/serde-query/latest/serde_query/">serde-query</a>.</li>
</ul>
<table>
<thead>
<tr><th>XML</th><th>Rust</th></tr>
</thead>
<tbody>
<tr>
<td>
<div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;
  &lt;message&gt;&lt;quit /&gt;&lt;/message&gt;
  &lt;message&gt;&lt;change-color rgb=&quot;0 0 255&quot; /&gt;&lt;/message&gt;
&lt;/Document&gt;</code></pre></div></td>
<td>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Serialize, Deserialize)]
#[serde(rename_all = <span class="string">"kebab-case"</span>)]
</span><span class="kw">enum </span>Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor {
        <span class="attr">#[serde(rename = <span class="string">"@rgb"</span>)]
        </span>rgb: (i32, i32, i32)
    },
}

<span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Document {
    <span class="attr">#[serde(rename = <span class="string">"message"</span>)]
    </span>messages: Vec&lt;Message&gt;,
}

<span class="kw">let </span>value = Document {
    messages: <span class="macro">vec!</span>[Message::Quit, Message::ChangeColor { rgb: (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>) }],
};
</code></pre></div>
</td>
</tr>
<tr><th colspan="2">
<p>Using <code>#content</code></p>
</th></tr>
<tr>
<td>
<div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;
  &lt;quit /&gt;
  &lt;change-color rgb=&quot;0 0 255&quot; /&gt;
&lt;/Document&gt;</code></pre></div></td>
<td>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Document {
    <span class="attr">#[serde(rename = <span class="string">"#content"</span>)]
    </span>messages: Vec&lt;Message&gt;,
}

<span class="kw">let </span>value = Document {
    messages: <span class="macro">vec!</span>[Message::Quit, Message::ChangeColor { rgb: (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>) }],
};
</code></pre></div>
</td>
</tr>
<tr><th colspan="2">Container element</th></tr>
<tr>
<td>
<div class="example-wrap"><pre class="language-xml"><code>&lt;Document&gt;
  &lt;messages&gt;
    &lt;message&gt;&lt;quit /&gt;&lt;/message&gt;
    &lt;message&gt;&lt;change-color rgb=&quot;0 0 255&quot; /&gt;&lt;/message&gt;
  &lt;/messages&gt;
&lt;/Document&gt;</code></pre></div></td>
<td>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Messages {
    <span class="attr">#[serde(rename = <span class="string">"message"</span>)]
    </span>messages: Vec&lt;Message&gt;
}

<span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Document {
    messages: Messages,
}

<span class="kw">let </span>value = Document {
    messages: Messages {
        messages: <span class="macro">vec!</span>[
            Message::Quit,
            Message::ChangeColor { rgb: (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>) },
        ],
    },
};
</code></pre></div>
</td>
</tr>
</tbody>
</table>
<h3 id="xml-namespaces"><a class="doc-anchor" href="#xml-namespaces">§</a>XML Namespaces</h3>
<p>Any XML namespaces declared in a document are mapped to a prefix.
That prefix can then appears in the names of attributes and elements.
The prefix must also appear in the names of the corresponding Rust fields.</p>
<ul>
<li><strong>Deserialization:</strong> Only prefixes matter. Any <code>xmlns...</code> attributes are ignored.</li>
<li><strong>Serialization:</strong> The mapping between prefixes and namespace URI must be provided (<a href="config/struct.SerdeXml.html#method.namespace" title="method serde_xml_rs::config::SerdeXml::namespace">see SerdeXml::namespace</a>). All namespaces are declared in the root element.</li>
</ul>
<table>
<thead>
<tr><th>XML</th><th>Rust</th></tr>
</thead>
<tbody>
<tr>
<td>
<div class="example-wrap"><pre class="language-xml"><code>&lt;Document xmlns=&quot;urn:example:default&quot; xmlns:a=&quot;urn:example:a&quot;&gt;
  &lt;a:a&gt;abc&lt;/a:a&gt;
  &lt;b&gt;123&lt;/b&gt;
  &lt;c a:id=&quot;456&quot; /&gt;
&lt;/Document&gt;</code></pre></div></td>
<td>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Document {
    <span class="attr">#[serde(rename = <span class="string">"a:a"</span>)]
    </span>a: String,
    b: i32,
    c: C,
}

<span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>C {
    <span class="attr">#[serde(rename = <span class="string">"@a:id"</span>)]
    </span>id: i32,
}

<span class="kw">let </span>value = Document {
    a: <span class="string">"abc"</span>.to_string(),
    b: <span class="number">123</span>,
    c: C { id: <span class="number">456 </span>},
};

<span class="macro">assert_eq!</span>(serde_xml_rs::from_str::&lt;Document&gt;(text).unwrap(), value);

<span class="kw">let </span>config = serde_xml_rs::SerdeXml::new()
    .default_namespace(<span class="string">"urn:example:default"</span>)
    .namespace(<span class="string">"a"</span>, <span class="string">"urn:example:a"</span>);
<span class="macro">assert_eq!</span>(config.to_string(<span class="kw-2">&amp;</span>value).unwrap(), text);</code></pre></div>
</td>
</tr>
</tbody>
</table>
<h2 id="custom-eventreader"><a class="doc-anchor" href="#custom-eventreader">§</a>Custom EventReader</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>serde::{Deserialize, Serialize};
<span class="kw">use </span>serde_xml_rs::{from_str, to_string, de::Deserializer};
<span class="kw">use </span>xml::reader::{EventReader, ParserConfig};

<span class="attr">#[derive(Debug, Serialize, Deserialize, PartialEq)]
</span><span class="kw">struct </span>Item {
    name: String,
    source: String,
}

<span class="kw">let </span>src = <span class="string">r#"&lt;Item&gt;&lt;name&gt;  Banana  &lt;/name&gt;&lt;source&gt;Store&lt;/source&gt;&lt;/Item&gt;"#</span>;
<span class="kw">let </span>should_be = Item {
    name: <span class="string">"  Banana  "</span>.to_string(),
    source: <span class="string">"Store"</span>.to_string(),
};

<span class="kw">let </span>config = ParserConfig::new()
    .trim_whitespace(<span class="bool-val">false</span>)
    .whitespace_to_characters(<span class="bool-val">true</span>);
<span class="kw">let </span>event_reader = EventReader::new_with_config(src.as_bytes(), config);
<span class="kw">let </span>item = Item::deserialize(<span class="kw-2">&amp;mut </span>Deserializer::new(event_reader)).unwrap();
<span class="macro">assert_eq!</span>(item, should_be);
</code></pre></div>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.SerdeXml"><code>pub use crate::config::<a class="struct" href="config/struct.SerdeXml.html" title="struct serde_xml_rs::config::SerdeXml">SerdeXml</a>;</code></dt><dt id="reexport.from_reader"><code>pub use crate::de::<a class="fn" href="de/fn.from_reader.html" title="fn serde_xml_rs::de::from_reader">from_reader</a>;</code></dt><dt id="reexport.from_str"><code>pub use crate::de::<a class="fn" href="de/fn.from_str.html" title="fn serde_xml_rs::de::from_str">from_str</a>;</code></dt><dt id="reexport.Deserializer"><code>pub use crate::de::<a class="struct" href="de/struct.Deserializer.html" title="struct serde_xml_rs::de::Deserializer">Deserializer</a>;</code></dt><dt id="reexport.to_string"><code>pub use crate::ser::<a class="fn" href="ser/fn.to_string.html" title="fn serde_xml_rs::ser::to_string">to_string</a>;</code></dt><dt id="reexport.to_writer"><code>pub use crate::ser::<a class="fn" href="ser/fn.to_writer.html" title="fn serde_xml_rs::ser::to_writer">to_writer</a>;</code></dt><dt id="reexport.Serializer"><code>pub use crate::ser::<a class="struct" href="ser/struct.Serializer.html" title="struct serde_xml_rs::ser::Serializer">Serializer</a>;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="config/index.html" title="mod serde_xml_rs::config">config</a></dt><dt><a class="mod" href="de/index.html" title="mod serde_xml_rs::de">de</a></dt><dt><a class="mod" href="ser/index.html" title="mod serde_xml_rs::ser">ser</a></dt></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Error.html" title="enum serde_xml_rs::Error">Error</a></dt></dl></section></div></main></body></html>