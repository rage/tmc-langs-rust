<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Common interface for memory regions."><title>BitStore in bitvec::store - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="bitvec" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../bitvec/index.html">bitvec</a><span class="version">0.19.6</span></h2></div><h2 class="location"><a href="#">BitStore</a></h2><div class="sidebar-elems"><section><h3><a href="#required-associated-types">Required Associated Types</a></h3><ul class="block"><li><a href="#associatedtype.Access">Access</a></li><li><a href="#associatedtype.Alias">Alias</a></li><li><a href="#associatedtype.Mem">Mem</a></li></ul><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.load_value">load_value</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.get_bit">get_bit</a></li><li><a href="#method.get_bits">get_bits</a></li></ul><h3><a href="#foreign-impls">Implementations on Foreign Types</a></h3><ul class="block"><li><a href="#impl-BitStore-for-Cell%3CR%3E">Cell&lt;R&gt;</a></li><li><a href="#impl-BitStore-for-u16">u16</a></li><li><a href="#impl-BitStore-for-u32">u32</a></li><li><a href="#impl-BitStore-for-u64">u64</a></li><li><a href="#impl-BitStore-for-u8">u8</a></li><li><a href="#impl-BitStore-for-usize">usize</a></li></ul><h3><a href="#object-safety">Object Safety</a></h3><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In bitvec::store</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Trait <a href="../index.html">bitvec</a>::<wbr><a href="index.html">store</a>::<wbr><a class="trait" href="#">BitStore</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/bitvec/store.rs.html#82-170">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub trait BitStore: Sealed + <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> {
    type <a href="#associatedtype.Mem" class="associatedtype">Mem</a>: <a class="trait" href="../index/trait.BitRegister.html" title="trait bitvec::index::BitRegister">BitRegister</a> + <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;Self&gt;;
    type <a href="#associatedtype.Access" class="associatedtype">Access</a>: BitAccess&lt;Item = Self::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>&gt;;
    type <a href="#associatedtype.Alias" class="associatedtype">Alias</a>: <a class="trait" href="trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a> + <a class="trait" href="../../radium/trait.Radium.html" title="trait radium::Radium">Radium</a>&lt;Item = Self::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>&gt;;

    // Required method
    fn <a href="#tymethod.load_value" class="fn">load_value</a>(&amp;self) -&gt; Self::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>;

    // Provided methods
    fn <a href="#method.get_bit" class="fn">get_bit</a>&lt;O&gt;(&amp;self, index: <a class="struct" href="../index/struct.BitIdx.html" title="struct bitvec::index::BitIdx">BitIdx</a>&lt;Self::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>
       <span class="where">where O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.get_bits" class="fn">get_bits</a>(&amp;self, mask: <a class="struct" href="../index/struct.BitMask.html" title="struct bitvec::index::BitMask">BitMask</a>&lt;Self::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>&gt;) -&gt; Self::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a> { ... }
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Common interface for memory regions.</p>
<p>This trait is implemented on the fundamental integers no wider than the target
processor word size, their <code>Cell</code> wrappers, and (if present) their <code>Atomic</code>
variants. Users provide this type as a parameter to their data structures in
order to inform the structure of how it may access the memory it describes.</p>
<p>Currently, <code>bitvec</code> is only tested on 32- and 64- bit architectures. This means
that <code>u8</code>, <code>u16</code>, <code>u32</code>, and <code>usize</code> unconditionally implement <code>BitStore</code>, but
<code>u64</code> will only do so on 64-bit targets, and will be unavailable on 32-bit
targets. This is a necessary restriction of <code>bitvec</code> internals. Please comment
on <a href="https://github.com/myrrlyn/bitvec/issues/76">Issue #76</a> if this affects you.</p>
<p>Specifically, this has the davantage that a <code>BitSlice&lt;_, Cell&lt;_&gt;&gt;</code> knows that it
has a view of memory that will not undergo concurrent modification. As such, it
can forego atomic accesses, and just use ordinary load/store instructions
without fear of causing observable race conditions.</p>
<p>The associated types <code>Mem</code> and <code>Alias</code> allow implementors to know the register
width of the memory they describe (<code>Mem</code>) and to know the aliasing status of the
region.</p>
<h2 id="generic-programming"><a class="doc-anchor" href="#generic-programming">§</a>Generic Programming</h2>
<p>Generic programming with associated types is <em>hard</em>, especially when using them,
as in this trait, to implement a closed graph of relationships between types.</p>
<p>For example, this trait is implemented such that for any given type <code>T</code>,
<code>T::Alias::Mem</code> == <code>T::Mem</code> == <code>T::NoAlias::Mem</code>, <code>T::Alias::Alias == T::Alias</code>,
and <code>T::NoAlias::NoAlias == T::NoAlias</code>. Unfortunately, the Rust type system
does not allow these relationships to be described, so generic programming that
performs type transitions will <em>rapidly</em> become uncomfortable to use.</p>
<p>Internally, <code>bitvec</code> makes use of type-manipulation functions that are known to
be correct with respect to the implementations of <code>BitStore</code> in order to ease
implementation of library methods.</p>
<p>You are not expected to do significant programming that is generic over the
<code>BitStore</code> memory parameter. When using a concrete type, the compiler will
gladly reduce the abstract type associations into their instantiated selections,
allowing monomorphized code to be <em>much</em> more convenient than generic.</p>
<p>If you have a use case that involves generic programming over this trait, and
you are encountering difficulties dealing with the type associations, please
file an issue asking for support in this area.</p>
<h2 id="supertraits"><a class="doc-anchor" href="#supertraits">§</a>Supertraits</h2>
<p>This trait has trait requirements that better express its behavior:</p>
<ul>
<li><code>Sealed</code> prevents it from being implemented by downstream libraries (<code>Sealed</code>
is a public trait in a private module, that only this crate can name).</li>
<li><code>Sized</code> instructs the compiler that values of this type can be used as
immediates.</li>
<li><code>Debug</code> informs the compiler that other structures using this trait bound can
correctly derive <code>Debug</code>.
*</li>
</ul>
</div></details><h2 id="required-associated-types" class="section-header">Required Associated Types<a href="#required-associated-types" class="anchor">§</a></h2><div class="methods"><details class="toggle" open><summary><section id="associatedtype.Mem" class="method"><a class="src rightside" href="../../src/bitvec/store.rs.html#84">source</a><h4 class="code-header">type <a href="#associatedtype.Mem" class="associatedtype">Mem</a>: <a class="trait" href="../index/trait.BitRegister.html" title="trait bitvec::index::BitRegister">BitRegister</a> + <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>The register type that the implementor describes.</p>
</div></details><details class="toggle" open><summary><section id="associatedtype.Access" class="method"><a class="src rightside" href="../../src/bitvec/store.rs.html#87">source</a><h4 class="code-header">type <a href="#associatedtype.Access" class="associatedtype">Access</a>: BitAccess&lt;Item = Self::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>&gt;</h4></section></summary><div class="docblock"><p>The modifier type over <code>Self::Mem</code> used to perform memory access.</p>
</div></details><details class="toggle" open><summary><section id="associatedtype.Alias" class="method"><a class="src rightside" href="../../src/bitvec/store.rs.html#100">source</a><h4 class="code-header">type <a href="#associatedtype.Alias" class="associatedtype">Alias</a>: <a class="trait" href="trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a> + <a class="trait" href="../../radium/trait.Radium.html" title="trait radium::Radium">Radium</a>&lt;Item = Self::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>&gt;</h4></section></summary><div class="docblock"><p>A sibling <code>BitStore</code> implementor that performs alias-aware memory
access.</p>
<p>While the associated type always has the same <code>Mem</code> concrete type as
<code>Self</code>, attempting to encode this requirement as `&lt;Mem = Self::Mem&gt;
causes Rust to enter an infinite recursion in the trait solver.</p>
<p>Instead, the two <code>Radium</code> bounds inform the compiler that the <code>Alias</code> is
irradiant over both the current memory and the destination memory types,
allowing generic type algebra to resolve correctly even though the fact
that <code>Radium</code> is only implemented once is not guaranteed.</p>
</div></details></div><h2 id="required-methods" class="section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.load_value" class="method"><a class="src rightside" href="../../src/bitvec/store.rs.html#128">source</a><h4 class="code-header">fn <a href="#tymethod.load_value" class="fn">load_value</a>(&amp;self) -&gt; Self::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a></h4></section></summary><div class="docblock"><p>Copies a memory element into the caller’s local context.</p>
<h5 id="parameters"><a class="doc-anchor" href="#parameters">§</a>Parameters</h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns"><a class="doc-anchor" href="#returns">§</a>Returns</h5>
<p>A copy of the value at <code>*self</code>.</p>
</div></details></div><h2 id="provided-methods" class="section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.get_bit" class="method"><a class="src rightside" href="../../src/bitvec/store.rs.html#144-147">source</a><h4 class="code-header">fn <a href="#method.get_bit" class="fn">get_bit</a>&lt;O&gt;(&amp;self, index: <a class="struct" href="../index/struct.BitIdx.html" title="struct bitvec::index::BitIdx">BitIdx</a>&lt;Self::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a><div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</div></h4></section></summary><div class="docblock"><p>Fetches the value of one bit in a memory element.</p>
<h5 id="type-parameters"><a class="doc-anchor" href="#type-parameters">§</a>Type Parameters</h5>
<ul>
<li><code>O</code>: A bit ordering.</li>
</ul>
<h5 id="parameters-1"><a class="doc-anchor" href="#parameters-1">§</a>Parameters</h5>
<ul>
<li><code>&amp;self</code></li>
<li><code>index</code>: The semantic index of the bit in <code>*self</code> to read.</li>
</ul>
<h5 id="returns-1"><a class="doc-anchor" href="#returns-1">§</a>Returns</h5>
<p>The value of the bit in <code>*self</code> corresponding to <code>index</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_bits" class="method"><a class="src rightside" href="../../src/bitvec/store.rs.html#167-169">source</a><h4 class="code-header">fn <a href="#method.get_bits" class="fn">get_bits</a>(&amp;self, mask: <a class="struct" href="../index/struct.BitMask.html" title="struct bitvec::index::BitMask">BitMask</a>&lt;Self::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>&gt;) -&gt; Self::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a></h4></section></summary><div class="docblock"><p>Fetches any number of bits from a memory element.</p>
<p>The mask provided to this method must be constructed from indices that
are valid in the caller’s context. As the mask is already computed by
the caller, this does not take an ordering type parameter.</p>
<h5 id="parameters-2"><a class="doc-anchor" href="#parameters-2">§</a>Parameters</h5>
<ul>
<li><code>&amp;self</code></li>
<li><code>mask</code>: A mask of any number of bits. This is a selection mask of bits
to read.</li>
</ul>
<h5 id="returns-2"><a class="doc-anchor" href="#returns-2">§</a>Returns</h5>
<p>A copy of the memory element at <code>*self</code>, with all bits not selected (set
to <code>0</code>) in <code>mask</code> erased and all bits selected (set to <code>1</code>) in <code>mask</code>
preserved.</p>
</div></details></div><h2 id="object-safety" class="section-header">Object Safety<a href="#object-safety" class="anchor">§</a></h2><div class="object-safety-info">This trait is <b>not</b> <a href="https://doc.rust-lang.org/1.81.0/reference/items/traits.html#object-safety">object safe</a>.</div><h2 id="foreign-impls" class="section-header">Implementations on Foreign Types<a href="#foreign-impls" class="anchor">§</a></h2><details class="toggle implementors-toggle"><summary><section id="impl-BitStore-for-u8" class="impl"><a class="src rightside" href="../../src/bitvec/store.rs.html#236-240">source</a><a href="#impl-BitStore-for-u8" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a> for <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Access-1" class="associatedtype trait-impl"><a href="#associatedtype.Access-1" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Access" class="associatedtype">Access</a> = <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>&gt;</h4></section></summary><div class="docblock"><p>The unsigned integers will only be <code>BitStore</code> type parameters
for handles to unaliased memory, following the normal Rust
reference rules.</p>
</div></details><details class="toggle" open><summary><section id="associatedtype.Alias-1" class="associatedtype trait-impl"><a href="#associatedtype.Alias-1" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Alias" class="associatedtype">Alias</a> = <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>&gt;</h4></section></summary><div class="docblock"><p>In non-atomic builds, use cell wrappers for aliased access.</p>
</div></details><section id="associatedtype.Mem-1" class="associatedtype trait-impl"><a href="#associatedtype.Mem-1" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Mem" class="associatedtype">Mem</a> = <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a></h4></section><section id="method.load_value" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/store.rs.html#236-240">source</a><a href="#method.load_value" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.load_value" class="fn">load_value</a>(&amp;self) -&gt; Self::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a></h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BitStore-for-u16" class="impl"><a class="src rightside" href="../../src/bitvec/store.rs.html#236-240">source</a><a href="#impl-BitStore-for-u16" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a> for <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u16.html">u16</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Access-2" class="associatedtype trait-impl"><a href="#associatedtype.Access-2" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Access" class="associatedtype">Access</a> = <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u16.html">u16</a>&gt;</h4></section></summary><div class="docblock"><p>The unsigned integers will only be <code>BitStore</code> type parameters
for handles to unaliased memory, following the normal Rust
reference rules.</p>
</div></details><details class="toggle" open><summary><section id="associatedtype.Alias-2" class="associatedtype trait-impl"><a href="#associatedtype.Alias-2" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Alias" class="associatedtype">Alias</a> = <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u16.html">u16</a>&gt;</h4></section></summary><div class="docblock"><p>In non-atomic builds, use cell wrappers for aliased access.</p>
</div></details><section id="associatedtype.Mem-2" class="associatedtype trait-impl"><a href="#associatedtype.Mem-2" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Mem" class="associatedtype">Mem</a> = <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u16.html">u16</a></h4></section><section id="method.load_value-1" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/store.rs.html#236-240">source</a><a href="#method.load_value-1" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.load_value" class="fn">load_value</a>(&amp;self) -&gt; Self::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a></h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BitStore-for-u32" class="impl"><a class="src rightside" href="../../src/bitvec/store.rs.html#236-240">source</a><a href="#impl-BitStore-for-u32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a> for <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u32.html">u32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Access-3" class="associatedtype trait-impl"><a href="#associatedtype.Access-3" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Access" class="associatedtype">Access</a> = <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u32.html">u32</a>&gt;</h4></section></summary><div class="docblock"><p>The unsigned integers will only be <code>BitStore</code> type parameters
for handles to unaliased memory, following the normal Rust
reference rules.</p>
</div></details><details class="toggle" open><summary><section id="associatedtype.Alias-3" class="associatedtype trait-impl"><a href="#associatedtype.Alias-3" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Alias" class="associatedtype">Alias</a> = <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u32.html">u32</a>&gt;</h4></section></summary><div class="docblock"><p>In non-atomic builds, use cell wrappers for aliased access.</p>
</div></details><section id="associatedtype.Mem-3" class="associatedtype trait-impl"><a href="#associatedtype.Mem-3" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Mem" class="associatedtype">Mem</a> = <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u32.html">u32</a></h4></section><section id="method.load_value-2" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/store.rs.html#236-240">source</a><a href="#method.load_value-2" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.load_value" class="fn">load_value</a>(&amp;self) -&gt; Self::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a></h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BitStore-for-u64" class="impl"><a class="src rightside" href="../../src/bitvec/store.rs.html#243">source</a><a href="#impl-BitStore-for-u64" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a> for <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u64.html">u64</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Access-4" class="associatedtype trait-impl"><a href="#associatedtype.Access-4" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Access" class="associatedtype">Access</a> = <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u64.html">u64</a>&gt;</h4></section></summary><div class="docblock"><p>The unsigned integers will only be <code>BitStore</code> type parameters
for handles to unaliased memory, following the normal Rust
reference rules.</p>
</div></details><details class="toggle" open><summary><section id="associatedtype.Alias-4" class="associatedtype trait-impl"><a href="#associatedtype.Alias-4" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Alias" class="associatedtype">Alias</a> = <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u64.html">u64</a>&gt;</h4></section></summary><div class="docblock"><p>In non-atomic builds, use cell wrappers for aliased access.</p>
</div></details><section id="associatedtype.Mem-4" class="associatedtype trait-impl"><a href="#associatedtype.Mem-4" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Mem" class="associatedtype">Mem</a> = <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u64.html">u64</a></h4></section><section id="method.load_value-3" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/store.rs.html#243">source</a><a href="#method.load_value-3" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.load_value" class="fn">load_value</a>(&amp;self) -&gt; Self::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a></h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BitStore-for-usize" class="impl"><a class="src rightside" href="../../src/bitvec/store.rs.html#245">source</a><a href="#impl-BitStore-for-usize" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a> for <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Access-5" class="associatedtype trait-impl"><a href="#associatedtype.Access-5" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Access" class="associatedtype">Access</a> = <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>The unsigned integers will only be <code>BitStore</code> type parameters
for handles to unaliased memory, following the normal Rust
reference rules.</p>
</div></details><details class="toggle" open><summary><section id="associatedtype.Alias-5" class="associatedtype trait-impl"><a href="#associatedtype.Alias-5" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Alias" class="associatedtype">Alias</a> = <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>In non-atomic builds, use cell wrappers for aliased access.</p>
</div></details><section id="associatedtype.Mem-5" class="associatedtype trait-impl"><a href="#associatedtype.Mem-5" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Mem" class="associatedtype">Mem</a> = <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a></h4></section><section id="method.load_value-4" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/store.rs.html#245">source</a><a href="#method.load_value-4" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.load_value" class="fn">load_value</a>(&amp;self) -&gt; Self::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a></h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BitStore-for-Cell%3CR%3E" class="impl"><a class="src rightside" href="../../src/bitvec/store.rs.html#247-271">source</a><a href="#impl-BitStore-for-Cell%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a> for <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;R&gt;<div class="where">where
    Self: <a class="trait" href="../../radium/trait.Radium.html" title="trait radium::Radium">Radium</a>&lt;Item = R&gt;,
    R: <a class="trait" href="../index/trait.BitRegister.html" title="trait bitvec::index::BitRegister">BitRegister</a>,</div></h3></section></summary><div class="impl-items"><section id="associatedtype.Access-6" class="associatedtype trait-impl"><a href="#associatedtype.Access-6" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Access" class="associatedtype">Access</a> = <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;R&gt;</h4></section><section id="associatedtype.Alias-6" class="associatedtype trait-impl"><a href="#associatedtype.Alias-6" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Alias" class="associatedtype">Alias</a> = <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;R&gt;</h4></section><section id="associatedtype.Mem-6" class="associatedtype trait-impl"><a href="#associatedtype.Mem-6" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Mem" class="associatedtype">Mem</a> = R</h4></section><section id="method.load_value-5" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/store.rs.html#268-270">source</a><a href="#method.load_value-5" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.load_value" class="fn">load_value</a>(&amp;self) -&gt; Self::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a></h4></section></div></details><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"></div><script src="../../trait.impl/bitvec/store/trait.BitStore.js" data-ignore-extern-crates="std,core" async></script></section></div></main></body></html>