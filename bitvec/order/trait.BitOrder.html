<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An ordering over a register."><title>BitOrder in bitvec::order - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="bitvec" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../bitvec/index.html">bitvec</a><span class="version">0.19.6</span></h2></div><h2 class="location"><a href="#">BitOrder</a></h2><div class="sidebar-elems"><section><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.at">at</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.mask">mask</a></li><li><a href="#method.select">select</a></li></ul><h3><a href="#object-safety">Object Safety</a></h3><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In bitvec::order</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Trait <a href="../index.html">bitvec</a>::<wbr><a href="index.html">order</a>::<wbr><a class="trait" href="#">BitOrder</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/bitvec/order.rs.html#91-239">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub unsafe trait BitOrder {
    // Required method
    fn <a href="#tymethod.at" class="fn">at</a>&lt;R&gt;(index: <a class="struct" href="../index/struct.BitIdx.html" title="struct bitvec::index::BitIdx">BitIdx</a>&lt;R&gt;) -&gt; <a class="struct" href="../index/struct.BitPos.html" title="struct bitvec::index::BitPos">BitPos</a>&lt;R&gt;
       <span class="where">where R: <a class="trait" href="../index/trait.BitRegister.html" title="trait bitvec::index::BitRegister">BitRegister</a></span>;

    // Provided methods
    fn <a href="#method.select" class="fn">select</a>&lt;R&gt;(index: <a class="struct" href="../index/struct.BitIdx.html" title="struct bitvec::index::BitIdx">BitIdx</a>&lt;R&gt;) -&gt; <a class="struct" href="../index/struct.BitSel.html" title="struct bitvec::index::BitSel">BitSel</a>&lt;R&gt;
       <span class="where">where R: <a class="trait" href="../index/trait.BitRegister.html" title="trait bitvec::index::BitRegister">BitRegister</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.mask" class="fn">mask</a>&lt;R&gt;(
        from: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../index/struct.BitIdx.html" title="struct bitvec::index::BitIdx">BitIdx</a>&lt;R&gt;&gt;&gt;,
        upto: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../index/struct.BitTail.html" title="struct bitvec::index::BitTail">BitTail</a>&lt;R&gt;&gt;&gt;,
    ) -&gt; <a class="struct" href="../index/struct.BitMask.html" title="struct bitvec::index::BitMask">BitMask</a>&lt;R&gt;
       <span class="where">where R: <a class="trait" href="../index/trait.BitRegister.html" title="trait bitvec::index::BitRegister">BitRegister</a></span> { ... }
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>An ordering over a register.</p>
<h2 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h2>
<p><code>bitvec</code> structures store and operate on semantic counts, not bit positions. The
<code>BitOrder::at</code> function takes a semantic ordering, <code>BitIdx</code>, and produces an
electrical position, <code>BitPos</code>.</p>
<h2 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h2>
<p>If your implementation violates any of the requirements on these functions, then
the program will become incorrect and have unspecified behavior. The best-case
scenario is that operations relying on your implementation will crash the
program; the worst-case is that memory access will silently become corrupt.</p>
<p>You are responsible for adhering to the requirements of these functions. In the
future, a verification function may be provided for your test suite; however, it
is not yet possible to verify your implementation at compile-time.</p>
<p>This is an <code>unsafe trait</code> to implement, because you are responsible for
upholding the state requirements. The types you manipulate have <code>unsafe fn</code>
constructors, because they require you to maintain correct and consistent
processes in order for the rest of the library to use them.</p>
<p>The implementations of <code>BitOrder</code> are trusted to drive safe code, and once data
leaves a <code>BitOrder</code> implementation, it is considered safe to use as the basis
for interaction with memory.</p>
<h2 id="verification"><a class="doc-anchor" href="#verification">§</a>Verification</h2>
<p>Rust currently lacks Zig’s compile-time computation capability. This means that
<code>bitvec</code> cannot fail a compile if it detects that a <code>BitOrder</code> implementation is
invalid and breaks the stated requirements. <code>bitvec</code> does offer a function,
<a href="fn.verify.html"><code>verify</code></a>, which ensures the correctness of an implementation. When Rust gains
the capability to run this function in generic <code>const</code> contexts, <code>bitvec</code> will
use it to prevent at compile-time the construction of data structures that use
incorrect ordering implementations.</p>
<p>The verifier function panics when it detects invalid behavior, with an error
message intended to clearly indicate the broken requirement.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::{
  index::{BitIdx, BitPos, BitRegister},
  order::{<span class="self">self</span>, BitOrder},
};

<span class="kw">pub struct </span>Custom;
<span class="kw">unsafe impl </span>BitOrder <span class="kw">for </span>Custom {
  <span class="kw">fn </span>at&lt;R: BitRegister&gt;(idx: BitIdx&lt;R&gt;) -&gt; BitPos&lt;R&gt; {
  <span class="comment">// impl
  </span>}
}

<span class="attr">#[test]
#[cfg(test)]
</span><span class="kw">fn </span>prove_custom() {
  order::verify::&lt;Custom&gt;();
}</code></pre></div>
</div></details><h2 id="required-methods" class="section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.at" class="method"><a class="src rightside" href="../../src/bitvec/order.rs.html#150-151">source</a><h4 class="code-header">fn <a href="#tymethod.at" class="fn">at</a>&lt;R&gt;(index: <a class="struct" href="../index/struct.BitIdx.html" title="struct bitvec::index::BitIdx">BitIdx</a>&lt;R&gt;) -&gt; <a class="struct" href="../index/struct.BitPos.html" title="struct bitvec::index::BitPos">BitPos</a>&lt;R&gt;<div class="where">where
    R: <a class="trait" href="../index/trait.BitRegister.html" title="trait bitvec::index::BitRegister">BitRegister</a>,</div></h4></section></summary><div class="docblock"><p>Converts a semantic bit index into an electrical bit position.</p>
<p>This function is the basis of the trait, and must adhere to a number of
requirements in order for an implementation to be considered correct.</p>
<h5 id="parameters"><a class="doc-anchor" href="#parameters">§</a>Parameters</h5>
<ul>
<li><code>index</code>: The semantic index of a bit within a register <code>R</code>.</li>
</ul>
<h5 id="returns"><a class="doc-anchor" href="#returns">§</a>Returns</h5>
<p>The electrical position of the indexed bit within a register <code>R</code>. See
the <code>BitPos</code> documentation for what electrical positions are considered
to mean.</p>
<h5 id="type-parameters"><a class="doc-anchor" href="#type-parameters">§</a>Type Parameters</h5>
<ul>
<li><code>R</code>: The register type which the index and position describe.</li>
</ul>
<h5 id="requirements"><a class="doc-anchor" href="#requirements">§</a>Requirements</h5>
<p>This function must satisfy the following requirements for all possible
input and output values for all possible type parameters:</p>
<h6 id="totality"><a class="doc-anchor" href="#totality">§</a>Totality</h6>
<p>This function must be able to accept every input in the <code>BitIdx&lt;R&gt;</code>
value range, and produce a corresponding <code>BitPos&lt;R&gt;</code>. It must not abort
the program or return an invalid <code>BitPos&lt;R&gt;</code> for any input value in the
<code>BitIdx&lt;R&gt;</code> range.</p>
<h6 id="bijection"><a class="doc-anchor" href="#bijection">§</a>Bijection</h6>
<p>There must be an exactly one-to-one correspondence between input value
and output value. No input index may select from a set of more than one
output position, and no output position may be produced by more than one
input index.</p>
<h6 id="purity"><a class="doc-anchor" href="#purity">§</a>Purity</h6>
<p>The translation from index to position must be consistent for the
lifetime of the program. This function <em>may</em> refer to global state, but
that state <strong>must</strong> be immutable for the program lifetime, and must not
be used to violate the totality or bijection requirements.</p>
<h6 id="output-validity"><a class="doc-anchor" href="#output-validity">§</a>Output Validity</h6>
<p>The produced <code>BitPos&lt;R&gt;</code> must be within the valid range of that type.
Call sites of this function will not take any steps to constrain the
output value. If you use <code>unsafe</code> code to produce an invalid
<code>BitPos&lt;R&gt;</code>, the program is permanently incorrect, and will likely
crash.</p>
<h5 id="usage-1"><a class="doc-anchor" href="#usage-1">§</a>Usage</h5>
<p>This function will only ever be called with input values in the valid
<code>BitIdx&lt;R&gt;</code> range. Implementors are not required to consider any values
outside this range in their function body.</p>
</div></details></div><h2 id="provided-methods" class="section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.select" class="method"><a class="src rightside" href="../../src/bitvec/order.rs.html#186-189">source</a><h4 class="code-header">fn <a href="#method.select" class="fn">select</a>&lt;R&gt;(index: <a class="struct" href="../index/struct.BitIdx.html" title="struct bitvec::index::BitIdx">BitIdx</a>&lt;R&gt;) -&gt; <a class="struct" href="../index/struct.BitSel.html" title="struct bitvec::index::BitSel">BitSel</a>&lt;R&gt;<div class="where">where
    R: <a class="trait" href="../index/trait.BitRegister.html" title="trait bitvec::index::BitRegister">BitRegister</a>,</div></h4></section></summary><div class="docblock"><p>Converts a semantic bit index into a one-hot selector mask.</p>
<p>This is an optional function; a default implementation is provided for
you.</p>
<p>The default implementation of this function calls <code>Self::at</code> to produce
an electrical position, then turns that into a selector mask by setting
the <code>n</code>th bit more significant than the least significant bit of the
element. <code>BitOrder</code> implementations may choose to provide a faster mask
production here, but they must satisfy the requirements listed below.</p>
<h5 id="parameters-1"><a class="doc-anchor" href="#parameters-1">§</a>Parameters</h5>
<ul>
<li><code>index</code>: The semantic index of a bit within a register <code>R</code>.</li>
</ul>
<h5 id="returns-1"><a class="doc-anchor" href="#returns-1">§</a>Returns</h5>
<p>A one-hot selector mask for the bit indicated by the index value.</p>
<h5 id="type-parameters-1"><a class="doc-anchor" href="#type-parameters-1">§</a>Type Parameters</h5>
<ul>
<li><code>R</code>: The storage type for which the mask will be calculated. The mask
must also be this type, as it will be applied to a register of <code>R</code> in
order to set, clear, or test a single bit.</li>
</ul>
<h5 id="requirements-1"><a class="doc-anchor" href="#requirements-1">§</a>Requirements</h5>
<p>A one-hot encoding means that there is exactly one bit set in the
produced value. It must be equivalent to <code>1 &lt;&lt; Self::at::&lt;R&gt;(place)</code>.</p>
<p>As with <code>at</code>, this function must produce a unique mapping from each
legal index in the <code>R</code> domain to a one-hot value of <code>R</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.mask" class="method"><a class="src rightside" href="../../src/bitvec/order.rs.html#224-238">source</a><h4 class="code-header">fn <a href="#method.mask" class="fn">mask</a>&lt;R&gt;(
    from: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../index/struct.BitIdx.html" title="struct bitvec::index::BitIdx">BitIdx</a>&lt;R&gt;&gt;&gt;,
    upto: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../index/struct.BitTail.html" title="struct bitvec::index::BitTail">BitTail</a>&lt;R&gt;&gt;&gt;,
) -&gt; <a class="struct" href="../index/struct.BitMask.html" title="struct bitvec::index::BitMask">BitMask</a>&lt;R&gt;<div class="where">where
    R: <a class="trait" href="../index/trait.BitRegister.html" title="trait bitvec::index::BitRegister">BitRegister</a>,</div></h4></section></summary><div class="docblock"><p>Constructs a multi-bit selector mask for batch operations on a single
register <code>R</code>.</p>
<p>The default implementation of this function traverses the index range,
converting each index into a single-bit selector with <code>Self::select</code> and
accumulating into a combined register value.</p>
<h5 id="parameters-2"><a class="doc-anchor" href="#parameters-2">§</a>Parameters</h5>
<ul>
<li><code>from</code>: The inclusive starting index for the mask.</li>
<li><code>upto</code>: The exclusive ending index for the mask.</li>
</ul>
<h5 id="returns-2"><a class="doc-anchor" href="#returns-2">§</a>Returns</h5>
<p>A bit-mask with all bits corresponding to the input index range set high
and all others set low.</p>
<h5 id="type-parameters-2"><a class="doc-anchor" href="#type-parameters-2">§</a>Type Parameters</h5>
<ul>
<li><code>R</code>: The storage type for which the mask will be calculated. The mask
must also be this type, as it will be applied to a register of <code>R</code> in
order to set, clear, or test all the selected bits.</li>
</ul>
<h5 id="requirements-2"><a class="doc-anchor" href="#requirements-2">§</a>Requirements</h5>
<p>This function must always be equivalent to</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code>(from .. upto)
  .map(<span class="number">1 </span>&lt;&lt; <span class="self">Self</span>::at::&lt;R&gt;)
  .fold(<span class="number">0</span>, |mask, sel| mask | sel)</code></pre></div>
</div></details></div><h2 id="object-safety" class="section-header">Object Safety<a href="#object-safety" class="anchor">§</a></h2><div class="object-safety-info">This trait is <b>not</b> <a href="https://doc.rust-lang.org/1.81.0/reference/items/traits.html#object-safety">object safe</a>.</div><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"><section id="impl-BitOrder-for-Lsb0" class="impl"><a class="src rightside" href="../../src/bitvec/order.rs.html#290-324">source</a><a href="#impl-BitOrder-for-Lsb0" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a> for <a class="struct" href="struct.Lsb0.html" title="struct bitvec::order::Lsb0">Lsb0</a></h3></section><section id="impl-BitOrder-for-Msb0" class="impl"><a class="src rightside" href="../../src/bitvec/order.rs.html#245-284">source</a><a href="#impl-BitOrder-for-Msb0" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a> for <a class="struct" href="struct.Msb0.html" title="struct bitvec::order::Msb0">Msb0</a></h3></section></div><script src="../../trait.impl/bitvec/order/trait.BitOrder.js" async></script></section></div></main></body></html>