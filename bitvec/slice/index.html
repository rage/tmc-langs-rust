<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A dynamically-sized view into individual bits of a memory region."><title>bitvec::slice - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="bitvec" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../bitvec/index.html">bitvec</a><span class="version">0.19.6</span></h2></div><h2 class="location"><a href="#">Module slice</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section><h2><a href="../index.html">In crate bitvec</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">bitvec</a>::<wbr><a class="mod" href="#">slice</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/bitvec/slice.rs.html#1-2134">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A dynamically-sized view into individual bits of a memory region.</p>
<p>You can read the language’s <a href="https://doc.rust-lang.org/std/slice"><code>slice</code> module documentation</a> here.</p>
<p>This module defines the <a href="struct.BitSlice.html"><code>BitSlice</code></a> region, and all of its associated support
code.</p>
<p><code>BitSlice</code> is the primary working type of this crate. It is a wrapper type over
<code>[T]</code> which enables you to view, manipulate, and take the address of individual
bits in memory. It behaves in every possible respect exactly like an ordinary
slice: it is dynamically-sized, and must be held by <code>&amp;</code> or <code>&amp;mut</code> reference,
just like <code>[T]</code>, and implements every inherent method and trait that <code>[T]</code> does,
to the absolute limits of what Rust permits.</p>
<p>The key to <code>BitSlice</code>’s powerful capability is that references to it use a
special encoding that store, in addition to the address of the base element and
the bit length, the index of the starting bit in the base element. This custom
reference encoding has some costs in what APIs are possible – for instance, Rust
forbids it from supporting <code>&amp;mut BitSlice[index] = bool</code> write indexing – but in
exchange, enables it to be <em>far</em> more capable than any other bit-slice crate in
existence.</p>
<p>Because of the volume of code that must be written to match the <code>[T]</code> standard
API, this module is organized very differently than the slice implementation in
the <code>core</code> and <code>std</code> distribution libraries.</p>
<ul>
<li>the root module <code>slice</code> contains new APIs that have no counterpart in <code>[T]</code></li>
<li><code>slice/api</code> contains reïmplementations of the <code>[T]</code> inherent methods</li>
<li><code>slice/iter</code> implements all of the iteration capability</li>
<li><code>slice/ops</code> implements the traits in <code>core::ops</code></li>
<li><code>slice/proxy</code> implements the proxy reference used in place of <code>&amp;mut bool</code></li>
<li><code>slice/traits</code> implements all other traits not in <code>core::ops</code></li>
<li>lastly, <code>slice/tests</code> contains all the unit tests.</li>
</ul>
<p>!</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.BitMut.html" title="struct bitvec::slice::BitMut">BitMut</a></div><div class="desc docblock-short">Proxy reference type, equivalent to <code>&amp;mut bool</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a></div><div class="desc docblock-short">A slice of individual bits, anywhere in memory.</div></li><li><div class="item-name"><a class="struct" href="struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a></div><div class="desc docblock-short">An iterator over a bit slice in (non-overlapping) chunks (<code>chunk_size</code> bits
at a time), starting at the beginning of the slice.</div></li><li><div class="item-name"><a class="struct" href="struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a></div><div class="desc docblock-short">An iterator over a bit slice in (non-overlapping) chunks (<code>chunk_size</code> bits
at a time), starting at the beginning of the slice.</div></li><li><div class="item-name"><a class="struct" href="struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a></div><div class="desc docblock-short">An iterator over a bit slice in (non-overlapping) mutable chunks
(<code>chunk_size</code> bits at a time), starting at the beginning of the slice.</div></li><li><div class="item-name"><a class="struct" href="struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a></div><div class="desc docblock-short">An iterator over a bit slice in (non-overlapping) mutable chunks
(<code>chunk_size</code> bits at a time), starting at the beginning of the slice.</div></li><li><div class="item-name"><a class="struct" href="struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a></div><div class="desc docblock-short">Immutable slice iterator</div></li><li><div class="item-name"><a class="struct" href="struct.IterMut.html" title="struct bitvec::slice::IterMut">IterMut</a></div><div class="desc docblock-short">Mutable bit slice iterator.</div></li><li><div class="item-name"><a class="struct" href="struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a></div><div class="desc docblock-short">An iterator over a bit slice in (non-overlapping) chunks (<code>chunk_size</code> bits
at a time), starting at the end of the slice.</div></li><li><div class="item-name"><a class="struct" href="struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a></div><div class="desc docblock-short">An iterator over a bit slice in (non-overlapping) chunks (<code>chunk_size</code> bits
at a time), starting at the end of the slice.</div></li><li><div class="item-name"><a class="struct" href="struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a></div><div class="desc docblock-short">An iterator over a bit slice in (non-overlapping) mutable chunks
(<code>chunk_size</code> bits at a time), starting at the end of the slice.</div></li><li><div class="item-name"><a class="struct" href="struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a></div><div class="desc docblock-short">An iterator over a slice in (non-overlapping) mutable chunks (<code>chunk_size</code>
bits at a time), starting at the end of the slice.</div></li><li><div class="item-name"><a class="struct" href="struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a></div><div class="desc docblock-short">An iterator over subslices separated by bits that match a predicate
function, starting from the end of the slice.</div></li><li><div class="item-name"><a class="struct" href="struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a></div><div class="desc docblock-short">An iterator over subslices separated by bits that match a predicate
function, starting from the end of the slice.</div></li><li><div class="item-name"><a class="struct" href="struct.RSplitN.html" title="struct bitvec::slice::RSplitN">RSplitN</a></div><div class="desc docblock-short">An iterator over subslices separated by bits that match a predicate
function, limited to a given number of splits, starting from the end of the
slice.</div></li><li><div class="item-name"><a class="struct" href="struct.RSplitNMut.html" title="struct bitvec::slice::RSplitNMut">RSplitNMut</a></div><div class="desc docblock-short">An iterator over subslices separated by bits that match a predicate
function, limited to a given number of splits, starting from the end of the
slice.</div></li><li><div class="item-name"><a class="struct" href="struct.Split.html" title="struct bitvec::slice::Split">Split</a></div><div class="desc docblock-short">An iterator over subslices separated by bits that match a predicate
function.</div></li><li><div class="item-name"><a class="struct" href="struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a></div><div class="desc docblock-short">An iterator over the mutable subslices of the slice which are separated by
bits that match <code>pred</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.SplitN.html" title="struct bitvec::slice::SplitN">SplitN</a></div><div class="desc docblock-short">An iterator over subslices separated by bits that match a predicate
function, limited to a given number of splits.</div></li><li><div class="item-name"><a class="struct" href="struct.SplitNMut.html" title="struct bitvec::slice::SplitNMut">SplitNMut</a></div><div class="desc docblock-short">An iterator over subslices separated by bits that match a predicate
function, limited to a given number of splits.</div></li><li><div class="item-name"><a class="struct" href="struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a></div><div class="desc docblock-short">An iterator over overlapping subslices of length <code>size</code>.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a></div><div class="desc docblock-short">A helper trait used for indexing operations.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.bits_from_raw_parts.html" title="fn bitvec::slice::bits_from_raw_parts">bits_from_raw_parts</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Constructs a <code>&amp;BitSlice</code> reference from its component data.</div></li><li><div class="item-name"><a class="fn" href="fn.bits_from_raw_parts_mut.html" title="fn bitvec::slice::bits_from_raw_parts_mut">bits_from_raw_parts_mut</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Constructs a <code>&amp;mut BitSlice</code> reference from its component data.</div></li><li><div class="item-name"><a class="fn" href="fn.from_mut.html" title="fn bitvec::slice::from_mut">from_mut</a></div><div class="desc docblock-short">Converts a reference to <code>T</code> into a bitslice over one element.</div></li><li><div class="item-name"><a class="fn" href="fn.from_raw_parts.html" title="fn bitvec::slice::from_raw_parts">from_raw_parts</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Forms a bitslice from a pointer and a length.</div></li><li><div class="item-name"><a class="fn" href="fn.from_raw_parts_mut.html" title="fn bitvec::slice::from_raw_parts_mut">from_raw_parts_mut</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Performs the same functionality as <a href="fn.from_raw_parts.html"><code>from_raw_parts</code></a>, except that a mutable
bitslice is returned.</div></li><li><div class="item-name"><a class="fn" href="fn.from_ref.html" title="fn bitvec::slice::from_ref">from_ref</a></div><div class="desc docblock-short">Converts a reference to <code>T</code> into a bitslice over one element.</div></li></ul></section></div></main></body></html>