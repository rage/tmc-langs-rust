<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A vector of individual bits, allocated on the heap."><title>BitVec in bitvec::vec - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="bitvec" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../bitvec/index.html">bitvec</a><span class="version">0.19.6</span></h2></div><h2 class="location"><a href="#">BitVec</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.append">append</a></li><li><a href="#method.as_bitptr">as_bitptr</a></li><li><a href="#method.as_bitslice">as_bitslice</a></li><li><a href="#method.as_mut_bitptr">as_mut_bitptr</a></li><li><a href="#method.as_mut_bitslice">as_mut_bitslice</a></li><li><a href="#method.as_mut_ptr">as_mut_ptr</a></li><li><a href="#method.as_mut_slice">as_mut_slice</a></li><li><a href="#method.as_ptr">as_ptr</a></li><li><a href="#method.as_slice">as_slice</a></li><li><a href="#method.capacity">capacity</a></li><li><a href="#method.clear">clear</a></li><li><a href="#method.drain">drain</a></li><li><a href="#method.elements">elements</a></li><li><a href="#method.extend_from_bitslice">extend_from_bitslice</a></li><li><a href="#method.extend_from_slice">extend_from_slice</a></li><li><a href="#method.force_align">force_align</a></li><li><a href="#method.from_bitslice">from_bitslice</a></li><li><a href="#method.from_raw_parts">from_raw_parts</a></li><li><a href="#method.from_vec">from_vec</a></li><li><a href="#method.insert">insert</a></li><li><a href="#method.into_boxed_bitslice">into_boxed_bitslice</a></li><li><a href="#method.into_boxed_slice">into_boxed_slice</a></li><li><a href="#method.into_vec">into_vec</a></li><li><a href="#method.new">new</a></li><li><a href="#method.pop">pop</a></li><li><a href="#method.push">push</a></li><li><a href="#method.remove">remove</a></li><li><a href="#method.repeat">repeat</a></li><li><a href="#method.reserve">reserve</a></li><li><a href="#method.reserve_exact">reserve_exact</a></li><li><a href="#method.resize">resize</a></li><li><a href="#method.resize_with">resize_with</a></li><li><a href="#method.retain">retain</a></li><li><a href="#method.set_elements">set_elements</a></li><li><a href="#method.set_len">set_len</a></li><li><a href="#method.set_uninitialized">set_uninitialized</a></li><li><a href="#method.shrink_to_fit">shrink_to_fit</a></li><li><a href="#method.splice">splice</a></li><li><a href="#method.split_off">split_off</a></li><li><a href="#method.swap_remove">swap_remove</a></li><li><a href="#method.truncate">truncate</a></li><li><a href="#method.try_from_vec">try_from_vec</a></li><li><a href="#method.with_capacity">with_capacity</a></li></ul><h3><a href="#deref-methods-BitSlice%3CO,+T%3E">Methods from Deref&lt;Target=BitSlice&lt;O, T&gt;&gt;</a></h3><ul class="block deref-methods"><li><a href="#method.align_to">align_to</a></li><li><a href="#method.align_to_mut">align_to_mut</a></li><li><a href="#method.all">all</a></li><li><a href="#method.any">any</a></li><li><a href="#method.as_mut_ptr-1">as_mut_ptr</a></li><li><a href="#method.as_ptr-1">as_ptr</a></li><li><a href="#method.as_raw_slice">as_raw_slice</a></li><li><a href="#method.as_raw_slice_mut">as_raw_slice_mut</a></li><li><a href="#method.as_slice-1">as_slice</a></li><li><a href="#method.bit_domain">bit_domain</a></li><li><a href="#method.bit_domain_mut">bit_domain_mut</a></li><li><a href="#method.chunks">chunks</a></li><li><a href="#method.chunks_exact">chunks_exact</a></li><li><a href="#method.chunks_exact_mut">chunks_exact_mut</a></li><li><a href="#method.chunks_mut">chunks_mut</a></li><li><a href="#method.clone_from_bitslice">clone_from_bitslice</a></li><li><a href="#method.contains">contains</a></li><li><a href="#method.copy_from_bitslice">copy_from_bitslice</a></li><li><a href="#method.copy_unchecked">copy_unchecked</a></li><li><a href="#method.copy_within">copy_within</a></li><li><a href="#method.copy_within_unchecked">copy_within_unchecked</a></li><li><a href="#method.count_ones">count_ones</a></li><li><a href="#method.count_zeros">count_zeros</a></li><li><a href="#method.domain">domain</a></li><li><a href="#method.domain_mut">domain_mut</a></li><li><a href="#method.electrical_distance">electrical_distance</a></li><li><a href="#method.ends_with">ends_with</a></li><li><a href="#method.first">first</a></li><li><a href="#method.first_mut">first_mut</a></li><li><a href="#method.for_each">for_each</a></li><li><a href="#method.get">get</a></li><li><a href="#method.get_mut">get_mut</a></li><li><a href="#method.get_unchecked">get_unchecked</a></li><li><a href="#method.get_unchecked_mut">get_unchecked_mut</a></li><li><a href="#method.is_empty">is_empty</a></li><li><a href="#method.iter">iter</a></li><li><a href="#method.iter_mut">iter_mut</a></li><li><a href="#method.last">last</a></li><li><a href="#method.last_mut">last_mut</a></li><li><a href="#method.len">len</a></li><li><a href="#method.not_all">not_all</a></li><li><a href="#method.not_any">not_any</a></li><li><a href="#method.offset_from">offset_from</a></li><li><a href="#method.rchunks">rchunks</a></li><li><a href="#method.rchunks_exact">rchunks_exact</a></li><li><a href="#method.rchunks_exact_mut">rchunks_exact_mut</a></li><li><a href="#method.rchunks_mut">rchunks_mut</a></li><li><a href="#method.repeat-1">repeat</a></li><li><a href="#method.reverse">reverse</a></li><li><a href="#method.rotate_left">rotate_left</a></li><li><a href="#method.rotate_right">rotate_right</a></li><li><a href="#method.rsplit">rsplit</a></li><li><a href="#method.rsplit_mut">rsplit_mut</a></li><li><a href="#method.rsplitn">rsplitn</a></li><li><a href="#method.rsplitn_mut">rsplitn_mut</a></li><li><a href="#method.set">set</a></li><li><a href="#method.set_all">set_all</a></li><li><a href="#method.set_unchecked">set_unchecked</a></li><li><a href="#method.some">some</a></li><li><a href="#method.split">split</a></li><li><a href="#method.split_at">split_at</a></li><li><a href="#method.split_at_aliased_mut">split_at_aliased_mut</a></li><li><a href="#method.split_at_mut">split_at_mut</a></li><li><a href="#method.split_at_unchecked">split_at_unchecked</a></li><li><a href="#method.split_at_unchecked_mut">split_at_unchecked_mut</a></li><li><a href="#method.split_first">split_first</a></li><li><a href="#method.split_first_mut">split_first_mut</a></li><li><a href="#method.split_last">split_last</a></li><li><a href="#method.split_last_mut">split_last_mut</a></li><li><a href="#method.split_mut">split_mut</a></li><li><a href="#method.splitn">splitn</a></li><li><a href="#method.splitn_mut">splitn_mut</a></li><li><a href="#method.starts_with">starts_with</a></li><li><a href="#method.swap">swap</a></li><li><a href="#method.swap_unchecked">swap_unchecked</a></li><li><a href="#method.swap_with_bitslice">swap_with_bitslice</a></li><li><a href="#method.to_bitvec">to_bitvec</a></li><li><a href="#method.windows">windows</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-AsMut%3CBitSlice%3CO,+T%3E%3E-for-BitVec%3CO,+T%3E">AsMut&lt;BitSlice&lt;O, T&gt;&gt;</a></li><li><a href="#impl-AsRef%3CBitSlice%3CO,+T%3E%3E-for-BitVec%3CO,+T%3E">AsRef&lt;BitSlice&lt;O, T&gt;&gt;</a></li><li><a href="#impl-Binary-for-BitVec%3CO,+T%3E">Binary</a></li><li><a href="#impl-BitAnd%3CRhs%3E-for-BitVec%3CO,+T%3E">BitAnd&lt;Rhs&gt;</a></li><li><a href="#impl-BitAndAssign%3CRhs%3E-for-BitVec%3CO,+T%3E">BitAndAssign&lt;Rhs&gt;</a></li><li><a href="#impl-BitField-for-BitVec%3CO,+T%3E">BitField</a></li><li><a href="#impl-BitOr%3CRhs%3E-for-BitVec%3CO,+T%3E">BitOr&lt;Rhs&gt;</a></li><li><a href="#impl-BitOrAssign%3CRhs%3E-for-BitVec%3CO,+T%3E">BitOrAssign&lt;Rhs&gt;</a></li><li><a href="#impl-BitXor%3CRhs%3E-for-BitVec%3CO,+T%3E">BitXor&lt;Rhs&gt;</a></li><li><a href="#impl-BitXorAssign%3CRhs%3E-for-BitVec%3CO,+T%3E">BitXorAssign&lt;Rhs&gt;</a></li><li><a href="#impl-Borrow%3CBitSlice%3CO,+T%3E%3E-for-BitVec%3CO,+T%3E">Borrow&lt;BitSlice&lt;O, T&gt;&gt;</a></li><li><a href="#impl-BorrowMut%3CBitSlice%3CO,+T%3E%3E-for-BitVec%3CO,+T%3E">BorrowMut&lt;BitSlice&lt;O, T&gt;&gt;</a></li><li><a href="#impl-Clone-for-BitVec%3CO,+T%3E">Clone</a></li><li><a href="#impl-Debug-for-BitVec%3CO,+T%3E">Debug</a></li><li><a href="#impl-Default-for-BitVec%3CO,+T%3E">Default</a></li><li><a href="#impl-Deref-for-BitVec%3CO,+T%3E">Deref</a></li><li><a href="#impl-DerefMut-for-BitVec%3CO,+T%3E">DerefMut</a></li><li><a href="#impl-Display-for-BitVec%3CO,+T%3E">Display</a></li><li><a href="#impl-Drop-for-BitVec%3CO,+T%3E">Drop</a></li><li><a href="#impl-Eq-for-BitVec%3CO,+T%3E">Eq</a></li><li><a href="#impl-Extend%3C%26bool%3E-for-BitVec%3CO,+T%3E">Extend&lt;&amp;&#x27;a bool&gt;</a></li><li><a href="#impl-Extend%3Cbool%3E-for-BitVec%3CO,+T%3E">Extend&lt;bool&gt;</a></li><li><a href="#impl-From%3C%26BitSlice%3CO,+T%3E%3E-for-BitVec%3CO,+T%3E">From&lt;&amp;&#x27;a BitSlice&lt;O, T&gt;&gt;</a></li><li><a href="#impl-From%3C%26mut+BitSlice%3CO,+T%3E%3E-for-BitVec%3CO,+T%3E">From&lt;&amp;&#x27;a mut BitSlice&lt;O, T&gt;&gt;</a></li><li><a href="#impl-From%3CBitBox%3CO,+T%3E%3E-for-BitVec%3CO,+T%3E">From&lt;BitBox&lt;O, T&gt;&gt;</a></li><li><a href="#impl-From%3CBitVec%3CO,+T%3E%3E-for-BitBox%3CO,+T%3E">From&lt;BitVec&lt;O, T&gt;&gt;</a></li><li><a href="#impl-FromIterator%3C%26bool%3E-for-BitVec%3CO,+T%3E">FromIterator&lt;&amp;&#x27;a bool&gt;</a></li><li><a href="#impl-FromIterator%3Cbool%3E-for-BitVec%3CO,+T%3E">FromIterator&lt;bool&gt;</a></li><li><a href="#impl-Hash-for-BitVec%3CO,+T%3E">Hash</a></li><li><a href="#impl-Index%3CIdx%3E-for-BitVec%3CO,+T%3E">Index&lt;Idx&gt;</a></li><li><a href="#impl-IndexMut%3CIdx%3E-for-BitVec%3CO,+T%3E">IndexMut&lt;Idx&gt;</a></li><li><a href="#impl-Into%3CVec%3CT%3E%3E-for-BitVec%3CO,+T%3E">Into&lt;Vec&lt;T&gt;&gt;</a></li><li><a href="#impl-IntoIterator-for-%26BitVec%3CO,+T%3E">IntoIterator</a></li><li><a href="#impl-IntoIterator-for-%26mut+BitVec%3CO,+T%3E">IntoIterator</a></li><li><a href="#impl-IntoIterator-for-BitVec%3CO,+T%3E">IntoIterator</a></li><li><a href="#impl-LowerHex-for-BitVec%3CO,+T%3E">LowerHex</a></li><li><a href="#impl-Not-for-BitVec%3CO,+T%3E">Not</a></li><li><a href="#impl-Octal-for-BitVec%3CO,+T%3E">Octal</a></li><li><a href="#impl-Ord-for-BitVec%3CO,+T%3E">Ord</a></li><li><a href="#impl-PartialEq%3CBitVec%3CO2,+T2%3E%3E-for-%26BitSlice%3CO1,+T1%3E">PartialEq&lt;BitVec&lt;O2, T2&gt;&gt;</a></li><li><a href="#impl-PartialEq%3CBitVec%3CO2,+T2%3E%3E-for-%26mut+BitSlice%3CO1,+T1%3E">PartialEq&lt;BitVec&lt;O2, T2&gt;&gt;</a></li><li><a href="#impl-PartialEq%3CBitVec%3CO2,+T2%3E%3E-for-BitSlice%3CO1,+T1%3E">PartialEq&lt;BitVec&lt;O2, T2&gt;&gt;</a></li><li><a href="#impl-PartialEq%3CRhs%3E-for-BitVec%3CO,+T%3E">PartialEq&lt;Rhs&gt;</a></li><li><a href="#impl-PartialOrd%3CBitVec%3CO,+T%3E%3E-for-BitSlice%3CO,+T%3E">PartialOrd&lt;BitVec&lt;O, T&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3CRhs%3E-for-BitVec%3CO,+T%3E">PartialOrd&lt;Rhs&gt;</a></li><li><a href="#impl-Pointer-for-BitVec%3CO,+T%3E">Pointer</a></li><li><a href="#impl-Send-for-BitVec%3CO,+T%3E">Send</a></li><li><a href="#impl-Sync-for-BitVec%3CO,+T%3E">Sync</a></li><li><a href="#impl-TryFrom%3CVec%3CT%3E%3E-for-BitVec%3CO,+T%3E">TryFrom&lt;Vec&lt;T&gt;&gt;</a></li><li><a href="#impl-Unpin-for-BitVec%3CO,+T%3E">Unpin</a></li><li><a href="#impl-UpperHex-for-BitVec%3CO,+T%3E">UpperHex</a></li><li><a href="#impl-Write-for-BitVec%3CO,+T%3E">Write</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-BitVec%3CO,+T%3E">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-BitVec%3CO,+T%3E">RefUnwindSafe</a></li><li><a href="#impl-UnwindSafe-for-BitVec%3CO,+T%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-CloneToUninit-for-T">CloneToUninit</a></li><li><a href="#impl-Conv-for-T">Conv</a></li><li><a href="#impl-Conv-for-T-1">Conv</a></li><li><a href="#impl-FmtForward-for-T">FmtForward</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-Pipe-for-T">Pipe</a></li><li><a href="#impl-Pipe-for-T-1">Pipe</a></li><li><a href="#impl-PipeAsRef-for-T">PipeAsRef</a></li><li><a href="#impl-PipeBorrow-for-T">PipeBorrow</a></li><li><a href="#impl-PipeDeref-for-T">PipeDeref</a></li><li><a href="#impl-PipeRef-for-T">PipeRef</a></li><li><a href="#impl-Tap-for-T">Tap</a></li><li><a href="#impl-Tap-for-T-1">Tap</a></li><li><a href="#impl-TapAsRef%3CU%3E-for-T">TapAsRef&lt;U&gt;</a></li><li><a href="#impl-TapBorrow%3CU%3E-for-T">TapBorrow&lt;U&gt;</a></li><li><a href="#impl-TapDeref-for-T">TapDeref</a></li><li><a href="#impl-ToOwned-for-T">ToOwned</a></li><li><a href="#impl-ToString-for-T">ToString</a></li><li><a href="#impl-TryConv-for-T">TryConv</a></li><li><a href="#impl-TryConv-for-T-1">TryConv</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In bitvec::vec</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../index.html">bitvec</a>::<wbr><a href="index.html">vec</a>::<wbr><a class="struct" href="#">BitVec</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/bitvec/vec.rs.html#130-139">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code><div class="code-attribute">#[repr(C)]</div>pub struct BitVec&lt;O = <a class="struct" href="../order/struct.Lsb0.html" title="struct bitvec::order::Lsb0">Lsb0</a>, T = <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div>{ <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A vector of individual bits, allocated on the heap.</p>
<p>This is a managed, heap-allocated, buffer that contains a <code>BitSlice</code> region. It
is analagous to <code>Vec&lt;bool&gt;</code>, and is written to be as close as possible to
drop-in replacabale for it. This type contains little interesting behavior in
its own right, dereferencing instead to <a href="../slice/struct.BitSlice.html"><code>BitSlice</code></a> for manipulation of the
buffer contents, and serves primarily as an interface to the allocator. If you
require statically-allocated, fixed-size, owned buffers, you should use the
<a href="../array/struct.BitArray.html"><code>BitArray</code></a> type.</p>
<p>Because <code>BitVec</code> directly owns its memory, and can guarantee that no other
object in a program has access to its buffers, <code>BitVec</code> is able to override some
behavior from <code>BitSlice</code> in more efficient manners.</p>
<h2 id="documentation"><a class="doc-anchor" href="#documentation">§</a>Documentation</h2>
<p>All APIs that mirror something in the standard library will have an <code>Original</code>
section linking to the corresponding item. All APIs that have a different
signature or behavior than the original will have an <code>API Differences</code> section
explaining what has changed, and how to adapt your existing code to the change.</p>
<p>These sections look like this:</p>
<h2 id="original"><a class="doc-anchor" href="#original">§</a>Original</h2>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a></p>
<h2 id="api-differences"><a class="doc-anchor" href="#api-differences">§</a>API Differences</h2>
<p>The buffer type <code>Vec&lt;bool&gt;</code> has no type parameters. <code>BitVec&lt;O, T&gt;</code> has the same
two type parameters as <code>BitSlice&lt;O, T&gt;</code>. Otherwise, <code>BitVec</code> is able to
implement the full API surface of <code>Vec&lt;bool&gt;</code>.</p>
<h2 id="behavior"><a class="doc-anchor" href="#behavior">§</a>Behavior</h2>
<p>Because <code>BitVec</code> is a fully-owned buffer, it is able to operate on its memory
without concern for any other views that may alias. This enables it to
specialize some <code>BitSlice</code> behavior to be faster or more efficient.</p>
<h2 id="type-parameters"><a class="doc-anchor" href="#type-parameters">§</a>Type Parameters</h2>
<p>This takes the same two type parameters, <code>O: BitOrder</code> and <code>T: BitStore</code>, as
<code>BitSlice</code>.</p>
<h2 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h2>
<p>Like <code>BitSlice</code>, <code>BitVec</code> is exactly equal in size to <code>Vec</code>, and is also
absolutely representation-incompatible with it. You must never attempt to
type-cast between <code>Vec&lt;T&gt;</code> and <code>BitVec</code> in any way, nor attempt to modify the
memory value of a <code>BitVec</code> handle. Doing so will cause allocator and memory
errors in your program, likely inducing a panic.</p>
<p>Everything in the <code>BitVec</code> public API, even the <code>unsafe</code> parts, are guaranteed
to have no more unsafety than their equivalent items in the standard library.
All <code>unsafe</code> APIs will have documentation explicitly detailing what the API
requires you to uphold in order for it to function safely and correctly. All
safe APIs will do so themselves.</p>
<h2 id="performance"><a class="doc-anchor" href="#performance">§</a>Performance</h2>
<p>The choice of <code>T: BitStore</code> type parameter can impact your vector’s performance,
as the allocator operates in units of <code>T</code> rather than in bits. This means that
larger register types will increase the amount of memory reserved in each call
to the allocator, meaning fewer calls to <code>.push()</code> will actually cause a
reällocation. In addition, iteration over the vector is governed by the
<code>BitSlice</code> characteristics on the type parameter. You are generally better off
using larger types when your vector is a data collection rather than a specific
I/O protocol buffer.</p>
<h2 id="macro-construction"><a class="doc-anchor" href="#macro-construction">§</a>Macro Construction</h2>
<p>Heap allocation can only occur at runtime, but the <a href="../macro.bitvec.html"><code>bitvec!</code></a> macro will
construct an appropriate <code>BitSlice</code> buffer at compile-time, and at run-time,
only copy the buffer into a heap allocation.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#37-1225">source</a><a href="#impl-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#58-63">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs a new, empty <code>BitVec&lt;O, T&gt;</code>.</p>
<p>The vector will not allocate until bits are pushed into it.</p>
<h5 id="original-1"><a class="doc-anchor" href="#original-1">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.new"><code>Vec::new</code></a></p>
<h5 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = BitVec::&lt;LocalBits, usize&gt;::new();</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.with_capacity" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#104-119">source</a><h4 class="code-header">pub fn <a href="#method.with_capacity" class="fn">with_capacity</a>(capacity: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs a new, empty <code>BitVec&lt;O, T&gt;</code> with the specified capacity.</p>
<p>The vector will be able to hold at least <code>capacity</code> bits without
reällocating. If <code>capacity</code> is 0, the vector will not allocate.</p>
<p>It is important to note that although the returned vector has the
<em>capacity</em> specified, the vector will have a zero <em>length</em>. For an
explanation of the difference between length and capacity, see
<em><a href="#capacity-and-reallocation">Capacity and reällocation</a></em>.</p>
<h5 id="original-2"><a class="doc-anchor" href="#original-2">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.with_capacity"><code>Vec::with_capacity</code></a></p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>Panics if the requested capacity exceeds the vector’s limits.</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = BitVec::&lt;LocalBits, usize&gt;::with_capacity(<span class="number">10</span>);

<span class="comment">// The vector contains no items, even though it has capacity for more
</span><span class="macro">assert_eq!</span>(bv.len(), <span class="number">0</span>);

<span class="comment">// These are all done without reallocating...
</span><span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..<span class="number">10 </span>{
  bv.push(<span class="bool-val">true</span>);
}

<span class="comment">// ...but this may make the vector reallocate
</span>bv.push(<span class="bool-val">false</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_raw_parts" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#209-220">source</a><h4 class="code-header">pub unsafe fn <a href="#method.from_raw_parts" class="fn">from_raw_parts</a>(
    pointer: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.pointer.html">*mut </a><a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;,
    capacity: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>,
) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a <code>BitVec&lt;O, T&gt;</code> directly from the raw components of another
bit-vector.</p>
<h5 id="original-3"><a class="doc-anchor" href="#original-3">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.from_raw_parts"><code>Vec::from_raw_parts</code></a></p>
<h5 id="api-differences-1"><a class="doc-anchor" href="#api-differences-1">§</a>API Differences</h5>
<p>Ordinary vectors decompose into their buffer pointer and element length
separately; bit vectors must keep these two components bundled into the
<code>*BitSlice</code> region pointer. As such, this only accepts two components;
the slice pointer and the buffer capacity.</p>
<p><code>Vec</code> could define its raw parts as <code>*[T]</code> and <code>usize</code> also, but Rust
does not make working with raw slice pointers easy.</p>
<h5 id="panics-1"><a class="doc-anchor" href="#panics-1">§</a>Panics</h5>
<p>This function panics if <code>pointer</code> is the null pointer.</p>
<h5 id="safety-1"><a class="doc-anchor" href="#safety-1">§</a>Safety</h5>
<p>This is highly unsafe, due to the number of invariants that aren’t
checked:</p>
<ul>
<li><code>pointer</code> needs to have been previously allocated via <code>BitVec&lt;O, T&gt;</code>
(at least, it’s highly likely to be incorrect if it wasn’t).</li>
<li><code>T</code> needs to have the same size and alignment as what <code>pointer</code> was
allocated with. (<code>T</code> having a less strict alignment is not sufficient;
the alignment really needs to be equal to satisfy the [<code>dealloc</code>]
requirement that memory must be allocated and deällocated with the
same layout.)</li>
<li><code>capacity</code> needs to be the capacity that the pointer was allocated
with.</li>
</ul>
<p>In addition to the invariants inherited from <code>Vec::from_raw_parts</code>, the
fact that this function takes a bit-slice pointer adds another one:</p>
<ul>
<li><strong><code>pointer</code> MUST NOT have had its value modified in any way in the</strong>
<strong>time when it was outside of a <code>bitvec</code> container type.</strong></li>
</ul>
<p>Violating these <em>will</em> cause problems like corrupting the allocator’s
internal data structures. For example it is <strong>not</strong> safe to build a
<code>BitVec&lt;_, u8&gt;</code> from a pointer to a C <code>char</code> array with length <code>size_t</code>.
It’s also not safe to build one from a <code>BitVec&lt;_, u16&gt;</code> and its length,
becauset the allocator cares about the alignment, and these two types
have different alignments. The buffer was allocated with alignment 2
(for <code>u16</code>), but after turning it into a <code>BitVec&lt;_, u8&gt;</code>, it’ll be
deällocated with alignment 1.</p>
<p>The ownership of <code>pointer</code> is effectively transferred to the <code>BitVec&lt;O, T&gt;</code> which may then deällocate, reällocate, or change the contents of
memory pointed to by the pointer at will. Ensure that nothing else uses
the pointer after calling this function.</p>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>bitvec <span class="kw">as </span>bv;
<span class="kw">use </span>core::mem;

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];

<span class="comment">// Prevent running `bv`’s destructor so we are in complete control
// of the allocation.
</span><span class="kw">let </span><span class="kw-2">mut </span>bv = mem::ManuallyDrop::new(bv);

<span class="comment">// Pull out the various important pieces of information about `bv`
</span><span class="kw">let </span>p = bv.as_mut_ptr();
<span class="kw">let </span>e = bv.elements();
<span class="kw">let </span>cap = bv.capacity();

<span class="kw">unsafe </span>{
  <span class="kw">let </span>bits = bv::slice::from_raw_parts_mut::&lt;LocalBits, <span class="kw">_</span>&gt;(p, e);
  <span class="kw">let </span>len = bits.len();

  <span class="comment">// Overwrite memory with a new pattern
  </span>bits.iter_mut().for_each(|<span class="kw-2">mut </span>b| <span class="kw-2">*</span>b = <span class="bool-val">true</span>);

  <span class="comment">// Put everything back together into a BitVec
  </span><span class="kw">let </span>rebuilt = BitVec::from_raw_parts(bits <span class="kw">as </span><span class="kw-2">*mut </span><span class="kw">_</span>, cap);
  <span class="macro">assert_eq!</span>(rebuilt.len(), len);
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.capacity" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#237-245">source</a><h4 class="code-header">pub fn <a href="#method.capacity" class="fn">capacity</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of bits the vector can hold without reällocating.</p>
<h5 id="original-4"><a class="doc-anchor" href="#original-4">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.capacity"><code>Vec::capacity</code></a></p>
<h5 id="examples-3"><a class="doc-anchor" href="#examples-3">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv: BitVec&lt;LocalBits, usize&gt; = BitVec::with_capacity(<span class="number">100</span>);
<span class="macro">assert!</span>(bv.capacity() &gt;= <span class="number">100</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reserve" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#271-292">source</a><h4 class="code-header">pub fn <a href="#method.reserve" class="fn">reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Reserves capacity for at least <code>additional</code> more bits to be inserted in
the given <code>BitVec&lt;O, T&gt;</code>. The collection may reserve more space to avoid
frequent reällocations. After calling <code>reserve</code>, capacity will be
greater than or equal to <code>self.len() + additional</code>. Does nothing if
capacity is already sufficient.</p>
<h5 id="original-5"><a class="doc-anchor" href="#original-5">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.reserve"><code>Vec::reserve</code></a></p>
<h5 id="panics-2"><a class="doc-anchor" href="#panics-2">§</a>Panics</h5>
<p>Panics if the new capacity exceeds the vector’s limits.</p>
<h5 id="examples-4"><a class="doc-anchor" href="#examples-4">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">1</span>];
bv.reserve(<span class="number">100</span>);
<span class="macro">assert!</span>(bv.capacity() &gt;= <span class="number">101</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reserve_exact" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#321-339">source</a><h4 class="code-header">pub fn <a href="#method.reserve_exact" class="fn">reserve_exact</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Reserves the minimum capacity for exactly <code>additional</code> more bits to be
inserted in the given <code>BitVec&lt;O, T&gt;</code>. After calling <code>reserve_exact</code>,
capacity will be greater than or equal to <code>self.len() + additional</code>.
Does nothing if the capacity is already sufficient.</p>
<p>Note that the allocator may give the collection more space than it
requests. Therefore, capacity can not be relied upon to be precisely
minimal. Prefer <code>reserve</code> if future insertions are expected.</p>
<h5 id="original-6"><a class="doc-anchor" href="#original-6">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.reserve_exact"><code>Vec::reserve_exact</code></a></p>
<h5 id="panics-3"><a class="doc-anchor" href="#panics-3">§</a>Panics</h5>
<p>Panics if the new capacity exceeds the vector’s limits.</p>
<h5 id="examples-5"><a class="doc-anchor" href="#examples-5">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">1</span>];
bv.reserve_exact(<span class="number">100</span>);
<span class="macro">assert!</span>(bv.capacity() &gt;= <span class="number">101</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.shrink_to_fit" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#362-364">source</a><h4 class="code-header">pub fn <a href="#method.shrink_to_fit" class="fn">shrink_to_fit</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Shrinks the capacity of the vector as much as possible.</p>
<p>It will drop down as close as possible to the length but the allocator
may still inform the vector that there is space for a few more bits.</p>
<h5 id="original-7"><a class="doc-anchor" href="#original-7">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.shrink_to_fit"><code>Vec::shrink_to_fit</code></a></p>
<h5 id="examples-6"><a class="doc-anchor" href="#examples-6">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = BitVec::&lt;LocalBits, usize&gt;::with_capacity(<span class="number">100</span>);
bv.extend([<span class="bool-val">false</span>, <span class="bool-val">true</span>, <span class="bool-val">false</span>].iter().copied());
<span class="macro">assert!</span>(bv.capacity() &gt;= <span class="number">100</span>);
bv.shrink_to_fit();
<span class="macro">assert!</span>(bv.capacity() &gt;= <span class="number">3</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.into_boxed_slice" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#405-407">source</a><h4 class="code-header">pub fn <a href="#method.into_boxed_slice" class="fn">into_boxed_slice</a>(self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.slice.html">[T]</a>&gt;</h4></section></summary><div class="docblock"><p>Converts the vector into [<code>Box&lt;[T]&gt;</code>].</p>
<p>Note that this will drop any excess capacity.</p>
<h5 id="original-8"><a class="doc-anchor" href="#original-8">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.into_boxed_slice"><code>Vec::into_boxed_slice</code></a></p>
<h5 id="analogue"><a class="doc-anchor" href="#analogue">§</a>Analogue</h5>
<p>See [<code>into_boxed_bitslice</code>] for a <code>BitVec -&gt; BitBox</code> transform.</p>
<h5 id="examples-7"><a class="doc-anchor" href="#examples-7">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];

<span class="kw">let </span>slice = bv.into_boxed_slice();
<span class="macro">assert_eq!</span>(slice.len(), <span class="number">1</span>);</code></pre></div>
<p>Any excess capacity is removed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv: BitVec = BitVec::with_capacity(<span class="number">100</span>);
bv.extend([<span class="bool-val">false</span>, <span class="bool-val">true</span>, <span class="bool-val">false</span>].iter().copied());

<span class="macro">assert!</span>(bv.capacity() &gt;= <span class="number">100</span>);
<span class="kw">let </span>slice = bv.into_boxed_slice();
<span class="macro">assert_eq!</span>(slice.into_vec().capacity(), <span class="number">1</span>);</code></pre></div>
<p>[<code>Box&lt;[T]&gt;</code>]: https://doc.rust-lang.org/alloc/boxed/struct.Box.html
[<code>into_boxed_bitslice</code>]: #method.into_boxed_bitslice</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.truncate" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#464-468">source</a><h4 class="code-header">pub fn <a href="#method.truncate" class="fn">truncate</a>(&amp;mut self, len: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Shortens the vector, keeping the first <code>len</code> bits and dropping the rest.</p>
<p>If <code>len</code> is greater than the vector’s current length, this has no
effect.</p>
<p>The <a href="#method.drain"><code>drain</code></a> method can emulate <code>truncate</code>, but causes the excess bits
to be returned instead of dropped.</p>
<p>Note that this method has no effect on the allocated capacity of the
vector, <strong>nor does it erase truncated memory</strong>. Bits in the allocated
memory that are outside of the <code>.as_bitslice()</code> view always have
<strong>unspecified</strong> values, and cannot be relied upon to be zero.</p>
<h5 id="original-9"><a class="doc-anchor" href="#original-9">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.truncate"><code>Vec::truncate</code></a></p>
<h5 id="examples-8"><a class="doc-anchor" href="#examples-8">§</a>Examples</h5>
<p>Truncating a five bit vector to two bits:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">1</span>; <span class="number">5</span>];
bv.truncate(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(bv.len(), <span class="number">2</span>);
<span class="macro">assert!</span>(bv.as_slice()[<span class="number">0</span>].count_ones() &gt;= <span class="number">5</span>);</code></pre></div>
<p>No truncation occurs when <code>len</code> is greater than the vector’s current
length:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">1</span>; <span class="number">3</span>];
bv.truncate(<span class="number">8</span>);
<span class="macro">assert_eq!</span>(bv.len(), <span class="number">3</span>);</code></pre></div>
<p>Truncating when <code>len == 0</code> is equivalent to calling the <a href="#method.clear"><code>clear</code></a>
method.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>; <span class="number">3</span>];
bv.truncate(<span class="number">0</span>);
<span class="macro">assert!</span>(bv.is_empty());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_slice" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#494-498">source</a><h4 class="code-header">pub fn <a href="#method.as_slice" class="fn">as_slice</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.slice.html">[T]</a></h4></section></summary><div class="docblock"><p>Extracts an element slice containing the entire vector.</p>
<h5 id="original-10"><a class="doc-anchor" href="#original-10">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.as_slice"><code>Vec::as_slice</code></a></p>
<h5 id="analogue-1"><a class="doc-anchor" href="#analogue-1">§</a>Analogue</h5>
<p>See <a href="#method.as_bitslice"><code>as_bitslice</code></a> for a <code>&amp;BitVec -&gt; &amp;BitSlice</code> transform.</p>
<h5 id="examples-9"><a class="doc-anchor" href="#examples-9">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>std::io::{<span class="self">self</span>, Write};
<span class="kw">let </span>buffer = <span class="macro">bitvec!</span>[Msb0, u8; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
io::sink().write(buffer.as_slice()).unwrap();</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut_slice" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#524-528">source</a><h4 class="code-header">pub fn <a href="#method.as_mut_slice" class="fn">as_mut_slice</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.slice.html">[T]</a></h4></section></summary><div class="docblock"><p>Extracts a mutable slice of the entire vector.</p>
<h5 id="original-11"><a class="doc-anchor" href="#original-11">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.as_mut_slice"><code>Vec::as_mut_slice</code></a></p>
<h5 id="analogue-2"><a class="doc-anchor" href="#analogue-2">§</a>Analogue</h5>
<p>See <a href="#method.as_mut_bitslice"><code>as_mut_bitslice</code></a> for a <code>&amp;mut BitVec -&gt; &amp;mut BitSlice</code> transform.</p>
<h5 id="examples-10"><a class="doc-anchor" href="#examples-10">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>std::io::{<span class="self">self</span>, Read};
<span class="kw">let </span><span class="kw-2">mut </span>buffer = <span class="macro">bitvec!</span>[Msb0, u8; <span class="number">0</span>; <span class="number">24</span>];
io::repeat(<span class="number">0b101</span>).read_exact(buffer.as_mut_slice()).unwrap();</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ptr" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#564-566">source</a><h4 class="code-header">pub fn <a href="#method.as_ptr" class="fn">as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.pointer.html">*const T</a></h4></section></summary><div class="docblock"><p>Returns a raw pointer to the vector’s buffer.</p>
<p>The caller must ensure that the vector outlives the pointer this
function returns, or else it will end up pointing to garbage. Modifying
the vector may cause its buffer to be reällocated, which would also make
any pointers to it invalid.</p>
<p>The caller must also ensure that the memory the pointer
(non-transitively) points to is never written to (except inside an
<code>UnsafeCell</code>) using this pointer or any pointer derived from it. If you
need to mutate the contents of the slice, use [<code>as_mut_ptr</code>].</p>
<h5 id="original-12"><a class="doc-anchor" href="#original-12">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.as_ptr"><code>Vec::as_ptr</code></a></p>
<h5 id="analogue-3"><a class="doc-anchor" href="#analogue-3">§</a>Analogue</h5>
<p>See [<code>as_bitptr</code>] for a <code>&amp;BitVec -&gt; *const BitSlice</code> transform.</p>
<h5 id="examples-11"><a class="doc-anchor" href="#examples-11">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[Lsb0; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>bv_ptr = bv.as_ptr();

<span class="kw">unsafe </span>{
  <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>bv_ptr, <span class="number">0b1010</span>);
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut_ptr" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#603-605">source</a><h4 class="code-header">pub fn <a href="#method.as_mut_ptr" class="fn">as_mut_ptr</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.pointer.html">*mut T</a></h4></section></summary><div class="docblock"><p>Returns an unsafe mutable pointer to the vector’s buffer.</p>
<p>The caller must ensure that the vector outlives the pointer this
function returns, or else it will end up pointing to garbage. Modifying
the vector may cause its buffer to be reällocated, which would also make
any pointers to it invalid.</p>
<h5 id="original-13"><a class="doc-anchor" href="#original-13">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.as_mut_ptr"><code>Vec::as_mut_ptr</code></a></p>
<h5 id="analogue-4"><a class="doc-anchor" href="#analogue-4">§</a>Analogue</h5>
<p>See <a href="#method.as_mut_bitptr"><code>as_mut_bitptr</code></a> for a <code>&amp;mut BitVec -&gt; *mut BitSlice</code> transform.</p>
<h5 id="eaxmples"><a class="doc-anchor" href="#eaxmples">§</a>Eaxmples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>size = <span class="number">4</span>;
<span class="kw">let </span><span class="kw-2">mut </span>bv: BitVec&lt;Msb0, usize&gt; = BitVec::with_capacity(size);
<span class="kw">let </span>bv_ptr = bv.as_mut_ptr();

<span class="kw">unsafe </span>{
  <span class="kw-2">*</span>bv_ptr = !<span class="number">0</span>;
  bv.set_len(size);
}
<span class="macro">assert_eq!</span>(bv.len(), <span class="number">4</span>);
<span class="macro">assert!</span>(bv.all());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_len" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#667-687">source</a><h4 class="code-header">pub unsafe fn <a href="#method.set_len" class="fn">set_len</a>(&amp;mut self, new_len: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Forces the length of the vector to <code>new_len</code>.</p>
<p>This is a low-level operation that maintains none of the normal
invariants of the type. Normally changing the length of a vector is done
using one of the safe operations instead, such as <a href="#method.truncate"><code>truncate</code></a>,
<a href="#method.resize"><code>resize</code></a>, <a href="#method.extend"><code>extend</code></a>, or <a href="#method.clear"><code>clear</code></a>.</p>
<h5 id="original-14"><a class="doc-anchor" href="#original-14">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.set_len"><code>Vec::set_len</code></a></p>
<h5 id="safety-2"><a class="doc-anchor" href="#safety-2">§</a>Safety</h5>
<ul>
<li><code>new_len</code> must be less than or equal to <a href="#method.capacity"><code>capacity()</code></a>.</li>
</ul>
<h5 id="examples-12"><a class="doc-anchor" href="#examples-12">§</a>Examples</h5>
<p>This method can be useful for situations in which the vector is serving
as a buffer for other code, particularly over FFI:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="comment">// `bitvec` could pair with `rustler` for a better bitstream
</span><span class="kw">type </span>ErlBitstring = BitVec&lt;Msb0, u8&gt;;
<span class="kw">let </span><span class="kw-2">mut </span>bits_read = <span class="number">0</span>;
<span class="comment">// An imaginary Erlang function wants a large bit buffer.
</span><span class="kw">let </span><span class="kw-2">mut </span>buf = ErlBitstring::with_capacity(<span class="number">32_768</span>);
<span class="comment">// SAFETY: When `erl_read_bits` returns `ERL_OK`, it holds that:
// 1. `bits_read` bits were initialized.
// 2. `bits_read` &lt;= the capacity (32_768)
// which makes `set_len` safe to call.
</span><span class="kw">unsafe </span>{
  <span class="comment">// Make the FFI call...
  </span><span class="kw">let </span>status = erl_read_bits(<span class="kw-2">&amp;mut </span>buf, <span class="number">10</span>, <span class="kw-2">&amp;mut </span>bits_read);
  <span class="kw">if </span>status == ERL_OK {
    <span class="comment">// ...and update the length to what was read in.
    </span>buf.set_len(bits_read);
  }
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.swap_remove" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#716-726">source</a><h4 class="code-header">pub fn <a href="#method.swap_remove" class="fn">swap_remove</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Removes a bit from the vector and returns it.</p>
<p>The removed bit is replaced by the last bit of the vector.</p>
<p>This does not preserve ordering, but is O(1).</p>
<h5 id="original-15"><a class="doc-anchor" href="#original-15">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.swap_remove"><code>Vec::swap_remove</code></a></p>
<h5 id="panics-4"><a class="doc-anchor" href="#panics-4">§</a>Panics</h5>
<p>Panics if <code>index</code> is out of bounds.</p>
<h5 id="examples-13"><a class="doc-anchor" href="#examples-13">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert!</span>(!bv.swap_remove(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);

<span class="macro">assert!</span>(!bv.swap_remove(<span class="number">0</span>));
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.insert" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#751-756">source</a><h4 class="code-header">pub fn <a href="#method.insert" class="fn">insert</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Inserts a bit at position <code>index</code> within the vector, shifting all bits
after it to the right.</p>
<h5 id="original-16"><a class="doc-anchor" href="#original-16">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.insert"><code>Vec::insert</code></a></p>
<h5 id="panics-5"><a class="doc-anchor" href="#panics-5">§</a>Panics</h5>
<p>Panics if <code>index &gt; len</code>.</p>
<h5 id="examples-14"><a class="doc-anchor" href="#examples-14">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>; <span class="number">5</span>];
bv.insert(<span class="number">4</span>, <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]);
bv.insert(<span class="number">2</span>, <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.remove" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#779-788">source</a><h4 class="code-header">pub fn <a href="#method.remove" class="fn">remove</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Removes and returns the bit at position <code>index</code> within the vector,
shifting all bits after it to the left.</p>
<h5 id="original-17"><a class="doc-anchor" href="#original-17">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.remove"><code>Vec::remove</code></a></p>
<h5 id="panics-6"><a class="doc-anchor" href="#panics-6">§</a>Panics</h5>
<p>Panics if <code>index</code> is out of bounds.</p>
<h5 id="examples-15"><a class="doc-anchor" href="#examples-15">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert!</span>(bv.remove(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.retain" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#816-823">source</a><h4 class="code-header">pub fn <a href="#method.retain" class="fn">retain</a>&lt;F&gt;(&amp;mut self, func: F)<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Retains only the bits specified by the predicate.</p>
<p>In other words, remove all bits <code>b</code> such that <code>func(idx(b), &amp;b)</code> returns
<code>false</code>. This method operates in place, visiting each bit exactly once
in the original order, and preserves the order of the retained bits.</p>
<h5 id="original-18"><a class="doc-anchor" href="#original-18">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.retain"><code>Vec::retain</code></a></p>
<h5 id="api-differences-2"><a class="doc-anchor" href="#api-differences-2">§</a>API Differences</h5>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h5 id="examples-16"><a class="doc-anchor" href="#examples-16">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
bv.retain(|i, b| (i % <span class="number">2 </span>== <span class="number">0</span>) ^ b);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.push" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#846-866">source</a><h4 class="code-header">pub fn <a href="#method.push" class="fn">push</a>(&amp;mut self, value: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Appends a bit to the back of a collection.</p>
<h5 id="original-19"><a class="doc-anchor" href="#original-19">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.push"><code>Vec::push</code></a></p>
<h5 id="panics-7"><a class="doc-anchor" href="#panics-7">§</a>Panics</h5>
<p>Panics if the number of bits in the vector exceeds the maximum vector
capacity.</p>
<h5 id="examples-17"><a class="doc-anchor" href="#examples-17">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>];
bv.push(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(bv.count_ones(), <span class="number">1</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pop" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#887-895">source</a><h4 class="code-header">pub fn <a href="#method.pop" class="fn">pop</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>&gt;</h4></section></summary><div class="docblock"><p>Removes the last bit from a vector and returns it, or <a href="https://doc.rust-lang.org/core/option/enum.Option.html#variant.None"><code>None</code></a> if it is
empty.</p>
<h5 id="original-20"><a class="doc-anchor" href="#original-20">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.pop"><code>Vec::pop</code></a></p>
<h5 id="examples-18"><a class="doc-anchor" href="#examples-18">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert_eq!</span>(bv.pop(), <span class="prelude-val">Some</span>(<span class="bool-val">true</span>));
<span class="macro">assert!</span>(bv.not_any());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.append" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#921-928">source</a><h4 class="code-header">pub fn <a href="#method.append" class="fn">append</a>&lt;O2, T2&gt;(&amp;mut self, other: &amp;mut <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O2, T2&gt;)<div class="where">where
    O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h4></section></summary><div class="docblock"><p>Moves all the bits of <code>other</code> into <code>self</code>, leaving <code>other</code> empty.</p>
<h5 id="original-21"><a class="doc-anchor" href="#original-21">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.append"><code>Vec::append</code></a></p>
<h5 id="panics-8"><a class="doc-anchor" href="#panics-8">§</a>Panics</h5>
<p>Panics if the number of bits overflows the maximum vector capacity.</p>
<h5 id="examples-19"><a class="doc-anchor" href="#examples-19">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv1 = <span class="macro">bitvec!</span>[<span class="number">0</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>bv2 = <span class="macro">bitvec!</span>[<span class="number">1</span>; <span class="number">10</span>];

bv1.append(<span class="kw-2">&amp;mut </span>bv2);

<span class="macro">assert_eq!</span>(bv1.count_ones(), <span class="number">10</span>);
<span class="macro">assert!</span>(bv2.is_empty());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.drain" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#964-967">source</a><h4 class="code-header">pub fn <a href="#method.drain" class="fn">drain</a>&lt;R&gt;(&amp;mut self, range: R) -&gt; <a class="struct" href="struct.Drain.html" title="struct bitvec::vec::Drain">Drain</a>&lt;'_, O, T&gt; <a href="#" class="tooltip" data-notable-ty="Drain&lt;&#39;_, O, T&gt;">ⓘ</a><div class="where">where
    R: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Creates a draining iterator that removes the specified range in the
vector and yields the removed items.</p>
<p>Note 1: The bit range is removed even if the iterator is only partially
consumed or not consumed at all.</p>
<p>Note 2: It is unspecified how many bits are removed from the vector if
the <code>Drain</code> value is leaked.</p>
<h5 id="original-22"><a class="doc-anchor" href="#original-22">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.drain"><code>Vec::drain</code></a></p>
<h5 id="panics-9"><a class="doc-anchor" href="#panics-9">§</a>Panics</h5>
<p>Panics if the starting point is greater than the end point or if the end
point is greater than the length of the vector.</p>
<h5 id="examples-20"><a class="doc-anchor" href="#examples-20">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let </span>bv2: BitVec = bv.drain(<span class="number">1 </span>..).collect();
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(bv2, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>]);

<span class="comment">// A full range clears the vector
</span>bv.drain(..);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.clear" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#990-994">source</a><h4 class="code-header">pub fn <a href="#method.clear" class="fn">clear</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Clears the vector, removing all values.</p>
<p>Note that this method has no effect on the allocated capacity of the
vector.</p>
<h5 id="original-23"><a class="doc-anchor" href="#original-23">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.clear"><code>Vec::clear</code></a></p>
<h5 id="examples-21"><a class="doc-anchor" href="#examples-21">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];

bv.clear();

<span class="macro">assert!</span>(bv.is_empty());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_off" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#1021-1032">source</a><h4 class="code-header">pub fn <a href="#method.split_off" class="fn">split_off</a>(&amp;mut self, at: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Splits the collection into two at the given index.</p>
<p>Returns a newly allocated vector containing the elements in range <code>[at, len)</code>. After the call, the original vector will be left containing the
bits <code>[0, at)</code> with its previous capacity unchanged.</p>
<h5 id="original-24"><a class="doc-anchor" href="#original-24">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.split_off"><code>Vec::split_off</code></a></p>
<h5 id="panics-10"><a class="doc-anchor" href="#panics-10">§</a>Panics</h5>
<p>Panics if <code>at &gt; len</code>.</p>
<h5 id="examples-22"><a class="doc-anchor" href="#examples-22">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>bv2 = bv.split_off(<span class="number">1</span>);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(bv2, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.resize_with" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#1072-1086">source</a><h4 class="code-header">pub fn <a href="#method.resize_with" class="fn">resize_with</a>&lt;F&gt;(&amp;mut self, new_len: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>, func: F)<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>() -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Resizes the <code>BitVec</code> in-place so that <code>len</code> is equal to <code>new_len</code>.</p>
<p>If <code>new_len</code> is greater than <code>len</code>, the <code>BitVec</code> is extended by the
difference, with each additional slot filled with the result of calling
the closure <code>func</code>. The return values from <code>func</code> will end up in the
<code>BitVec</code> in the order they have been generated.</p>
<p>If <code>new_len</code> is less than <code>len</code>, the <code>Vec</code> is simply truncated.</p>
<p>This method uses a closure to create new values on every push. If you’d
rather <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a> a given bit, use <a href="#method.resize"><code>resize</code></a>. If you want to use the
<a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> trait to generate values, you can pass <a href="https://doc.rust-lang.org/std/default/trait.Default.html#tymethod.default"><code>Default::default</code></a>
as the second argument.</p>
<h5 id="original-25"><a class="doc-anchor" href="#original-25">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.resize_with"><code>Vec::resize_with</code></a></p>
<h5 id="examples-23"><a class="doc-anchor" href="#examples-23">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">1</span>; <span class="number">3</span>];
bv.resize_with(<span class="number">5</span>, Default::default);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[];
<span class="kw">let </span><span class="kw-2">mut </span>p = <span class="number">0</span>;
bv.resize_with(<span class="number">4</span>, || { p += <span class="number">1</span>; p % <span class="number">2 </span>== <span class="number">0 </span>});
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.resize" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#1117-1140">source</a><h4 class="code-header">pub fn <a href="#method.resize" class="fn">resize</a>(&amp;mut self, new_len: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Resizes the <code>BitVec</code> in-place so that <code>len</code> is equal to <code>new_len</code>.</p>
<p>If <code>new_len</code> is greater than <code>len</code>, the <code>BitVec</code> is extended by the
difference, with each additional slot filled with <code>value</code>. If <code>new_len</code>
is less than <code>len</code>, the <code>BitVec</code> is simply truncated.</p>
<p>This method requires a single <code>bool</code> value. If you need more
flexibility, use <a href="#method.resize_with"><code>resize_with</code></a>.</p>
<h5 id="original-26"><a class="doc-anchor" href="#original-26">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.resize"><code>Vec::resize</code></a></p>
<h5 id="examples-24"><a class="doc-anchor" href="#examples-24">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">1</span>];
bv.resize(<span class="number">3</span>, <span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">1</span>; <span class="number">4</span>];
bv.resize(<span class="number">2</span>, <span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">2</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.extend_from_slice" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#1172-1174">source</a><h4 class="code-header">pub fn <a href="#method.extend_from_slice" class="fn">extend_from_slice</a>(&amp;mut self, other: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>])</h4></section></summary><div class="docblock"><p>Clones and appends all <code>bool</code>s in a slice to the <code>BitVec</code>.</p>
<p>Iterates over the slice <code>other</code>, clones each <code>bool</code>, and then appends it
to the <code>BitVec</code>. The <code>other</code> slice is traversed in-order.</p>
<p>Prefer the <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend"><code>Extend</code></a> implementation; this method is retained only for
API compatibility, and offers no performance benefit.</p>
<h5 id="original-27"><a class="doc-anchor" href="#original-27">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.extend_from_slice"><code>Vec::extend_from_slice</code></a></p>
<h5 id="analogue-5"><a class="doc-anchor" href="#analogue-5">§</a>Analogue</h5>
<p>See [<code>extend_from_bitslice</code>] for the method to append a bit-slice of the
same type parameters to a bit-vector.</p>
<h5 id="examples-25"><a class="doc-anchor" href="#examples-25">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>];
bv.extend_from_slice(<span class="kw-2">&amp;</span>[<span class="bool-val">true</span>]);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
<p>[<code>extend</code>]: #impl-Extend&lt;%26’a bool&gt;
[<code>extend_from_bitslice</code>]: #method.extend_from_bitslice</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.splice" class="method"><a class="src rightside" href="../../src/bitvec/vec/api.rs.html#1214-1224">source</a><h4 class="code-header">pub fn <a href="#method.splice" class="fn">splice</a>&lt;R, I&gt;(
    &amp;mut self,
    range: R,
    replace_with: I,
) -&gt; <a class="struct" href="struct.Splice.html" title="struct bitvec::vec::Splice">Splice</a>&lt;'_, O, T, I::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a>&gt; <a href="#" class="tooltip" data-notable-ty="Splice&lt;&#39;_, O, T, I::IntoIter&gt;">ⓘ</a><div class="where">where
    R: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt;,
    I: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Creates a splicing iterator that replaces the specified range in the
vector with the given <code>replace_with</code> iterator and yields the removed
items. <code>replace_with</code> does not need to be the same length as <code>range</code>.</p>
<p>The element range is removed even if the iterator is not consumed until
the end.</p>
<p>It is unspecified how many bits are removed from the vector if the
<code>Splice</code> value is leaked.</p>
<p>The input iterator <code>replace_with</code> is only consumed when the <code>Splice</code>
value is dropped.</p>
<p>This is optimal if:</p>
<ul>
<li>the tail (bits in the vector after <code>range</code>) is empty</li>
<li>or <code>replace_with</code> yields fewer bits than <code>range</code>’s length</li>
<li>or the lower bound of its <code>size_hint()</code> is exact</li>
</ul>
<p>Otherwise, a temporary vector is allocated and the tail is moved twice.</p>
<h5 id="original-28"><a class="doc-anchor" href="#original-28">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.splice"><code>Vec::splice</code></a></p>
<h5 id="examples-26"><a class="doc-anchor" href="#examples-26">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let </span>new = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let </span>old: BitVec = bv.splice(.. <span class="number">2</span>, new.iter().copied()).collect();
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);
<span class="macro">assert_eq!</span>(old, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitVec%3CO,+T%3E-1" class="impl"><a class="src rightside" href="../../src/bitvec/vec.rs.html#142-685">source</a><a href="#impl-BitVec%3CO,+T%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="docblock"><p>Methods specific to <code>BitVec&lt;_, T&gt;</code>, and not present on <code>Vec&lt;T&gt;</code>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.repeat" class="method"><a class="src rightside" href="../../src/bitvec/vec.rs.html#170-177">source</a><h4 class="code-header">pub fn <a href="#method.repeat" class="fn">repeat</a>(bit: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>, len: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs a <code>BitVec</code> from a value repeated many times.</p>
<p>This function is equivalent to the <code>bitvec![O, T; bit; len]</code> macro call,
and is in fact the implementation of that macro syntax.</p>
<h5 id="parameters"><a class="doc-anchor" href="#parameters">§</a>Parameters</h5>
<ul>
<li><code>bit</code>: The bit value to which all <code>len</code> allocated bits will be set.</li>
<li><code>len</code>: The number of live bits in the constructed <code>BitVec</code>.</li>
</ul>
<h5 id="returns"><a class="doc-anchor" href="#returns">§</a>Returns</h5>
<p>A <code>BitVec</code> with <code>len</code> live bits, all set to <code>bit</code>.</p>
<h5 id="examples-27"><a class="doc-anchor" href="#examples-27">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = BitVec::&lt;Msb0, u8&gt;::repeat(<span class="bool-val">true</span>, <span class="number">20</span>);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">20</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_bitslice" class="method"><a class="src rightside" href="../../src/bitvec/vec.rs.html#205-224">source</a><h4 class="code-header">pub fn <a href="#method.from_bitslice" class="fn">from_bitslice</a>(slice: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;) -&gt; Self</h4></section></summary><div class="docblock"><p>Clones a <code>&amp;BitSlice</code> into a <code>BitVec</code>.</p>
<h5 id="original-29"><a class="doc-anchor" href="#original-29">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#impl-Clone"><code>&lt;Vec&lt;T: Clone&gt; as Clone&gt;::clone</code></a></p>
<h5 id="effects"><a class="doc-anchor" href="#effects">§</a>Effects</h5>
<p>This performs a direct element-wise copy from the source slice to the
newly-allocated buffer, then sets the vector to have the same starting
bit as the slice did. This allows for faster behavior. If you require
that the vector start at the leading edge of the first element, use
<a href="#method.force_align"><code>force_align</code></a> to guarantee this.</p>
<h5 id="examples-28"><a class="doc-anchor" href="#examples-28">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let </span>bv = BitVec::from_bitslice(<span class="kw-2">&amp;</span>bits[<span class="number">2 </span>..]);
<span class="macro">assert_eq!</span>(bv, bits[<span class="number">2 </span>..]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_vec" class="method"><a class="src rightside" href="../../src/bitvec/vec.rs.html#254-257">source</a><h4 class="code-header">pub fn <a href="#method.from_vec" class="fn">from_vec</a>(vec: <a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;) -&gt; Self</h4></section></summary><div class="docblock"><p>Converts a <code>Vec&lt;T&gt;</code> into a <code>BitVec&lt;O, T&gt;</code> without copying its buffer.</p>
<h5 id="parameters-1"><a class="doc-anchor" href="#parameters-1">§</a>Parameters</h5>
<ul>
<li><code>vec</code>: A vector to view as bits.</li>
</ul>
<h5 id="returns-1"><a class="doc-anchor" href="#returns-1">§</a>Returns</h5>
<p>A <code>BitVec</code> over the <code>vec</code> buffer.</p>
<h5 id="panics-11"><a class="doc-anchor" href="#panics-11">§</a>Panics</h5>
<p>This panics if <code>vec</code> is too long to convert into a <code>BitVec</code>. See
<a href="../slice/struct.BitSlice.html#associatedconstant.MAX_ELTS"><code>BitSlice::MAX_ELTS</code></a>.</p>
<h5 id="examples-29"><a class="doc-anchor" href="#examples-29">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>vec = <span class="macro">vec!</span>[<span class="number">0u8</span>; <span class="number">4</span>];
<span class="kw">let </span>bv = BitVec::&lt;LocalBits, <span class="kw">_</span>&gt;::from_vec(vec);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">32</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from_vec" class="method"><a class="src rightside" href="../../src/bitvec/vec.rs.html#289-308">source</a><h4 class="code-header">pub fn <a href="#method.try_from_vec" class="fn">try_from_vec</a>(vec: <a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, <a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;&gt;</h4></section></summary><div class="docblock"><p>Converts a <code>Vec&lt;T&gt;</code> into a <code>BitVec&lt;O, T&gt;</code> without copying its buffer.</p>
<p>This method takes ownership of a memory buffer and enables it to be used
as a bit-vector. Because <code>Vec</code> can be longer than <code>BitVec</code>s, this is a
fallible method, and the original vector will be returned if it cannot
be converted.</p>
<h5 id="parameters-2"><a class="doc-anchor" href="#parameters-2">§</a>Parameters</h5>
<ul>
<li><code>vec</code>: Some vector of memory, to be viewed as bits.</li>
</ul>
<h5 id="returns-2"><a class="doc-anchor" href="#returns-2">§</a>Returns</h5>
<p>If <code>vec</code> is short enough to be viewed as a <code>BitVec</code>, then this returns
a <code>BitVec</code> over the <code>vec</code> buffer. If <code>vec</code> is too long, then this
returns <code>vec</code> unmodified.</p>
<h5 id="examples-30"><a class="doc-anchor" href="#examples-30">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>vec = <span class="macro">vec!</span>[<span class="number">0u8</span>; <span class="number">4</span>];
<span class="kw">let </span>bv = BitVec::&lt;LocalBits, <span class="kw">_</span>&gt;::try_from_vec(vec).unwrap();
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">32</span>]);</code></pre></div>
<p>An example showing this function failing would require an allocation
exceeding <code>!0usize &gt;&gt; 3</code> bytes in size, which is infeasible to produce.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.extend_from_bitslice" class="method"><a class="src rightside" href="../../src/bitvec/vec.rs.html#337-342">source</a><h4 class="code-header">pub fn <a href="#method.extend_from_bitslice" class="fn">extend_from_bitslice</a>(&amp;mut self, other: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;)</h4></section></summary><div class="docblock"><p>Copies all bits in a <code>BitSlice</code> into the <code>BitVec</code>.</p>
<p>This is provided for API completeness; it has no performance benefits
compared to use of the <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend"><code>Extend</code></a> implementation.</p>
<h5 id="parameters-3"><a class="doc-anchor" href="#parameters-3">§</a>Parameters</h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>other</code>: A <code>BitSlice</code> reference of the same type parameters as <code>self</code>.</li>
</ul>
<h5 id="behavior-1"><a class="doc-anchor" href="#behavior-1">§</a>Behavior</h5>
<p><code>self</code> is extended by the length of <code>other</code>, and then the contents of
<code>other</code> are copied into the newly-allocated end of <code>self</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>];
bv.extend_from_bitslice(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);

<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
<p><a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend"><code>Extend</code></a>: #impl-Extend&lt;%26’a bool&gt;
[<code>.as_bitslice()</code>]: #method.as_bitslice()</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.into_boxed_bitslice" class="method"><a class="src rightside" href="../../src/bitvec/vec.rs.html#364-371">source</a><h4 class="code-header">pub fn <a href="#method.into_boxed_bitslice" class="fn">into_boxed_bitslice</a>(self) -&gt; <a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;O, T&gt;</h4></section></summary><div class="docblock"><p>Converts the vector into <a href="../boxed/struct.BitBox.html"><code>BitBox&lt;O, T&gt;</code></a>.</p>
<p>Note that this will drop any excess capacity.</p>
<h5 id="original-30"><a class="doc-anchor" href="#original-30">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.into_boxed_slice"><code>Vec::into_boxed_slice</code></a></p>
<h5 id="examples-31"><a class="doc-anchor" href="#examples-31">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">1</span>; <span class="number">50</span>];
<span class="kw">let </span>bb: BitBox = bv.into_boxed_bitslice();
<span class="macro">assert_eq!</span>(bb, <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">50</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.into_vec" class="method"><a class="src rightside" href="../../src/bitvec/vec.rs.html#396-406">source</a><h4 class="code-header">pub fn <a href="#method.into_vec" class="fn">into_vec</a>(self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Converts the vector back into an ordinary vector of memory elements.</p>
<p>This does not affect the vector’s buffer, only the handle used to
control it.</p>
<h5 id="parameters-4"><a class="doc-anchor" href="#parameters-4">§</a>Parameters</h5>
<ul>
<li><code>self</code></li>
</ul>
<h5 id="returns-3"><a class="doc-anchor" href="#returns-3">§</a>Returns</h5>
<p>An ordinary vector containing all of the bit-vector’s memory buffer.</p>
<h5 id="examples-32"><a class="doc-anchor" href="#examples-32">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let </span>vec = bv.into_vec();
<span class="macro">assert_eq!</span>(vec, [<span class="number">0</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.elements" class="method"><a class="src rightside" href="../../src/bitvec/vec.rs.html#419-421">source</a><h4 class="code-header">pub fn <a href="#method.elements" class="fn">elements</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Gets the number of elements <code>T</code> that contain live bits of the vector.</p>
<h5 id="examples-33"><a class="doc-anchor" href="#examples-33">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[LocalBits, u16; <span class="number">1</span>; <span class="number">50</span>];
<span class="macro">assert_eq!</span>(bv.elements(), <span class="number">4</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_uninitialized" class="method"><a class="src rightside" href="../../src/bitvec/vec.rs.html#448-460">source</a><h4 class="code-header">pub fn <a href="#method.set_uninitialized" class="fn">set_uninitialized</a>(&amp;mut self, value: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Sets the uninitialized bits of the vector to a fixed value.</p>
<p>This method modifies all bits in the allocated buffer that are outside
the <code>self.as_bitslice()</code> view so that they have a consistent value. This
can be used to zero the uninitialized memory so that when viewed as a
raw memory slice, bits outside the live region have a predictable value.</p>
<h5 id="examples-34"><a class="doc-anchor" href="#examples-34">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="number">220u8</span>.view_bits::&lt;Lsb0&gt;().to_bitvec();
<span class="macro">assert_eq!</span>(bv.as_slice(), <span class="kw-2">&amp;</span>[<span class="number">220u8</span>]);
bv.truncate(<span class="number">4</span>);
<span class="macro">assert_eq!</span>(bv.count_ones(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(bv.as_slice(), <span class="kw-2">&amp;</span>[<span class="number">220u8</span>]);

bv.set_uninitialized(<span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(bv.as_slice(), <span class="kw-2">&amp;</span>[<span class="number">12u8</span>]);

bv.set_uninitialized(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(bv.as_slice(), <span class="kw-2">&amp;</span>[!<span class="number">3u8</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.force_align" class="method"><a class="src rightside" href="../../src/bitvec/vec.rs.html#483-495">source</a><h4 class="code-header">pub fn <a href="#method.force_align" class="fn">force_align</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Ensures that the live region of the vector’s contents begins at the
leading edge of the buffer.</p>
<h5 id="examples-35"><a class="doc-anchor" href="#examples-35">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>data = <span class="number">0x3Cu8</span>;
<span class="kw">let </span>bits = data.view_bits::&lt;Msb0&gt;();

<span class="kw">let </span><span class="kw-2">mut </span>bv = bits[<span class="number">2 </span>.. <span class="number">6</span>].to_bitvec();
<span class="macro">assert_eq!</span>(bv, bits[<span class="number">2 </span>.. <span class="number">6</span>]);
<span class="macro">assert_eq!</span>(bv.as_slice()[<span class="number">0</span>], data);

bv.force_align();
<span class="macro">assert_eq!</span>(bv, bits[<span class="number">2 </span>.. <span class="number">6</span>]);
<span class="comment">//  It is not specified what happens to bits that are no longer used.
</span><span class="macro">assert_eq!</span>(bv.as_slice()[<span class="number">0</span>] &amp; <span class="number">0xF0</span>, <span class="number">0xF0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_elements" class="method"><a class="src rightside" href="../../src/bitvec/vec.rs.html#522-526">source</a><h4 class="code-header">pub fn <a href="#method.set_elements" class="fn">set_elements</a>(&amp;mut self, element: T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>)</h4></section></summary><div class="docblock"><p>Writes a value into every element that the vector considers live.</p>
<p>This unconditionally writes <code>element</code> into each live location in the
backing buffer, without altering the <code>BitVec</code>’s length or capacity.</p>
<p>It is unspecified what effects this has on the allocated but dead
elements in the buffer.</p>
<h5 id="parameters-5"><a class="doc-anchor" href="#parameters-5">§</a>Parameters</h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>element</code>: The value which will be written to each live location in
the vector’s buffer.</li>
</ul>
<h5 id="examples-36"><a class="doc-anchor" href="#examples-36">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[LocalBits, u8; <span class="number">0</span>; <span class="number">10</span>];
<span class="macro">assert_eq!</span>(bv.as_slice(), [<span class="number">0</span>, <span class="number">0</span>]);
bv.set_elements(<span class="number">0xA5</span>);
<span class="macro">assert_eq!</span>(bv.as_slice(), [<span class="number">0xA5</span>, <span class="number">0xA5</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_bitslice" class="method"><a class="src rightside" href="../../src/bitvec/vec.rs.html#546-548">source</a><h4 class="code-header">pub fn <a href="#method.as_bitslice" class="fn">as_bitslice</a>(&amp;self) -&gt; &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <a href="#" class="tooltip" data-notable-ty="&amp;BitSlice&lt;O, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Views the buffer’s contents as a <code>BitSlice</code>.</p>
<p>This is equivalent to <code>&amp;bv[..]</code>.</p>
<h5 id="original-31"><a class="doc-anchor" href="#original-31">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.as_slice"><code>Vec::as_slice</code></a></p>
<h5 id="examples-37"><a class="doc-anchor" href="#examples-37">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let </span>bits = bv.as_bitslice();</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut_bitslice" class="method"><a class="src rightside" href="../../src/bitvec/vec.rs.html#569-571">source</a><h4 class="code-header">pub fn <a href="#method.as_mut_bitslice" class="fn">as_mut_bitslice</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <a href="#" class="tooltip" data-notable-ty="&amp;mut BitSlice&lt;O, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Extracts a mutable bit-slice of the entire vector.</p>
<p>Equivalent to <code>&amp;mut bv[..]</code>.</p>
<h5 id="original-32"><a class="doc-anchor" href="#original-32">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.as_mut_slice"><code>Vec::as_mut_slice</code></a></p>
<h5 id="examples-38"><a class="doc-anchor" href="#examples-38">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>bits = bv.as_mut_bitslice();
bits.set(<span class="number">0</span>, <span class="bool-val">true</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_bitptr" class="method"><a class="src rightside" href="../../src/bitvec/vec.rs.html#605-607">source</a><h4 class="code-header">pub fn <a href="#method.as_bitptr" class="fn">as_bitptr</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.pointer.html">*const </a><a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</h4></section></summary><div class="docblock"><p>Returns a raw pointer to the vector’s region.</p>
<p>The caller must ensure that the vector outlives the pointer this
function returns, or else it will end up pointing to garbage. Modifying
the vector may cause its buffer to be reallocated, which would also make
any pointers to it invalid.</p>
<p>The caller must also ensure that the memory the pointer
(non-transitively) points to is never written to (except inside an
<code>UnsafeCell</code>) using this pointer or any pointer derived from it. If you
need to mutate the contents of the region, use <a href="#method.as_mut_bitptr"><code>as_mut_bitptr</code></a>.</p>
<p>This pointer is an opaque crate-internal type. Its in-memory
representation is unsafe to modify in any way. The only safe action to
take with this pointer is to pass it, unchanged, back into a <code>bitvec</code>
API.</p>
<h5 id="examples-39"><a class="doc-anchor" href="#examples-39">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>; <span class="number">20</span>];
<span class="kw">let </span>ptr = bv.as_bitptr();

<span class="kw">let </span>bits = <span class="kw">unsafe </span>{ <span class="kw-2">&amp;*</span>ptr };
<span class="macro">assert_eq!</span>(bv, bits);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut_bitptr" class="method"><a class="src rightside" href="../../src/bitvec/vec.rs.html#634-636">source</a><h4 class="code-header">pub fn <a href="#method.as_mut_bitptr" class="fn">as_mut_bitptr</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.pointer.html">*mut </a><a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</h4></section></summary><div class="docblock"><p>Returns an unsafe mutable pointer to the vector’s region.</p>
<p>The caller must ensure that the vector outlives the pointer this
function returns, or else it will end up pointing to garbage. Modifying
the vector may cause its buffer to be reallocated, which would also make
any pointers to it invalid.</p>
<p>This pointer is an opaque crate-internal type. Its in-memory
representation is unsafe to modify in any way. The only safe action to
take with this pointer is to pass it, unchanged, back into a <code>bitvec</code>
API.</p>
<h5 id="examples-40"><a class="doc-anchor" href="#examples-40">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>; <span class="number">20</span>];
<span class="kw">let </span>ptr = bv.as_mut_bitptr();

<span class="kw">let </span>bits = <span class="kw">unsafe </span>{ <span class="kw-2">&amp;mut *</span>ptr };
<span class="macro">assert_eq!</span>(bv, bits);</code></pre></div>
</div></details></div></details></div><h2 id="deref-methods-BitSlice%3CO,+T%3E" class="section-header"><span>Methods from <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt;</span><a href="#deref-methods-BitSlice%3CO,+T%3E" class="anchor">§</a></h2><div id="deref-methods-BitSlice%3CO,+T%3E-1" class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.len" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#84-86">source</a><h4 class="code-header">pub fn <a href="#method.len" class="fn">len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of bits in the slice.</p>
<h5 id="original-33"><a class="doc-anchor" href="#original-33">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.len"><code>slice::len</code></a></p>
<h5 id="examples-41"><a class="doc-anchor" href="#examples-41">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>].len(), <span class="number">1</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_empty" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#103-112">source</a><h4 class="code-header">pub fn <a href="#method.is_empty" class="fn">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the slice has a length of 0.</p>
<h5 id="original-34"><a class="doc-anchor" href="#original-34">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.is_empty"><code>slice::is_empty</code></a></p>
<h5 id="examples-42"><a class="doc-anchor" href="#examples-42">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].is_empty());
<span class="macro">assert!</span>(!<span class="macro">bits!</span>[<span class="number">0</span>].is_empty());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.first" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#129-131">source</a><h4 class="code-header">pub fn <a href="#method.first" class="fn">first</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the first bit of the slice, or <code>None</code> if it is empty.</p>
<h5 id="original-35"><a class="doc-anchor" href="#original-35">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.first"><code>slice::first</code></a></p>
<h5 id="examples-43"><a class="doc-anchor" href="#examples-43">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>), <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>].first());
<span class="macro">assert!</span>(<span class="macro">bits!</span>[].first().is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.first_mut" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#160-162">source</a><h4 class="code-header">pub fn <a href="#method.first_mut" class="fn">first_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../slice/struct.BitMut.html" title="struct bitvec::slice::BitMut">BitMut</a>&lt;'_, O, T&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns a mutable pointer to the first bit of the slice, or <code>None</code> if it
is empty.</p>
<h5 id="original-36"><a class="doc-anchor" href="#original-36">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.first_mut"><code>slice::first_mut</code></a></p>
<h5 id="api-differences-3"><a class="doc-anchor" href="#api-differences-3">§</a>API Differences</h5>
<p>This crate cannot manifest <code>&amp;mut bool</code> references, and must use the
<code>BitMut</code> proxy type where <code>&amp;mut bool</code> exists in the standard library
API. The proxy value must be bound as <code>mut</code> in order to write through
it.</p>
<h5 id="examples-44"><a class="doc-anchor" href="#examples-44">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>];
<span class="macro">assert!</span>(!bits[<span class="number">0</span>]);
<span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="kw-2">mut </span>first) = bits.first_mut() {
  <span class="kw-2">*</span>first = <span class="bool-val">true</span>;
}
<span class="macro">assert!</span>(bits[<span class="number">0</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_first" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#182-190">source</a><h4 class="code-header">pub fn <a href="#method.split_first" class="fn">split_first</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(&amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>, <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Self</a>)&gt;</h4></section></summary><div class="docblock"><p>Returns the first and all the rest of the bits of the slice, or <code>None</code>
if it is empty.</p>
<h5 id="original-37"><a class="doc-anchor" href="#original-37">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#split_first"><code>slice::split_first</code></a></p>
<h5 id="examples-45"><a class="doc-anchor" href="#examples-45">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">if let </span><span class="prelude-val">Some</span>((first, rest)) = <span class="macro">bits!</span>[<span class="number">1</span>].split_first() {
  <span class="macro">assert!</span>(<span class="kw-2">*</span>first);
  <span class="macro">assert!</span>(rest.is_empty());
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_first_mut" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#227-237">source</a><h4 class="code-header">pub fn <a href="#method.split_first_mut" class="fn">split_first_mut</a>(
    &amp;mut self,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="../slice/struct.BitMut.html" title="struct bitvec::slice::BitMut">BitMut</a>&lt;'_, O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;, &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;)&gt;</h4></section></summary><div class="docblock"><p>Returns the first and all the rest of the bits of the slice, or <code>None</code>
if it is empty.</p>
<h5 id="original-38"><a class="doc-anchor" href="#original-38">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#split_first_mut"><code>slice::split_first_mut</code></a></p>
<h5 id="api-differences-4"><a class="doc-anchor" href="#api-differences-4">§</a>API Differences</h5>
<p>This crate cannot manifest <code>&amp;mut bool</code> references, and must use the
<code>BitMut</code> proxy type where <code>&amp;mut bool</code> exists in the standard library
API. The proxy value must be bound as <code>mut</code> in order to write through
it.</p>
<p>Because the references are permitted to use the same memory address,
they are marked as aliasing in order to satisfy Rust’s requirements
about freedom from data races.</p>
<h5 id="examples-46"><a class="doc-anchor" href="#examples-46">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">3</span>];
<span class="kw">if let </span><span class="prelude-val">Some</span>((<span class="kw-2">mut </span>first, rest)) = bits.split_first_mut() {
  <span class="kw-2">*</span>first = <span class="bool-val">true</span>;
  <span class="kw-2">*</span>rest.get_mut(<span class="number">1</span>).unwrap() = <span class="bool-val">true</span>;
}
<span class="macro">assert_eq!</span>(bits.count_ones(), <span class="number">2</span>);
<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="kw-2">mut</span>].split_first_mut().is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_last" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#258-266">source</a><h4 class="code-header">pub fn <a href="#method.split_last" class="fn">split_last</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(&amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>, <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Self</a>)&gt;</h4></section></summary><div class="docblock"><p>Returns the last and all the rest of the bits of the slice, or <code>None</code> if
it is empty.</p>
<h5 id="original-39"><a class="doc-anchor" href="#original-39">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_last"><code>slice::split_last</code></a></p>
<h5 id="examples-47"><a class="doc-anchor" href="#examples-47">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>];
<span class="kw">if let </span><span class="prelude-val">Some</span>((last, rest)) = bits.split_last() {
  <span class="macro">assert!</span>(<span class="kw-2">*</span>last);
  <span class="macro">assert!</span>(rest.is_empty());
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_last_mut" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#304-314">source</a><h4 class="code-header">pub fn <a href="#method.split_last_mut" class="fn">split_last_mut</a>(
    &amp;mut self,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="../slice/struct.BitMut.html" title="struct bitvec::slice::BitMut">BitMut</a>&lt;'_, O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;, &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;)&gt;</h4></section></summary><div class="docblock"><p>Returns the last and all the rest of the bits of the slice, or <code>None</code> if
it is empty.</p>
<h5 id="original-40"><a class="doc-anchor" href="#original-40">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_last_mut"><code>slice::split_last_mut</code></a></p>
<h5 id="api-differences-5"><a class="doc-anchor" href="#api-differences-5">§</a>API Differences</h5>
<p>This crate cannot manifest <code>&amp;mut bool</code> references, and must use the
<code>BitMut</code> proxy type where <code>&amp;mut bool</code> exists in the standard library
API. The proxy value must be bound as <code>mut</code> in order to write through
it.</p>
<p>Because the references are permitted to use the same memory address,
they are marked as aliasing in order to satisfy Rust’s requirements
about freedom from data races.</p>
<h5 id="examples-48"><a class="doc-anchor" href="#examples-48">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">3</span>];

<span class="kw">if let </span><span class="prelude-val">Some</span>((<span class="kw-2">mut </span>last, rest)) = bits.split_last_mut() {
  <span class="kw-2">*</span>last = <span class="bool-val">true</span>;
  <span class="kw-2">*</span>rest.get_mut(<span class="number">1</span>).unwrap() = <span class="bool-val">true</span>;
}
<span class="macro">assert_eq!</span>(bits.count_ones(), <span class="number">2</span>);
<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="kw-2">mut</span>].split_last_mut().is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.last" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#331-336">source</a><h4 class="code-header">pub fn <a href="#method.last" class="fn">last</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the last bit of the slice, or <code>None</code> if it is empty.</p>
<h5 id="original-41"><a class="doc-anchor" href="#original-41">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.last"><code>slice::last</code></a></p>
<h5 id="examples-49"><a class="doc-anchor" href="#examples-49">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].last());
<span class="macro">assert!</span>(<span class="macro">bits!</span>[].last().is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.last_mut" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#364-369">source</a><h4 class="code-header">pub fn <a href="#method.last_mut" class="fn">last_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../slice/struct.BitMut.html" title="struct bitvec::slice::BitMut">BitMut</a>&lt;'_, O, T&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns a mutable pointer to the last bit of the slice, or <code>None</code> if it
is empty.</p>
<h5 id="original-42"><a class="doc-anchor" href="#original-42">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.last_mut"><code>slice::last_mut</code></a></p>
<h5 id="api-differences-6"><a class="doc-anchor" href="#api-differences-6">§</a>API Differences</h5>
<p>This crate cannot manifest <code>&amp;mut bool</code> references, and must use the
<code>BitMut</code> proxy type where <code>&amp;mut bool</code> exists in the standard library
API. The proxy value must be bound as <code>mut</code> in order to write through
it.</p>
<h5 id="examples-50"><a class="doc-anchor" href="#examples-50">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>];
<span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="kw-2">mut </span>last) = bits.last_mut() {
  <span class="kw-2">*</span>last = <span class="bool-val">true</span>;
}
<span class="macro">assert!</span>(bits[<span class="number">0</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#396-399">source</a><h4 class="code-header">pub fn <a href="#method.get" class="fn">get</a>&lt;'a, I&gt;(&amp;'a self, index: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;I::<a class="associatedtype" href="../slice/trait.BitSliceIndex.html#associatedtype.Immut" title="type bitvec::slice::BitSliceIndex::Immut">Immut</a>&gt;<div class="where">where
    I: <a class="trait" href="../slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a reference to an element or subslice depending on the type of
index.</p>
<ul>
<li>If given a position, returns a reference to the element at that
position or <code>None</code> if out of bounds.</li>
<li>If given a range, returns the subslice corresponding to that range, or
<code>None</code> if out of bounds.</li>
</ul>
<h5 id="original-43"><a class="doc-anchor" href="#original-43">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get"><code>slice::get</code></a></p>
<h5 id="examples-51"><a class="doc-anchor" href="#examples-51">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>), bits.get(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>bits[<span class="number">1 </span>.. <span class="number">3</span>]), bits.get(<span class="number">1 </span>.. <span class="number">3</span>));
<span class="macro">assert!</span>(bits.get(<span class="number">9</span>).is_none());
<span class="macro">assert!</span>(bits.get(<span class="number">8 </span>.. <span class="number">10</span>).is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#425-428">source</a><h4 class="code-header">pub fn <a href="#method.get_mut" class="fn">get_mut</a>&lt;'a, I&gt;(&amp;'a mut self, index: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;I::<a class="associatedtype" href="../slice/trait.BitSliceIndex.html#associatedtype.Mut" title="type bitvec::slice::BitSliceIndex::Mut">Mut</a>&gt;<div class="where">where
    I: <a class="trait" href="../slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a mutable reference to an element or subslice depending on the
type of index (see <a href="#method.get"><code>get</code></a>) or <code>None</code> if the index is out of bounds.</p>
<h5 id="original-44"><a class="doc-anchor" href="#original-44">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/core/slice/trait.SliceIndex.html#method.get_mut"><code>slice::get_mut</code></a></p>
<h5 id="api-differences-7"><a class="doc-anchor" href="#api-differences-7">§</a>API Differences</h5>
<p>When <code>I</code> is <code>usize</code>, this returns <code>BitMut</code> instead of <code>&amp;mut bool</code>.</p>
<h5 id="examples-52"><a class="doc-anchor" href="#examples-52">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">2</span>];
<span class="macro">assert!</span>(!bits.get(<span class="number">1</span>).unwrap());
<span class="kw-2">*</span>bits.get_mut(<span class="number">1</span>).unwrap() = <span class="bool-val">true</span>;
<span class="macro">assert!</span>(bits.get(<span class="number">1</span>).unwrap());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#461-464">source</a><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked" class="fn">get_unchecked</a>&lt;'a, I&gt;(&amp;'a self, index: I) -&gt; I::<a class="associatedtype" href="../slice/trait.BitSliceIndex.html#associatedtype.Immut" title="type bitvec::slice::BitSliceIndex::Immut">Immut</a><div class="where">where
    I: <a class="trait" href="../slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a reference to an element or subslice, without doing bounds
checking.</p>
<p>This is generally not recommended; use with caution!</p>
<p>Unlike the original slice function, calling this with an out-of-bounds
index is not <em>technically</em> compile-time <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a>, as the
references produced do not actually describe local memory. However, the
use of an out-of-bounds index will eventually cause an out-of-bounds
memory read, which is a runtime safety violation. For a safe alternative
see <a href="#method.get"><code>get</code></a>.</p>
<h5 id="original-45"><a class="doc-anchor" href="#original-45">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked"><code>slice::get_unchecked</code></a></p>
<h5 id="examples-53"><a class="doc-anchor" href="#examples-53">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>];
<span class="kw">unsafe </span>{
  <span class="macro">assert!</span>(<span class="kw-2">*</span>bits.get_unchecked(<span class="number">1</span>));
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked_mut" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#499-502">source</a><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked_mut" class="fn">get_unchecked_mut</a>&lt;'a, I&gt;(&amp;'a mut self, index: I) -&gt; I::<a class="associatedtype" href="../slice/trait.BitSliceIndex.html#associatedtype.Mut" title="type bitvec::slice::BitSliceIndex::Mut">Mut</a><div class="where">where
    I: <a class="trait" href="../slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a mutable reference to the output at this location, without
doing bounds checking.</p>
<p>This is generally not recommended; use with caution!</p>
<p>Unlike the original slice function, calling this with an out-of-bounds
index is not <em>technically</em> compile-time <a href="../../reference/behavior-considered-undefined.html">undefined behavior</a>, as the
references produced do not actually describe local memory. However, the
use of an out-of-bounds index will eventually cause an out-of-bounds
memory write, which is a runtime safety violation. For a safe
alternative see <a href="#method.get_mut"><code>get_mut</code></a>.</p>
<h5 id="original-46"><a class="doc-anchor" href="#original-46">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked_mut"><code>slice::get_unchecked_mut</code></a></p>
<h5 id="examples-54"><a class="doc-anchor" href="#examples-54">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">2</span>];
<span class="kw">unsafe </span>{
  <span class="kw">let </span><span class="kw-2">mut </span>bit = bits.get_unchecked_mut(<span class="number">1</span>);
  <span class="kw-2">*</span>bit = <span class="bool-val">true</span>;
}
<span class="macro">assert!</span>(bits[<span class="number">1</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ptr-1" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#556-558">source</a><h4 class="code-header">pub fn <a href="#method.as_ptr-1" class="fn">as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.pointer.html">*const Self</a></h4></section></summary><div class="docblock"><p>Returns a raw bit-slice pointer to the region.</p>
<p>The caller must ensure that the slice outlives the pointer this function
returns, or else it will end up pointing to garbage.</p>
<p>The caller must also ensure that the memory the pointer
(non-transitively) points to is only written to if <code>T</code> allows shared
mutation, using this pointer or any pointer derived from it. If you need
to mutate the contents of the slice, use <a href="#method.as_mut_ptr"><code>as_mut_ptr</code></a>.</p>
<p>Modifying the container (such as <code>BitVec</code>) referenced by this slice may
cause its buffer to be reällocated, which would also make any pointers
to it invalid.</p>
<h5 id="original-47"><a class="doc-anchor" href="#original-47">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_ptr"><code>slice::as_ptr</code></a></p>
<h5 id="api-differences-8"><a class="doc-anchor" href="#api-differences-8">§</a>API Differences</h5>
<p>This returns <code>*const BitSlice</code>, which is the equivalent of <code>*const [T]</code>
instead of <code>*const T</code>. The pointer encoding used requires more than one
CPU word of space to address a single bit, so there is no advantage to
removing the length information from the encoded pointer value.</p>
<h5 id="notes"><a class="doc-anchor" href="#notes">§</a>Notes</h5>
<p>You <strong>cannot</strong> use any of the methods in the <code>pointer</code> fundamental type
or the <code>core::ptr</code> module on the <code>*_ BitSlice</code> type. This pointer
retains the <code>bitvec</code>-specific value encoding, and is incomprehensible by
the Rust standard library.</p>
<p>The only thing you can do with this pointer is dereference it.</p>
<h5 id="examples-55"><a class="doc-anchor" href="#examples-55">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let </span>bits_ptr = bits.as_ptr();

<span class="kw">for </span>i <span class="kw">in </span><span class="number">0 </span>.. bits.len() {
  <span class="macro">assert_eq!</span>(bits[i], <span class="kw">unsafe </span>{
    (<span class="kw-2">&amp;*</span>bits_ptr)[i]
  });
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut_ptr-1" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#602-604">source</a><h4 class="code-header">pub fn <a href="#method.as_mut_ptr-1" class="fn">as_mut_ptr</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.pointer.html">*mut Self</a></h4></section></summary><div class="docblock"><p>Returns an unsafe mutable bit-slice pointer to the region.</p>
<p>The caller must ensure that the slice outlives the pointer this function
returns, or else it will end up pointing to garbage.</p>
<p>Modifying the container (such as <code>BitVec</code>) referenced by this slice may
cause its buffer to be reällocated, which would also make any pointers
to it invalid.</p>
<h5 id="original-48"><a class="doc-anchor" href="#original-48">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_mut_ptr"><code>slice::as_mut_ptr</code></a></p>
<h5 id="api-differences-9"><a class="doc-anchor" href="#api-differences-9">§</a>API Differences</h5>
<p>This returns <code>*mut BitSlice</code>, which is the equivalont of <code>*mut [T]</code>
instead of <code>*mut T</code>. The pointer encoding used requires more than one
CPU word of space to address a single bit, so there is no advantage to
removing the length information from the encoded pointer value.</p>
<h5 id="notes-1"><a class="doc-anchor" href="#notes-1">§</a>Notes</h5>
<p>You <strong>cannot</strong> use any of the methods in the <code>pointer</code> fundamental type
or the <code>core::ptr</code> module on the <code>*_ BitSlice</code> type. This pointer
retains the <code>bitvec</code>-specific value encoding, and is incomprehensible by
the Rust standard library.</p>
<h5 id="examples-56"><a class="doc-anchor" href="#examples-56">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>Lsb0, u8; <span class="number">0</span>; <span class="number">8</span>];
<span class="kw">let </span>bits_ptr = bits.as_mut_ptr();

<span class="kw">for </span>i <span class="kw">in </span><span class="number">0 </span>.. bits.len() {
  <span class="kw">unsafe </span>{ <span class="kw-2">&amp;mut *</span>bits_ptr }.set(i, i % <span class="number">3 </span>== <span class="number">0</span>);
}
<span class="macro">assert_eq!</span>(bits.as_slice()[<span class="number">0</span>], <span class="number">0b0100_1001</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.swap" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#631-638">source</a><h4 class="code-header">pub fn <a href="#method.swap" class="fn">swap</a>(&amp;mut self, a: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>, b: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Swaps two bits in the slice.</p>
<h5 id="original-49"><a class="doc-anchor" href="#original-49">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.swap"><code>slice::swap</code></a></p>
<h5 id="arguments"><a class="doc-anchor" href="#arguments">§</a>Arguments</h5>
<ul>
<li><code>a</code>: The index of the first bit</li>
<li><code>b</code>: The index of the second bit</li>
</ul>
<h5 id="panics-12"><a class="doc-anchor" href="#panics-12">§</a>Panics</h5>
<p>Panics if <code>a</code> or <code>b</code> are out of bounds.</p>
<h5 id="examples-57"><a class="doc-anchor" href="#examples-57">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">1</span>];
bits.swap(<span class="number">0</span>, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reverse" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#657-687">source</a><h4 class="code-header">pub fn <a href="#method.reverse" class="fn">reverse</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Reverses the order of bits in the slice, in place.</p>
<h5 id="original-50"><a class="doc-anchor" href="#original-50">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.reverse"><code>slice::reverse</code></a></p>
<h5 id="examples-58"><a class="doc-anchor" href="#examples-58">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">0b1_1001100u8</span>;
<span class="kw">let </span>bits = data.view_bits_mut::&lt;Msb0&gt;();
bits[<span class="number">1 </span>..].reverse();
<span class="macro">assert_eq!</span>(data, <span class="number">0b1_0011001</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iter" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#709-711">source</a><h4 class="code-header">pub fn <a href="#method.iter" class="fn">iter</a>(&amp;self) -&gt; <a class="struct" href="../slice/struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'_, O, T&gt; <a href="#" class="tooltip" data-notable-ty="Iter&lt;&#39;_, O, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the slice.</p>
<h5 id="original-51"><a class="doc-anchor" href="#original-51">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.iter"><code>slice::iter</code></a></p>
<h5 id="examples-59"><a class="doc-anchor" href="#examples-59">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iterator = bits.iter();

<span class="macro">assert_eq!</span>(iterator.next(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">false</span>));
<span class="macro">assert_eq!</span>(iterator.next(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>));
<span class="macro">assert_eq!</span>(iterator.nth(<span class="number">5</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>));
<span class="macro">assert_eq!</span>(iterator.next(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iter_mut" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#731-733">source</a><h4 class="code-header">pub fn <a href="#method.iter_mut" class="fn">iter_mut</a>(&amp;mut self) -&gt; <a class="struct" href="../slice/struct.IterMut.html" title="struct bitvec::slice::IterMut">IterMut</a>&lt;'_, O, T&gt; <a href="#" class="tooltip" data-notable-ty="IterMut&lt;&#39;_, O, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator that allows modifying each bit.</p>
<h5 id="original-52"><a class="doc-anchor" href="#original-52">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#Method.iter_mut"><code>slice::iter_mut</code></a></p>
<h5 id="examples-60"><a class="doc-anchor" href="#examples-60">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>Msb0, u8; <span class="number">0</span>; <span class="number">8</span>];
<span class="kw">for </span>(idx, <span class="kw-2">mut </span>elem) <span class="kw">in </span>bits.iter_mut().enumerate() {
  <span class="kw-2">*</span>elem = idx % <span class="number">3 </span>== <span class="number">0</span>;
}
<span class="macro">assert_eq!</span>(bits.as_slice()[<span class="number">0</span>], <span class="number">0b100_100_10</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.windows" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#771-774">source</a><h4 class="code-header">pub fn <a href="#method.windows" class="fn">windows</a>(&amp;self, size: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a>&lt;'_, O, T&gt; <a href="#" class="tooltip" data-notable-ty="Windows&lt;&#39;_, O, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over all contiguous windows of length <code>size</code>. The
windows overlap. If the slice is shorter than <code>size</code>, the iterator
returns no values.</p>
<h5 id="original-53"><a class="doc-anchor" href="#original-53">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.windows"><code>slice::windows</code></a></p>
<h5 id="panics-13"><a class="doc-anchor" href="#panics-13">§</a>Panics</h5>
<p>Panics if <code>size</code> is 0.</p>
<h5 id="examples-61"><a class="doc-anchor" href="#examples-61">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.windows(<span class="number">6</span>);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="kw-2">&amp;</span>bits[.. <span class="number">6</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="kw-2">&amp;</span>bits[<span class="number">1 </span>.. <span class="number">7</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="kw-2">&amp;</span>bits[<span class="number">2 </span>..]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
<p>If the slice is shorter than <code>size</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = BitSlice::&lt;LocalBits, usize&gt;::empty();
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.windows(<span class="number">1</span>);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.chunks" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#812-815">source</a><h4 class="code-header">pub fn <a href="#method.chunks" class="fn">chunks</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a>&lt;'_, O, T&gt; <a href="#" class="tooltip" data-notable-ty="Chunks&lt;&#39;_, O, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the beginning of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not
divide the length of the slice, then the last chunk will not have length
<code>chunk_size</code>.</p>
<p>See <a href="#method.chunks_exact"><code>chunks_exact</code></a> for a variant of this iterator that returns chunks
of always exactly <code>chunk_size</code> bits, and <a href="#method.rchunks"><code>rchunks</code></a> for the same
iterator but starting at the end of the slice.</p>
<h5 id="original-54"><a class="doc-anchor" href="#original-54">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.chunks"><code>slice::chunks</code></a></p>
<h5 id="panics-14"><a class="doc-anchor" href="#panics-14">§</a>Panics</h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-62"><a class="doc-anchor" href="#examples-62">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.chunks(<span class="number">3</span>);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="kw-2">&amp;</span>bits[.. <span class="number">3</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="kw-2">&amp;</span>bits[<span class="number">3 </span>.. <span class="number">6</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="kw-2">&amp;</span>bits[<span class="number">6 </span>..]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.chunks_mut" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#851-854">source</a><h4 class="code-header">pub fn <a href="#method.chunks_mut" class="fn">chunks_mut</a>(&amp;mut self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a>&lt;'_, O, T&gt; <a href="#" class="tooltip" data-notable-ty="ChunksMut&lt;&#39;_, O, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the beginning of the slice.</p>
<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does
not divide the length of the slice, then the last chunk will not have
length <code>chunk_size</code>.</p>
<p>See <a href="#method.chunks_exact_mut"><code>chunks_exact_mut</code></a> for a variant of this iterator that returns
chunks of always exactly <code>chunk_size</code> bits, and <a href="#method.rchunks_mut"><code>rchunks_mut</code></a> for the
same iterator but starting at the end of the slice.</p>
<h5 id="original-55"><a class="doc-anchor" href="#original-55">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_mut"><code>slice::chunks_mut</code></a></p>
<h5 id="panics-15"><a class="doc-anchor" href="#panics-15">§</a>Panics</h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-63"><a class="doc-anchor" href="#examples-63">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>Lsb0, u8; <span class="number">0</span>; <span class="number">8</span>];
<span class="kw">for </span>(idx, chunk) <span class="kw">in </span>bits.chunks_mut(<span class="number">3</span>).enumerate() {
  chunk.set(<span class="number">2 </span>- idx, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(bits.as_slice()[<span class="number">0</span>], <span class="number">0b01_010_100</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.chunks_exact" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#896-899">source</a><h4 class="code-header">pub fn <a href="#method.chunks_exact" class="fn">chunks_exact</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a>&lt;'_, O, T&gt; <a href="#" class="tooltip" data-notable-ty="ChunksExact&lt;&#39;_, O, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the beginning of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not
divide the length of the slice, then the last up to <code>chunk_size-1</code> bits
will be omitted and can be retrieved from the <code>remainder</code> function of
the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> bits, the compiler may
optimize the resulting code better than in the case of <a href="#method.chunks"><code>chunks</code></a>.</p>
<p>See <a href="#method.chunks"><code>chunks</code></a> for a variant of this iterator that also returns the
remainder as a smaller chunk, and <a href="#method.rchunks_exact"><code>rchunks_exact</code></a> for the same
iterator but starting at the end of the slice.</p>
<h5 id="original-56"><a class="doc-anchor" href="#original-56">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_exact"><code>slice::chunks_exact</code></a></p>
<h5 id="panics-16"><a class="doc-anchor" href="#panics-16">§</a>Panics</h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-64"><a class="doc-anchor" href="#examples-64">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.chunks_exact(<span class="number">3</span>);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="kw-2">&amp;</span>bits[.. <span class="number">3</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="kw-2">&amp;</span>bits[<span class="number">3 </span>.. <span class="number">6</span>]);
<span class="macro">assert!</span>(iter.next().is_none());
<span class="macro">assert_eq!</span>(iter.remainder(), <span class="kw-2">&amp;</span>bits[<span class="number">6 </span>..]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.chunks_exact_mut" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#939-945">source</a><h4 class="code-header">pub fn <a href="#method.chunks_exact_mut" class="fn">chunks_exact_mut</a>(
    &amp;mut self,
    chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>,
) -&gt; <a class="struct" href="../slice/struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a>&lt;'_, O, T&gt; <a href="#" class="tooltip" data-notable-ty="ChunksExactMut&lt;&#39;_, O, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the beginning of the slice.</p>
<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does
not divide the beginning length of the slice, then the last up to
<code>chunk_size-1</code> bits will be omitted and can be retrieved from the
<code>into_remainder</code> function of the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> bits, the compiler may
optimize the resulting code better than in the case of <a href="#method.chunks_mut"><code>chunks_mut</code></a>.</p>
<p>See <a href="#method.chunks_mut"><code>chunks_mut</code></a> for a variant of this iterator that also returns the
remainder as a smaller chunk, and <a href="#method.rchunks_exact_mut"><code>rchunks_exact_mut</code></a> for the same
iterator but starting at the end of the slice.</p>
<h5 id="original-57"><a class="doc-anchor" href="#original-57">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_exact_mut"><code>slice::chunks_exact_mut</code></a></p>
<h5 id="panics-17"><a class="doc-anchor" href="#panics-17">§</a>Panics</h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-65"><a class="doc-anchor" href="#examples-65">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>Lsb0, u8; <span class="number">0</span>; <span class="number">8</span>];
<span class="kw">for </span>(idx, chunk) <span class="kw">in </span>bits.chunks_exact_mut(<span class="number">3</span>).enumerate() {
  chunk.set(idx, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(bits.as_slice()[<span class="number">0</span>], <span class="number">0b00_010_001</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rchunks" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#983-986">source</a><h4 class="code-header">pub fn <a href="#method.rchunks" class="fn">rchunks</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a>&lt;'_, O, T&gt; <a href="#" class="tooltip" data-notable-ty="RChunks&lt;&#39;_, O, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the end of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not
divide the length of the slice, then the last chunk will not have length
<code>chunk_size</code>.</p>
<p>See <a href="#method.rchunks_exact"><code>rchunks_exact</code></a> for a variant of this iterator that returns chunks
of always exactly <code>chunk_size</code> bits, and <a href="#method.chunks"><code>chunks</code></a> for the same
iterator but starting at the beginning of the slice.</p>
<h5 id="original-58"><a class="doc-anchor" href="#original-58">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks"><code>slice::rchunks</code></a></p>
<h5 id="panics-18"><a class="doc-anchor" href="#panics-18">§</a>Panics</h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-66"><a class="doc-anchor" href="#examples-66">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.rchunks(<span class="number">3</span>);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="kw-2">&amp;</span>bits[<span class="number">5 </span>..]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="kw-2">&amp;</span>bits[<span class="number">2 </span>.. <span class="number">5</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="kw-2">&amp;</span>bits[.. <span class="number">2</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rchunks_mut" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#1022-1025">source</a><h4 class="code-header">pub fn <a href="#method.rchunks_mut" class="fn">rchunks_mut</a>(&amp;mut self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a>&lt;'_, O, T&gt; <a href="#" class="tooltip" data-notable-ty="RChunksMut&lt;&#39;_, O, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the end of the slice.</p>
<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does
not divide the length of the slice, then the last chunk will not have
length <code>chunk_size</code>.</p>
<p>See <a href="#method.rchunks_exact_mut"><code>rchunks_exact_mut</code></a> for a variant of this iterator that returns
chunks of always exactly <code>chunk_size</code> bits, and <a href="#method.chunks_mut"><code>chunks_mut</code></a> for the
same iterator but starting at the beginning of the slice.</p>
<h5 id="original-59"><a class="doc-anchor" href="#original-59">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks_mut"><code>slice::rchunks_mut</code></a></p>
<h5 id="panics-19"><a class="doc-anchor" href="#panics-19">§</a>Panics</h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-67"><a class="doc-anchor" href="#examples-67">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>Lsb0, u8; <span class="number">0</span>; <span class="number">8</span>];
<span class="kw">for </span>(idx, chunk) <span class="kw">in </span>bits.rchunks_mut(<span class="number">3</span>).enumerate() {
  chunk.set(<span class="number">2 </span>- idx, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(bits.as_slice()[<span class="number">0</span>], <span class="number">0b100_010_01</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rchunks_exact" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#1068-1071">source</a><h4 class="code-header">pub fn <a href="#method.rchunks_exact" class="fn">rchunks_exact</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a>&lt;'_, O, T&gt; <a href="#" class="tooltip" data-notable-ty="RChunksExact&lt;&#39;_, O, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the end of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not
divide the length of the slice, then the last up to <code>chunk_size-1</code> bits
will be omitted and can be retrieved from the <code>remainder</code> function of
the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> bits, the compiler can
often optimize the resulting code better than in the case of <a href="#method.chunks"><code>chunks</code></a>.</p>
<p>See <a href="#method.rchunks"><code>rchunks</code></a> for a variant of this iterator that also returns the
remainder as a smaller chunk, and <a href="#method.chunks_exact"><code>chunks_exact</code></a> for the same iterator
but starting at the beginning of the slice.</p>
<h5 id="original-60"><a class="doc-anchor" href="#original-60">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks_exact"><code>slice::rchunks_exact</code></a></p>
<h5 id="panics-20"><a class="doc-anchor" href="#panics-20">§</a>Panics</h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-68"><a class="doc-anchor" href="#examples-68">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.rchunks_exact(<span class="number">3</span>);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="kw-2">&amp;</span>bits[<span class="number">5 </span>..]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="kw-2">&amp;</span>bits[<span class="number">2 </span>.. <span class="number">5</span>]);
<span class="macro">assert!</span>(iter.next().is_none());
<span class="macro">assert_eq!</span>(iter.remainder(), <span class="kw-2">&amp;</span>bits[.. <span class="number">2</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rchunks_exact_mut" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#1109-1115">source</a><h4 class="code-header">pub fn <a href="#method.rchunks_exact_mut" class="fn">rchunks_exact_mut</a>(
    &amp;mut self,
    chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>,
) -&gt; <a class="struct" href="../slice/struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a>&lt;'_, O, T&gt; <a href="#" class="tooltip" data-notable-ty="RChunksExactMut&lt;&#39;_, O, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the end of the slice.</p>
<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does
not divide the length of the slice, then the last up to <code>chunk_size-1</code>
bits will be omitted and can be retrieved from the <code>into_remainder</code>
function of the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> bits, the compiler can
often optimize the resulting code better than in the case of
<a href="#method.chunks_mut"><code>chunks_mut</code></a>.</p>
<p>See <a href="#method.rchunks_mut"><code>rchunks_mut</code></a> for a variant of this iterator that also returns the
remainder as a smaller chunk, and <a href="#method.chunks_exact_mut"><code>chunks_exact_mut</code></a> for the same
iterator but starting at the beginning of the slice.</p>
<h5 id="panics-21"><a class="doc-anchor" href="#panics-21">§</a>Panics</h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-69"><a class="doc-anchor" href="#examples-69">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>Lsb0, u8; <span class="number">0</span>; <span class="number">8</span>];
<span class="kw">for </span>(idx, chunk) <span class="kw">in </span>bits.rchunks_exact_mut(<span class="number">3</span>).enumerate() {
  chunk.set(idx, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(bits.as_slice()[<span class="number">0</span>], <span class="number">0b001_010_00</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_at" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#1159-1163">source</a><h4 class="code-header">pub fn <a href="#method.split_at" class="fn">split_at</a>(&amp;self, mid: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Self</a>, <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class="docblock"><p>Divides one slice into two at an index.</p>
<p>The first will contain all indices from <code>[0, mid)</code> (excluding the index
<code>mid</code> itself) and the second will contain all indices from <code>[mid, len)</code>
(excluding the index <code>len</code> itself).</p>
<h5 id="original-61"><a class="doc-anchor" href="#original-61">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_at"><code>slice::split_at</code></a></p>
<h5 id="panics-22"><a class="doc-anchor" href="#panics-22">§</a>Panics</h5>
<p>Panics if <code>mid &gt; len</code>.</p>
<h5 id="behavior-2"><a class="doc-anchor" href="#behavior-2">§</a>Behavior</h5>
<p>When <code>mid</code> is <code>0</code> or <code>self.len()</code>, then the left or right return values,
respectively, are empty slices. Empty slice references produced by this
method are specified to have the address information you would expect:
a left empty slice has the same base address and start bit as <code>self</code>,
and a right empty slice will have its address raised by <code>self.len()</code>.</p>
<h5 id="examples-70"><a class="doc-anchor" href="#examples-70">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];

<span class="kw">let </span>(left, right) = bits.split_at(<span class="number">0</span>);
<span class="macro">assert!</span>(left.is_empty());
<span class="macro">assert_eq!</span>(right, bits);

<span class="kw">let </span>(left, right) = bits.split_at(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(left, <span class="kw-2">&amp;</span>bits[.. <span class="number">2</span>]);
<span class="macro">assert_eq!</span>(right, <span class="kw-2">&amp;</span>bits[<span class="number">2 </span>..]);

<span class="kw">let </span>(left, right) = bits.split_at(<span class="number">8</span>);
<span class="macro">assert_eq!</span>(left, bits);
<span class="macro">assert!</span>(right.is_empty());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_at_mut" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#1219-1226">source</a><h4 class="code-header">pub fn <a href="#method.split_at_mut" class="fn">split_at_mut</a>(
    &amp;mut self,
    mid: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>,
) -&gt; (&amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;, &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;)</h4></section></summary><div class="docblock"><p>Divides one mutable slice into two at an index.</p>
<p>The first will contain all indices from <code>[0, mid)</code> (excluding the index
<code>mid</code> itself) and the second will contain all indices from <code>[mid, len)</code>
(excluding the index <code>len</code> itself).</p>
<h5 id="original-62"><a class="doc-anchor" href="#original-62">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.html#method.split_at_mut"><code>slice::split_at_mut</code></a></p>
<h5 id="api-differences-10"><a class="doc-anchor" href="#api-differences-10">§</a>API Differences</h5>
<p>Because the partition point <code>mid</code> is permitted to occur in the interior
of a memory element <code>T</code>, this method is required to mark the returned
slices as being to aliased memory. This marking ensures that writes to
the covered memory use the appropriate synchronization behavior of your
build to avoid data races – by default, this makes all writes atomic; on
builds with the <code>atomic</code> feature disabled, this uses <code>Cell</code>s and
forbids the produced subslices from leaving the current thread.</p>
<p>See the <a href="../store/trait.BitStore.html"><code>BitStore</code></a> documentation for more information.</p>
<h5 id="panics-23"><a class="doc-anchor" href="#panics-23">§</a>Panics</h5>
<p>Panics if <code>mid &gt; len</code>.</p>
<h5 id="behavior-3"><a class="doc-anchor" href="#behavior-3">§</a>Behavior</h5>
<p>When <code>mid</code> is <code>0</code> or <code>self.len()</code>, then the left or right return values,
respectively, are empty slices. Empty slice references produced by this
method are specified to have the address information you would expect:
a left empty slice has the same base address and start bit as <code>self</code>,
and a right empty slice will have its address raised by <code>self.len()</code>.</p>
<h5 id="examples-71"><a class="doc-anchor" href="#examples-71">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>Msb0, u8; <span class="number">0</span>; <span class="number">8</span>];
<span class="comment">// scoped to restrict the lifetime of the borrows
</span>{
  <span class="kw">let </span>(left, right) = bits.split_at_mut(<span class="number">3</span>);
  <span class="kw-2">*</span>left.get_mut(<span class="number">1</span>).unwrap() = <span class="bool-val">true</span>;
  <span class="kw-2">*</span>right.get_mut(<span class="number">2</span>).unwrap() = <span class="bool-val">true</span>;
}
<span class="macro">assert_eq!</span>(bits.as_slice()[<span class="number">0</span>], <span class="number">0b010_00100</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#1285-1288">source</a><h4 class="code-header">pub fn <a href="#method.split" class="fn">split</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class="struct" href="../slice/struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'_, O, T, F&gt; <a href="#" class="tooltip" data-notable-ty="Split&lt;&#39;_, O, T, F&gt;">ⓘ</a><div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>.
The matched bit is not contained in the subslices.</p>
<h5 id="original-63"><a class="doc-anchor" href="#original-63">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split"><code>slice::split</code></a></p>
<h5 id="api-differences-11"><a class="doc-anchor" href="#api-differences-11">§</a>API Differences</h5>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h5 id="examples-72"><a class="doc-anchor" href="#examples-72">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.split(|_pos, bit| <span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="kw-2">&amp;</span>bits[.. <span class="number">1</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="kw-2">&amp;</span>bits[<span class="number">2 </span>.. <span class="number">4</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="kw-2">&amp;</span>bits[<span class="number">5 </span>..]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
<p>If the first bit is matched, an empty slice will be the first item
returned by the iterator. Similarly, if the last element in the slice is
matched, an empty slice will be the last item returned by the iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.split(|_pos, bit| <span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="kw-2">&amp;</span>bits[.. <span class="number">3</span>]);
<span class="macro">assert!</span>(iter.next().unwrap().is_empty());
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
<p>If two matched bits are directly adjacent, an empty slice will be
present between them:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.split(|pos, bit| <span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="kw-2">&amp;</span>bits[<span class="number">0 </span>.. <span class="number">2</span>]);
<span class="macro">assert!</span>(iter.next().unwrap().is_empty());
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="kw-2">&amp;</span>bits[<span class="number">4 </span>.. <span class="number">8</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_mut" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#1315-1318">source</a><h4 class="code-header">pub fn <a href="#method.split_mut" class="fn">split_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class="struct" href="../slice/struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'_, O, T, F&gt; <a href="#" class="tooltip" data-notable-ty="SplitMut&lt;&#39;_, O, T, F&gt;">ⓘ</a><div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over mutable subslices separated by bits that match
<code>pred</code>. The matched bit is not contained in the subslices.</p>
<h5 id="original-64"><a class="doc-anchor" href="#original-64">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_mut"><code>slice::split_mut</code></a></p>
<h5 id="api-differences-12"><a class="doc-anchor" href="#api-differences-12">§</a>API Differences</h5>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h5 id="examples-73"><a class="doc-anchor" href="#examples-73">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>Msb0, u8; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">for </span>group <span class="kw">in </span>bits.split_mut(|_pos, bit| <span class="kw-2">*</span>bit) {
  <span class="kw-2">*</span>group.get_mut(<span class="number">0</span>).unwrap() = <span class="bool-val">true</span>;
}
<span class="macro">assert_eq!</span>(bits.as_slice()[<span class="number">0</span>], <span class="number">0b101_100_11</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#1363-1366">source</a><h4 class="code-header">pub fn <a href="#method.rsplit" class="fn">rsplit</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class="struct" href="../slice/struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'_, O, T, F&gt; <a href="#" class="tooltip" data-notable-ty="RSplit&lt;&#39;_, O, T, F&gt;">ⓘ</a><div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>,
starting at the end of the slice and working backwards. The matched bit
is not contained in the subslices.</p>
<h5 id="original-65"><a class="doc-anchor" href="#original-65">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rsplit"><code>slice::rsplit</code></a></p>
<h5 id="api-differences-13"><a class="doc-anchor" href="#api-differences-13">§</a>API Differences</h5>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h5 id="examples-74"><a class="doc-anchor" href="#examples-74">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>Msb0, u8; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.rsplit(|_pos, bit| <span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="kw-2">&amp;</span>bits[<span class="number">4 </span>..]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="kw-2">&amp;</span>bits[.. <span class="number">3</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
<p>As with <code>split()</code>, if the first or last bit is matched, an empty slice
will be the first (or last) item returned by the iterator.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>Msb0, u8; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.rsplit(|_pos, bit| <span class="kw-2">*</span>bit);

<span class="macro">assert!</span>(iter.next().unwrap().is_empty());
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="kw-2">&amp;</span>bits[<span class="number">4 </span>.. <span class="number">7</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="kw-2">&amp;</span>bits[<span class="number">1 </span>.. <span class="number">3</span>]);
<span class="macro">assert!</span>(iter.next().unwrap().is_empty());
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit_mut" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#1394-1397">source</a><h4 class="code-header">pub fn <a href="#method.rsplit_mut" class="fn">rsplit_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class="struct" href="../slice/struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'_, O, T, F&gt; <a href="#" class="tooltip" data-notable-ty="RSplitMut&lt;&#39;_, O, T, F&gt;">ⓘ</a><div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over mutable subslices separated by bits that match
<code>pred</code>, starting at the end of the slice and working backwards. The
matched bit is not contained in the subslices.</p>
<h5 id="original-66"><a class="doc-anchor" href="#original-66">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rsplit_mut"><code>slice::rsplit_mut</code></a></p>
<h5 id="api-differences-14"><a class="doc-anchor" href="#api-differences-14">§</a>API Differences</h5>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h5 id="examples-75"><a class="doc-anchor" href="#examples-75">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>Msb0, u8; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">for </span>group <span class="kw">in </span>bits.rsplit_mut(|_pos, bit| <span class="kw-2">*</span>bit) {
  <span class="kw-2">*</span>group.get_mut(<span class="number">0</span>).unwrap() = <span class="bool-val">true</span>;
}
<span class="macro">assert_eq!</span>(bits.as_slice()[<span class="number">0</span>], <span class="number">0b101_100_11</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.splitn" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#1432-1435">source</a><h4 class="code-header">pub fn <a href="#method.splitn" class="fn">splitn</a>&lt;F&gt;(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="../slice/struct.SplitN.html" title="struct bitvec::slice::SplitN">SplitN</a>&lt;'_, O, T, F&gt; <a href="#" class="tooltip" data-notable-ty="SplitN&lt;&#39;_, O, T, F&gt;">ⓘ</a><div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>,
limited to returning at most <code>n</code> items. The matched bit is not contained
in the subslices.</p>
<p>The last item returned, if any, will contain the remainder of the slice.</p>
<h5 id="original-67"><a class="doc-anchor" href="#original-67">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.splitn"><code>slice::splitn</code></a></p>
<h5 id="api-differences-15"><a class="doc-anchor" href="#api-differences-15">§</a>API Differences</h5>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h5 id="examples-76"><a class="doc-anchor" href="#examples-76">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">for </span>group <span class="kw">in </span>bits.splitn(<span class="number">2</span>, |pos, _bit| pos % <span class="number">3 </span>== <span class="number">2</span>) {
  <span class="macro">println!</span>(<span class="string">"{}"</span>, group.len());
}
<span class="comment">//  2
//  5</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.splitn_mut" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#1465-1468">source</a><h4 class="code-header">pub fn <a href="#method.splitn_mut" class="fn">splitn_mut</a>&lt;F&gt;(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="../slice/struct.SplitNMut.html" title="struct bitvec::slice::SplitNMut">SplitNMut</a>&lt;'_, O, T, F&gt; <a href="#" class="tooltip" data-notable-ty="SplitNMut&lt;&#39;_, O, T, F&gt;">ⓘ</a><div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>,
limited to returning at most <code>n</code> items. The matched element is not
contained in the subslices.</p>
<p>The last item returned, if any, will contain the remainder of the slice.</p>
<h5 id="original-68"><a class="doc-anchor" href="#original-68">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.splitn_mut"><code>slice::splitn_mut</code></a></p>
<h5 id="api-differences-16"><a class="doc-anchor" href="#api-differences-16">§</a>API Differences</h5>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h5 id="examples-77"><a class="doc-anchor" href="#examples-77">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>Msb0, u8; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">for </span>group <span class="kw">in </span>bits.splitn_mut(<span class="number">2</span>, |_pos, bit| <span class="kw-2">*</span>bit) {
  <span class="kw-2">*</span>group.get_mut(<span class="number">0</span>).unwrap() = <span class="bool-val">true</span>;
}
<span class="macro">assert_eq!</span>(bits.as_slice()[<span class="number">0</span>], <span class="number">0b101_100_10</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplitn" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#1504-1507">source</a><h4 class="code-header">pub fn <a href="#method.rsplitn" class="fn">rsplitn</a>&lt;F&gt;(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="../slice/struct.RSplitN.html" title="struct bitvec::slice::RSplitN">RSplitN</a>&lt;'_, O, T, F&gt; <a href="#" class="tooltip" data-notable-ty="RSplitN&lt;&#39;_, O, T, F&gt;">ⓘ</a><div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>
limited to returining at most <code>n</code> items. This starts at the end of the
slice and works backwards. The matched bit is not contained in the
subslices.</p>
<p>The last item returned, if any, will contain the remainder of the slice.</p>
<h5 id="original-69"><a class="doc-anchor" href="#original-69">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rsplitn"><code>slice::rsplitn</code></a></p>
<h5 id="api-differences-17"><a class="doc-anchor" href="#api-differences-17">§</a>API Differences</h5>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h5 id="examples-78"><a class="doc-anchor" href="#examples-78">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[Msb0, u8; <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">for </span>group <span class="kw">in </span>bits.rsplitn(<span class="number">2</span>, |pos, _bit| pos % <span class="number">3 </span>== <span class="number">2</span>) {
  <span class="macro">println!</span>(<span class="string">"{}"</span>, group.len());
}
<span class="comment">//  2
//  5</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplitn_mut" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#1538-1541">source</a><h4 class="code-header">pub fn <a href="#method.rsplitn_mut" class="fn">rsplitn_mut</a>&lt;F&gt;(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="../slice/struct.RSplitNMut.html" title="struct bitvec::slice::RSplitNMut">RSplitNMut</a>&lt;'_, O, T, F&gt; <a href="#" class="tooltip" data-notable-ty="RSplitNMut&lt;&#39;_, O, T, F&gt;">ⓘ</a><div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>
limited to returning at most <code>n</code> items. This starts at the end of the
slice and works backwards. The matched bit is not contained in the
subslices.</p>
<p>The last item returned, if any, will contain the remainder of the slice.</p>
<h5 id="original-70"><a class="doc-anchor" href="#original-70">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rsplitn_mut"><code>slice::rsplitn_mut</code></a></p>
<h5 id="api-differences-18"><a class="doc-anchor" href="#api-differences-18">§</a>API Differences</h5>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h5 id="examples-79"><a class="doc-anchor" href="#examples-79">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>Msb0, u8; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">for </span>group <span class="kw">in </span>bits.rsplitn_mut(<span class="number">2</span>, |_pos, bit| <span class="kw-2">*</span>bit) {
  <span class="kw-2">*</span>group.get_mut(<span class="number">0</span>).unwrap() = <span class="bool-val">true</span>;
}
<span class="macro">assert_eq!</span>(bits.as_slice()[<span class="number">0</span>], <span class="number">0b101_000_11</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.contains" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#1578-1588">source</a><h4 class="code-header">pub fn <a href="#method.contains" class="fn">contains</a>&lt;O2, T2&gt;(&amp;self, x: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a><div class="where">where
    O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the slice contains a subslice that matches the given
span.</p>
<h5 id="original-71"><a class="doc-anchor" href="#original-71">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.contains"><code>slice::contains</code></a></p>
<h5 id="api-differences-19"><a class="doc-anchor" href="#api-differences-19">§</a>API Differences</h5>
<p>This searches for a matching subslice (allowing different type
parameters) rather than for a specific bit. Searching for a contained
element with a given value is not as useful on a collection of <code>bool</code>.</p>
<p>Furthermore, <code>BitSlice</code> defines <a href="#method.any"><code>any</code></a> and <a href="#method.not_all"><code>not_all</code></a>, which are
optimized searchers for any <code>true</code> or <code>false</code> bit, respectively, in a
sequence.</p>
<h5 id="examples-80"><a class="doc-anchor" href="#examples-80">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>data = <span class="number">0b0101_1010u8</span>;
<span class="kw">let </span>bits_msb = data.view_bits::&lt;Msb0&gt;();
<span class="kw">let </span>bits_lsb = data.view_bits::&lt;Lsb0&gt;();
<span class="macro">assert!</span>(bits_msb.contains(<span class="kw-2">&amp;</span>bits_lsb[<span class="number">1 </span>.. <span class="number">5</span>]));</code></pre></div>
<p>This example uses a palindrome pattern to demonstrate that the slice
being searched for does not need to have the same type parameters as the
slice being searched.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.starts_with" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#1620-1627">source</a><h4 class="code-header">pub fn <a href="#method.starts_with" class="fn">starts_with</a>&lt;O2, T2&gt;(&amp;self, needle: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a><div class="where">where
    O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if <code>needle</code> is a prefix of the slice.</p>
<h5 id="original-72"><a class="doc-anchor" href="#original-72">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.starts_with"><code>slice::starts_with</code></a></p>
<h5 id="examples-81"><a class="doc-anchor" href="#examples-81">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>data = <span class="number">0b0100_1011u8</span>;
<span class="kw">let </span>haystack = data.view_bits::&lt;Msb0&gt;();
<span class="kw">let </span>needle = <span class="kw-2">&amp;</span>data.view_bits::&lt;Lsb0&gt;()[<span class="number">2 </span>.. <span class="number">5</span>];

<span class="macro">assert!</span>(haystack.starts_with(<span class="kw-2">&amp;</span>needle[.. <span class="number">2</span>]));
<span class="macro">assert!</span>(haystack.starts_with(needle));
<span class="macro">assert!</span>(!haystack.starts_with(<span class="kw-2">&amp;</span>haystack[<span class="number">2 </span>.. <span class="number">4</span>]));</code></pre></div>
<p>Always returns <code>true</code> if <code>needle</code> is an empty slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>empty = BitSlice::&lt;LocalBits, usize&gt;::empty();
<span class="macro">assert!</span>(<span class="number">0u8</span>.view_bits::&lt;LocalBits&gt;().starts_with(empty));
<span class="macro">assert!</span>(empty.starts_with(empty));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ends_with" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#1659-1667">source</a><h4 class="code-header">pub fn <a href="#method.ends_with" class="fn">ends_with</a>&lt;O2, T2&gt;(&amp;self, needle: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a><div class="where">where
    O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if <code>needle</code> is a suffix of the slice.</p>
<h5 id="original-73"><a class="doc-anchor" href="#original-73">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.ends_with"><code>slice::ends_with</code></a></p>
<h5 id="examples-82"><a class="doc-anchor" href="#examples-82">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>data = <span class="number">0b0100_1011u8</span>;
<span class="kw">let </span>haystack = data.view_bits::&lt;Lsb0&gt;();
<span class="kw">let </span>needle = <span class="kw-2">&amp;</span>data.view_bits::&lt;Msb0&gt;()[<span class="number">3 </span>.. <span class="number">6</span>];

<span class="macro">assert!</span>(haystack.ends_with(<span class="kw-2">&amp;</span>needle[<span class="number">1 </span>..]));
<span class="macro">assert!</span>(haystack.ends_with(needle));
<span class="macro">assert!</span>(!haystack.ends_with(<span class="kw-2">&amp;</span>haystack[<span class="number">2 </span>.. <span class="number">4</span>]));</code></pre></div>
<p>Always returns <code>true</code> if <code>needle</code> is an empty slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>empty = BitSlice::&lt;LocalBits, usize&gt;::empty();
<span class="macro">assert!</span>(<span class="number">0u8</span>.view_bits::&lt;LocalBits&gt;().ends_with(empty));
<span class="macro">assert!</span>(empty.ends_with(empty));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rotate_left" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#1710-1743">source</a><h4 class="code-header">pub fn <a href="#method.rotate_left" class="fn">rotate_left</a>(&amp;mut self, by: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Rotates the slice in-place such that the first <code>by</code> bits of the slice
move to the end while the last <code>self.len() - by</code> bits move to the front.
After calling <code>rotate_left</code>, the bit previously at index <code>by</code> will
become the first bit in the slice.</p>
<h5 id="original-74"><a class="doc-anchor" href="#original-74">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#rotate_left"><code>slice::rotate_left</code></a></p>
<h5 id="panics-24"><a class="doc-anchor" href="#panics-24">§</a>Panics</h5>
<p>This function will panic if <code>by</code> is greater than the length of the
slice. Note that <code>by == self.len()</code> does <em>not</em> panic and is a no-op
rotation.</p>
<h5 id="complexity"><a class="doc-anchor" href="#complexity">§</a>Complexity</h5>
<p>Takes linear (in <code>self.len()</code>) time.</p>
<h5 id="examples-83"><a class="doc-anchor" href="#examples-83">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">0xF0u8</span>;
<span class="kw">let </span>bits = data.view_bits_mut::&lt;Msb0&gt;();
bits.rotate_left(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(data, <span class="number">0xC3</span>);</code></pre></div>
<p>Rotating a subslice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">0xF0u8</span>;
<span class="kw">let </span>bits = data.view_bits_mut::&lt;Msb0&gt;();
bits[<span class="number">1 </span>.. <span class="number">5</span>].rotate_left(<span class="number">1</span>);
<span class="macro">assert_eq!</span>(data, <span class="number">0b1_1101_000</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rotate_right" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#1786-1808">source</a><h4 class="code-header">pub fn <a href="#method.rotate_right" class="fn">rotate_right</a>(&amp;mut self, by: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Rotates the slice in-place such that the first <code>self.len() - by</code> bits of
the slice move to the end while the last <code>by</code> bits move to the front.
After calling <code>rotate_right</code>, the bit previously at index <code>self.len() - by</code> will become the first bit in the slice.</p>
<h5 id="original-75"><a class="doc-anchor" href="#original-75">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#rotate_right"><code>slice::rotate_right</code></a></p>
<h5 id="panics-25"><a class="doc-anchor" href="#panics-25">§</a>Panics</h5>
<p>This function will panic if <code>by</code> is greater than the length of the
slice. Note that <code>by == self.len()</code> does <em>not</em> panic and is a no-op
rotation.</p>
<h5 id="complexity-1"><a class="doc-anchor" href="#complexity-1">§</a>Complexity</h5>
<p>Takes linear (in <code>self.len()</code>) time.</p>
<h5 id="examples-84"><a class="doc-anchor" href="#examples-84">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">0xF0u8</span>;
<span class="kw">let </span>bits = data.view_bits_mut::&lt;Msb0&gt;();
bits.rotate_right(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(data, <span class="number">0x3C</span>);</code></pre></div>
<p>Rotate a subslice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">0xF0u8</span>;
<span class="kw">let </span>bits = data.view_bits_mut::&lt;Msb0&gt;();
bits[<span class="number">1 </span>.. <span class="number">5</span>].rotate_right(<span class="number">1</span>);
<span class="macro">assert_eq!</span>(data, <span class="number">0b1_0111_000</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from_bitslice" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#1886-1902">source</a><h4 class="code-header">pub fn <a href="#method.clone_from_bitslice" class="fn">clone_from_bitslice</a>&lt;O2, T2&gt;(&amp;mut self, src: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;)<div class="where">where
    O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h4></section></summary><div class="docblock"><p>Copies the bits from <code>src</code> into <code>self</code>.</p>
<p>The length of <code>src</code> must be the same as <code>self</code>.</p>
<p>If you are attempting to write an integer value into a <code>BitSlice</code>, see
the <a href="../field/trait.BitField.html#method.store"><code>BitField::store</code></a> trait function.</p>
<h5 id="implementation"><a class="doc-anchor" href="#implementation">§</a>Implementation</h5>
<p>This method is by necessity a bit-by-bit individual walk across both
slices. Benchmarks indicate that where the slices share type parameters,
this is very close in performance to an element-wise <code>memcpy</code>. You
should use this method as the default transfer behavior, and only switch
to [<code>.copy_from_bitslice()</code>] where you know that your performance is an
issue <em>and</em> you can demonstrate that <code>.copy_from_bitslice()</code> is
meaningfully better.</p>
<p>Where <code>self</code> and <code>src</code> are not of the same type parameters, crate
benchmarks show a roughly halved runtime performance.</p>
<h5 id="original-76"><a class="doc-anchor" href="#original-76">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.clone_from_slice"><code>slice::clone_from_slice</code></a></p>
<h5 id="api-differences-20"><a class="doc-anchor" href="#api-differences-20">§</a>API Differences</h5>
<p>This method is renamed, as it takes a bit slice rather than an element
slice.</p>
<h5 id="panics-26"><a class="doc-anchor" href="#panics-26">§</a>Panics</h5>
<p>This function will panic if the two slices have different lengths.</p>
<h5 id="examples-85"><a class="doc-anchor" href="#examples-85">§</a>Examples</h5>
<p>Cloning two bits from a slice into another:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">0u8</span>;
<span class="kw">let </span>bits = data.view_bits_mut::&lt;Msb0&gt;();
<span class="kw">let </span>src = <span class="number">0x0Fu16</span>.view_bits::&lt;Lsb0&gt;();
bits[.. <span class="number">2</span>].clone_from_bitslice(<span class="kw-2">&amp;</span>src[<span class="number">2 </span>.. <span class="number">4</span>]);
<span class="macro">assert_eq!</span>(data, <span class="number">0xC0</span>);</code></pre></div>
<p>Rust enforces that there can only be one mutable reference with no
immutable references to a particular piece of data in a particular
scope. Because of this, attempting to use <code>clone_from_bitslice</code> on a
single slice will result in a compile failure:</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">3u8</span>;
<span class="kw">let </span>bits = data.view_bits_mut::&lt;Msb0&gt;();
bits[.. <span class="number">2</span>].clone_from_bitslice(<span class="kw-2">&amp;</span>bits[<span class="number">6 </span>..]);</code></pre></div>
<p>To work around this, we can use <a href="#method.split_at_mut"><code>split_at_mut</code></a> to create two distinct
sub-slices from a slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">3u8</span>;
<span class="kw">let </span>bits = data.view_bits_mut::&lt;Msb0&gt;();
<span class="kw">let </span>(head, tail) = bits.split_at_mut(<span class="number">4</span>);
head.clone_from_bitslice(tail);
<span class="macro">assert_eq!</span>(data, <span class="number">0x33</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.copy_from_bitslice" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#1966-2022">source</a><h4 class="code-header">pub fn <a href="#method.copy_from_bitslice" class="fn">copy_from_bitslice</a>(&amp;mut self, src: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class="docblock"><p>Copies all bits from <code>src</code> into <code>self</code>.</p>
<p>The length of <code>src</code> must be the same as <code>self</code>.</p>
<p>If you are attempting to write an integer value into a <code>BitSlice</code>, see
the <a href="../field/trait.BitField.html#method.store"><code>BitField::store</code></a> trait function.</p>
<h5 id="implementation-1"><a class="doc-anchor" href="#implementation-1">§</a>Implementation</h5>
<p>This method attempts to use <code>memcpy</code> element-wise copy acceleration
where possible. This will only occur when both <code>src</code> and <code>self</code> are
exactly similar: in addition to having the same type parameters and
length, they must begin at the same offset in an element.</p>
<p>Benchmarks do not indicate that <code>memcpy</code> element-wise copy is
significantly faster than <a href="#method.clone_from_bitslice"><code>.clone_from_bitslice()</code></a>’s bit-wise crawl.
This implementation is retained so that you have the ability to observe
performance characteristics on your own targets and choose as
appropriate.</p>
<h5 id="original-77"><a class="doc-anchor" href="#original-77">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.std.html#method.copy_from_slice"><code>slice::copy_from_slice</code></a></p>
<h5 id="api-differences-21"><a class="doc-anchor" href="#api-differences-21">§</a>API Differences</h5>
<p>This method is renamed, as it takes a bit slice rather than an element
slice.</p>
<h5 id="panics-27"><a class="doc-anchor" href="#panics-27">§</a>Panics</h5>
<p>This function will panic if the two slices have different lengths.</p>
<h5 id="examples-86"><a class="doc-anchor" href="#examples-86">§</a>Examples</h5>
<p>Copying two bits from a slice into another:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>dst = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">200</span>];
<span class="kw">let </span>src = <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">200</span>];

<span class="macro">assert!</span>(dst.not_any());
dst.copy_from_bitslice(src);
<span class="macro">assert!</span>(dst.all());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.copy_within" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#2061-2072">source</a><h4 class="code-header">pub fn <a href="#method.copy_within" class="fn">copy_within</a>&lt;R&gt;(&amp;mut self, src: R, dest: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>)<div class="where">where
    R: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Copies bits from one part of the slice to another part of itself.</p>
<p><code>src</code> is the range within <code>self</code> to copy from. <code>dest</code> is the starting
index of the range within <code>self</code> to copy to, which will have the same
length as <code>src</code>. The two ranges may overlap. The ends of the two ranges
must be less than or equal to <code>self.len()</code>.</p>
<h5 id="original-78"><a class="doc-anchor" href="#original-78">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.copy_within"><code>slice::copy_within</code></a></p>
<h5 id="panics-28"><a class="doc-anchor" href="#panics-28">§</a>Panics</h5>
<p>This function will panic if either range exceeds the end of the slice,
or if the end of <code>src</code> is before the start.</p>
<h5 id="examples-87"><a class="doc-anchor" href="#examples-87">§</a>Examples</h5>
<p>Copying four bytes within a slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">0x07u8</span>;
<span class="kw">let </span>bits = data.view_bits_mut::&lt;Msb0&gt;();
bits.copy_within(<span class="number">5 </span>.., <span class="number">0</span>);
<span class="macro">assert_eq!</span>(data, <span class="number">0xE7</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.swap_with_bitslice" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#2109-2124">source</a><h4 class="code-header">pub fn <a href="#method.swap_with_bitslice" class="fn">swap_with_bitslice</a>&lt;O2, T2&gt;(&amp;mut self, other: &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;)<div class="where">where
    O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h4></section></summary><div class="docblock"><p>Swaps all bits in <code>self</code> with those in <code>other</code>.</p>
<p>The length of <code>other</code> must be the same as <code>self</code>.</p>
<h5 id="original-79"><a class="doc-anchor" href="#original-79">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.swap_with_slice"><code>slice::swap_with_slice</code></a></p>
<h5 id="api-differences-22"><a class="doc-anchor" href="#api-differences-22">§</a>API Differences</h5>
<p>This method is renamed, as it takes a bit slice rather than an element
slice.</p>
<h5 id="panics-29"><a class="doc-anchor" href="#panics-29">§</a>Panics</h5>
<p>This function will panic if the two slices have different lengths.</p>
<h5 id="examples-88"><a class="doc-anchor" href="#examples-88">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>one = [<span class="number">0xA5u8</span>, <span class="number">0x69</span>];
<span class="kw">let </span><span class="kw-2">mut </span>two = <span class="number">0x1234u16</span>;
<span class="kw">let </span>one_bits = one.view_bits_mut::&lt;Msb0&gt;();
<span class="kw">let </span>two_bits = two.view_bits_mut::&lt;Lsb0&gt;();

one_bits.swap_with_bitslice(two_bits);

<span class="macro">assert_eq!</span>(one, [<span class="number">0x2C</span>, <span class="number">0x48</span>]);
<span class="macro">assert_eq!</span>(two, <span class="number">0x96A5</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.align_to" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#2193-2222">source</a><h4 class="code-header">pub unsafe fn <a href="#method.align_to" class="fn">align_to</a>&lt;U&gt;(&amp;self) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Self</a>, &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, U&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Self</a>)<div class="where">where
    U: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h4></section></summary><div class="docblock"><p>Transmute the bitslice to a bitslice of another type, ensuring alignment
of the types is maintained.</p>
<p>This method splits the bitslice into three distinct bitslices: prefix,
correctly aligned middle bitslice of a new type, and the suffix
bitslice. The method may make the middle bitslice the greatest
length possible for a given type and input bitslice, but only your
algorithm’s performance should depend on that, not its correctness. It
is permissible for all of the input data to be returned as the prefix or
suffix bitslice.</p>
<h5 id="original-80"><a class="doc-anchor" href="#original-80">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.align_to"><code>slice::align_to</code></a></p>
<h5 id="api-differences-23"><a class="doc-anchor" href="#api-differences-23">§</a>API Differences</h5>
<p>Type <code>U</code> is <strong>required</strong> to have the same type family as type <code>T</code>.
Whatever <code>T</code> is of the fundamental integers, atomics, or <code>Cell</code>
wrappers, <code>U</code> must be a different width in the same family. Changing the
type family with this method is <strong>unsound</strong> and strictly forbidden.
Unfortunately, it cannot be guaranteed by this function, so you are
required to abide by this limitation.</p>
<h5 id="safety-3"><a class="doc-anchor" href="#safety-3">§</a>Safety</h5>
<p>This method is essentially a <code>transmute</code> with respect to the elements in
the returned middle bitslice, so all the usual caveats pertaining to
<code>transmute::&lt;T, U&gt;</code> also apply here.</p>
<h5 id="examples-89"><a class="doc-anchor" href="#examples-89">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">unsafe </span>{
  <span class="kw">let </span>bytes: [u8; <span class="number">7</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];
  <span class="kw">let </span>bits = bytes.view_bits::&lt;LocalBits&gt;();
  <span class="kw">let </span>(prefix, shorts, suffix) = bits.align_to::&lt;u16&gt;();
  <span class="kw">match </span>prefix.len() {
    <span class="number">0 </span>=&gt; {
      <span class="macro">assert_eq!</span>(shorts, bits[.. <span class="number">48</span>]);
      <span class="macro">assert_eq!</span>(suffix, bits[<span class="number">48 </span>..]);
    },
    <span class="number">8 </span>=&gt; {
      <span class="macro">assert_eq!</span>(prefix, bits[.. <span class="number">8</span>]);
      <span class="macro">assert_eq!</span>(shorts, bits[<span class="number">8 </span>..]);
    },
    <span class="kw">_ </span>=&gt; <span class="macro">unreachable!</span>(<span class="string">"This case will not occur"</span>)
  }
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.align_to_mut" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#2269-2279">source</a><h4 class="code-header">pub unsafe fn <a href="#method.align_to_mut" class="fn">align_to_mut</a>&lt;U&gt;(
    &amp;mut self,
) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut Self</a>, &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, U&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut Self</a>)<div class="where">where
    U: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h4></section></summary><div class="docblock"><p>Transmute the bitslice to a bitslice of another type, ensuring alignment
of the types is maintained.</p>
<p>This method splits the bitslice into three distinct bitslices: prefix,
correctly aligned middle bitslice of a new type, and the suffix
bitslice. The method may make the middle bitslice the greatest
length possible for a given type and input bitslice, but only your
algorithm’s performance should depend on that, not its correctness. It
is permissible for all of the input data to be returned as the prefix or
suffix bitslice.</p>
<h5 id="original-81"><a class="doc-anchor" href="#original-81">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.align_to"><code>slice::align_to</code></a></p>
<h5 id="api-differences-24"><a class="doc-anchor" href="#api-differences-24">§</a>API Differences</h5>
<p>Type <code>U</code> is <strong>required</strong> to have the same type family as type <code>T</code>.
Whatever <code>T</code> is of the fundamental integers, atomics, or <code>Cell</code>
wrappers, <code>U</code> must be a different width in the same family. Changing the
type family with this method is <strong>unsound</strong> and strictly forbidden.
Unfortunately, it cannot be guaranteed by this function, so you are
required to abide by this limitation.</p>
<h5 id="safety-4"><a class="doc-anchor" href="#safety-4">§</a>Safety</h5>
<p>This method is essentially a <code>transmute</code> with respect to the elements in
the returned middle bitslice, so all the usual caveats pertaining to
<code>transmute::&lt;T, U&gt;</code> also apply here.</p>
<h5 id="examples-90"><a class="doc-anchor" href="#examples-90">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">unsafe </span>{
  <span class="kw">let </span><span class="kw-2">mut </span>bytes: [u8; <span class="number">7</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];
  <span class="kw">let </span>bits = bytes.view_bits_mut::&lt;LocalBits&gt;();
  <span class="kw">let </span>(prefix, shorts, suffix) = bits.align_to_mut::&lt;u16&gt;();
  <span class="comment">//  same access and behavior as in `align_to`
</span>}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_bitvec" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#2307-2309">source</a><h4 class="code-header">pub fn <a href="#method.to_bitvec" class="fn">to_bitvec</a>(&amp;self) -&gt; <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;O, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Copies <code>self</code> into a new <code>BitVec</code>.</p>
<h5 id="original-82"><a class="doc-anchor" href="#original-82">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std.primitive.html#method.to_vec"><code>slice::to_vec</code></a></p>
<h5 id="examples-91"><a class="doc-anchor" href="#examples-91">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>bv = bits.to_bitvec();
<span class="macro">assert_eq!</span>(bits, bv);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.repeat-1" class="method"><a class="src rightside" href="../../src/bitvec/slice/api.rs.html#2348-2365">source</a><h4 class="code-header">pub fn <a href="#method.repeat-1" class="fn">repeat</a>(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;O, T&gt;">ⓘ</a><div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h4></section></summary><div class="docblock"><p>Creates a vector by repeating a slice <code>n</code> times.</p>
<h5 id="original-83"><a class="doc-anchor" href="#original-83">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.repeat"><code>slice::repeat</code></a></p>
<h5 id="panics-30"><a class="doc-anchor" href="#panics-30">§</a>Panics</h5>
<p>This function will panic if the capacity would overflow.</p>
<h5 id="examples-92"><a class="doc-anchor" href="#examples-92">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].repeat(<span class="number">3</span>), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
<p>A panic upon overflow:</p>

<div class="example-wrap should_panic"><a href="#" class="tooltip" title="This example panics">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="comment">// this will panic at runtime
</span><span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].repeat(BitSlice::&lt;LocalBits, usize&gt;::MAX_BITS);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#731-737">source</a><h4 class="code-header">pub fn <a href="#method.set" class="fn">set</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Sets the bit value at the given position.</p>
<h5 id="parameters-6"><a class="doc-anchor" href="#parameters-6">§</a>Parameters</h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>index</code>: The bit index to set. It must be in the range <code>0 .. self.len()</code>.</li>
<li><code>value</code>: The value to be set, <code>true</code> for <code>1</code> and <code>false</code> for <code>0</code>.</li>
</ul>
<h5 id="effects-1"><a class="doc-anchor" href="#effects-1">§</a>Effects</h5>
<p>If <code>index</code> is valid, then the bit to which it refers is set to <code>value</code>.</p>
<h5 id="panics-31"><a class="doc-anchor" href="#panics-31">§</a>Panics</h5>
<p>This method panics if <code>index</code> is outside the slice domain.</p>
<h5 id="examples-93"><a class="doc-anchor" href="#examples-93">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">0u8</span>;
<span class="kw">let </span>bits = data.view_bits_mut::&lt;Msb0&gt;();

<span class="macro">assert!</span>(!bits.get(<span class="number">7</span>).unwrap());
bits.set(<span class="number">7</span>, <span class="bool-val">true</span>);
<span class="macro">assert!</span>(bits.get(<span class="number">7</span>).unwrap());
<span class="macro">assert_eq!</span>(data, <span class="number">1</span>);</code></pre></div>
<p>This example panics when it attempts to set a bit that is out of bounds.</p>

<div class="example-wrap should_panic"><a href="#" class="tooltip" title="This example panics">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>];
bits.set(<span class="number">1</span>, <span class="bool-val">false</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_unchecked" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#785-787">source</a><h4 class="code-header">pub unsafe fn <a href="#method.set_unchecked" class="fn">set_unchecked</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Sets a bit at an index, without checking boundary conditions.</p>
<p>This is generally not recommended; use with caution! For a safe
alternative, see <a href="#method.set"><code>set</code></a>.</p>
<h5 id="parameters-7"><a class="doc-anchor" href="#parameters-7">§</a>Parameters</h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>index</code>: The bit index to set. It must be in the range <code>0 .. self.len()</code>. It will not be checked.</li>
</ul>
<h5 id="effects-2"><a class="doc-anchor" href="#effects-2">§</a>Effects</h5>
<p>The bit at <code>index</code> is set to <code>value</code>.</p>
<h5 id="safety-5"><a class="doc-anchor" href="#safety-5">§</a>Safety</h5>
<p>This method is <strong>not</strong> safe. It performs raw pointer arithmetic to seek
from the start of the slice to the requested index, and set the bit
there. It does not inspect the length of <code>self</code>, and it is free to
perform out-of-bounds memory <em>write</em> access.</p>
<p>Use this method <strong>only</strong> when you have already performed the bounds
check, and can guarantee that the call occurs with a safely in-bounds
index.</p>
<h5 id="examples-94"><a class="doc-anchor" href="#examples-94">§</a>Examples</h5>
<p>This example uses a bit slice of length 2, and demonstrates
out-of-bounds access to the last bit in the element.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">0u8</span>;
<span class="kw">let </span>bits = <span class="kw-2">&amp;mut </span>data.view_bits_mut::&lt;Msb0&gt;()[<span class="number">2 </span>.. <span class="number">4</span>];

<span class="macro">assert_eq!</span>(bits.len(), <span class="number">2</span>);
<span class="kw">unsafe </span>{
  bits.set_unchecked(<span class="number">5</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(data, <span class="number">1</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.all" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#819-844">source</a><h4 class="code-header">pub fn <a href="#method.all" class="fn">all</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if <em>all</em> bits in the slice domain are set (logical <code>∧</code>).</p>
<h5 id="truth-table"><a class="doc-anchor" href="#truth-table">§</a>Truth Table</h5><div class="example-wrap"><pre class="language-text"><code>0 0 =&gt; 0
0 1 =&gt; 0
1 0 =&gt; 0
1 1 =&gt; 1
</code></pre></div><h5 id="parameters-8"><a class="doc-anchor" href="#parameters-8">§</a>Parameters</h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-4"><a class="doc-anchor" href="#returns-4">§</a>Returns</h5>
<p>Whether all bits in the slice domain are set. The empty slice returns
<code>true</code>.</p>
<h5 id="examples-95"><a class="doc-anchor" href="#examples-95">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert!</span>(bits[.. <span class="number">2</span>].all());
<span class="macro">assert!</span>(!bits[<span class="number">2 </span>..].all());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.any" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#876-890">source</a><h4 class="code-header">pub fn <a href="#method.any" class="fn">any</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if <em>any</em> bit in the slice is set (logical <code>∨</code>).</p>
<h5 id="truth-table-1"><a class="doc-anchor" href="#truth-table-1">§</a>Truth Table</h5><div class="example-wrap"><pre class="language-text"><code>0 0 =&gt; 0
0 1 =&gt; 1
1 0 =&gt; 1
1 1 =&gt; 1
</code></pre></div><h5 id="parameters-9"><a class="doc-anchor" href="#parameters-9">§</a>Parameters</h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-5"><a class="doc-anchor" href="#returns-5">§</a>Returns</h5>
<p>Whether any bit in the slice domain is set. The empty slice returns
<code>false</code>.</p>
<h5 id="examples-96"><a class="doc-anchor" href="#examples-96">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert!</span>(bits[.. <span class="number">2</span>].any());
<span class="macro">assert!</span>(!bits[<span class="number">2 </span>..].any());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.not_all" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#921-923">source</a><h4 class="code-header">pub fn <a href="#method.not_all" class="fn">not_all</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if <em>any</em> bit in the slice is unset (logical <code>¬∧</code>).</p>
<h5 id="truth-table-2"><a class="doc-anchor" href="#truth-table-2">§</a>Truth Table</h5><div class="example-wrap"><pre class="language-text"><code>0 0 =&gt; 1
0 1 =&gt; 1
1 0 =&gt; 1
1 1 =&gt; 0
</code></pre></div><h5 id="parameters-10"><a class="doc-anchor" href="#parameters-10">§</a>Parameters</h5>
<ul>
<li>`&amp;self</li>
</ul>
<h5 id="returns-6"><a class="doc-anchor" href="#returns-6">§</a>Returns</h5>
<p>Whether any bit in the slice domain is unset.</p>
<h5 id="examples-97"><a class="doc-anchor" href="#examples-97">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert!</span>(!bits[.. <span class="number">2</span>].not_all());
<span class="macro">assert!</span>(bits[<span class="number">2 </span>..].not_all());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.not_any" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#954-956">source</a><h4 class="code-header">pub fn <a href="#method.not_any" class="fn">not_any</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if <em>all</em> bits in the slice are unset (logical <code>¬∨</code>).</p>
<h5 id="truth-table-3"><a class="doc-anchor" href="#truth-table-3">§</a>Truth Table</h5><div class="example-wrap"><pre class="language-text"><code>0 0 =&gt; 1
0 1 =&gt; 0
1 0 =&gt; 0
1 1 =&gt; 0
</code></pre></div><h5 id="parameters-11"><a class="doc-anchor" href="#parameters-11">§</a>Parameters</h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-7"><a class="doc-anchor" href="#returns-7">§</a>Returns</h5>
<p>Whether all bits in the slice domain are unset.</p>
<h5 id="examples-98"><a class="doc-anchor" href="#examples-98">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert!</span>(!bits[.. <span class="number">2</span>].not_any());
<span class="macro">assert!</span>(bits[<span class="number">2 </span>..].not_any());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.some" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#997-999">source</a><h4 class="code-header">pub fn <a href="#method.some" class="fn">some</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests whether the slice has some, but not all, bits set and some, but
not all, bits unset.</p>
<p>This is <code>false</code> if either <a href="#method.all"><code>.all</code></a> or <a href="#method.not_any"><code>.not_any</code></a> are <code>true</code>.</p>
<h5 id="truth-table-4"><a class="doc-anchor" href="#truth-table-4">§</a>Truth Table</h5><div class="example-wrap"><pre class="language-text"><code>0 0 =&gt; 0
0 1 =&gt; 1
1 0 =&gt; 1
1 1 =&gt; 0
</code></pre></div><h5 id="parameters-12"><a class="doc-anchor" href="#parameters-12">§</a>Parameters</h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-8"><a class="doc-anchor" href="#returns-8">§</a>Returns</h5>
<p>Whether the slice domain has mixed content. The empty slice returns
<code>false</code>.</p>
<h5 id="examples-99"><a class="doc-anchor" href="#examples-99">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>data = <span class="number">0b111_000_10u8</span>;
<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];

<span class="macro">assert!</span>(!bits[.. <span class="number">2</span>].some());
<span class="macro">assert!</span>(!bits[<span class="number">2 </span>.. <span class="number">4</span>].some());
<span class="macro">assert!</span>(bits.some());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.count_ones" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#1023-1045">source</a><h4 class="code-header">pub fn <a href="#method.count_ones" class="fn">count_ones</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of ones in the memory region backing <code>self</code>.</p>
<h5 id="parameters-13"><a class="doc-anchor" href="#parameters-13">§</a>Parameters</h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-9"><a class="doc-anchor" href="#returns-9">§</a>Returns</h5>
<p>The number of high bits in the slice domain.</p>
<h5 id="examples-100"><a class="doc-anchor" href="#examples-100">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(bits[.. <span class="number">2</span>].count_ones(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(bits[<span class="number">2 </span>..].count_ones(), <span class="number">0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.count_zeros" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#1069-1091">source</a><h4 class="code-header">pub fn <a href="#method.count_zeros" class="fn">count_zeros</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of zeros in the memory region backing <code>self</code>.</p>
<h5 id="parameters-14"><a class="doc-anchor" href="#parameters-14">§</a>Parameters</h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-10"><a class="doc-anchor" href="#returns-10">§</a>Returns</h5>
<p>The number of low bits in the slice domain.</p>
<h5 id="examples-101"><a class="doc-anchor" href="#examples-101">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(bits[.. <span class="number">2</span>].count_zeros(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(bits[<span class="number">2 </span>..].count_zeros(), <span class="number">2</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_all" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#1115-1152">source</a><h4 class="code-header">pub fn <a href="#method.set_all" class="fn">set_all</a>(&amp;mut self, value: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Sets all bits in the slice to a value.</p>
<h5 id="parameters-15"><a class="doc-anchor" href="#parameters-15">§</a>Parameters</h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>value</code>: The bit value to which all bits in the slice will be set.</li>
</ul>
<h5 id="examples-102"><a class="doc-anchor" href="#examples-102">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>src = <span class="number">0u8</span>;
<span class="kw">let </span>bits = src.view_bits_mut::&lt;Msb0&gt;();
bits[<span class="number">2 </span>.. <span class="number">6</span>].set_all(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(bits.as_slice(), <span class="kw-2">&amp;</span>[<span class="number">0b0011_1100</span>]);
bits[<span class="number">3 </span>.. <span class="number">5</span>].set_all(<span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(bits.as_slice(), <span class="kw-2">&amp;</span>[<span class="number">0b0010_0100</span>]);
bits[.. <span class="number">1</span>].set_all(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(bits.as_slice(), <span class="kw-2">&amp;</span>[<span class="number">0b1010_0100</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.for_each" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#1184-1193">source</a><h4 class="code-header">pub fn <a href="#method.for_each" class="fn">for_each</a>&lt;F&gt;(&amp;mut self, func: F)<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Applies a function to each bit in the slice.</p>
<p><code>BitSlice</code> cannot implement <code>IndexMut</code>, as it cannot manifest <code>&amp;mut bool</code> references, and the <a href="../slice/struct.BitMut.html" title="struct bitvec::slice::BitMut"><code>BitMut</code></a> proxy reference has an unavoidable
overhead. This method bypasses both problems, by applying a function to
each pair of index and value in the slice, without constructing a proxy
reference.</p>
<h5 id="parameters-16"><a class="doc-anchor" href="#parameters-16">§</a>Parameters</h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>func</code>: A function which receives two arguments, <code>index: usize</code> and
<code>value: bool</code>, and returns a <code>bool</code>.</li>
</ul>
<h5 id="effects-3"><a class="doc-anchor" href="#effects-3">§</a>Effects</h5>
<p>For each index in the slice, the result of invoking <code>func</code> with the
index number and current bit value is written into the slice.</p>
<h5 id="examples-103"><a class="doc-anchor" href="#examples-103">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">0u8</span>;
<span class="kw">let </span>bits = data.view_bits_mut::&lt;Msb0&gt;();
bits.for_each(|idx, _bit| idx % <span class="number">3 </span>== <span class="number">0</span>);
<span class="macro">assert_eq!</span>(data, <span class="number">0b100_100_10</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_slice-1" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#1227-1231">source</a><h4 class="code-header">pub fn <a href="#method.as_slice-1" class="fn">as_slice</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.slice.html">[T]</a></h4></section></summary><div class="docblock"><p>Accesses the total backing storage of the <code>BitSlice</code>, as a slice of its
elements.</p>
<p>This method produces a slice over all the memory elements it touches,
using the current storage parameter. This is safe to do, as any events
that would create an aliasing view into the elements covered by the
returned slice will also have caused the slice to use its alias-aware
type.</p>
<h5 id="parameters-17"><a class="doc-anchor" href="#parameters-17">§</a>Parameters</h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-11"><a class="doc-anchor" href="#returns-11">§</a>Returns</h5>
<p>A view of the entire memory region this slice covers, including the edge
elements.</p>
<h5 id="examples-104"><a class="doc-anchor" href="#examples-104">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>data = <span class="number">0x3Cu8</span>;
<span class="kw">let </span>bits = <span class="kw-2">&amp;</span>data.view_bits::&lt;LocalBits&gt;()[<span class="number">2 </span>.. <span class="number">6</span>];

<span class="macro">assert!</span>(bits.all());
<span class="macro">assert_eq!</span>(bits.len(), <span class="number">4</span>);
<span class="macro">assert_eq!</span>(bits.as_slice(), <span class="kw-2">&amp;</span>[<span class="number">0x3Cu8</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_raw_slice" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#1275-1277">source</a><h4 class="code-header">pub fn <a href="#method.as_raw_slice" class="fn">as_raw_slice</a>(&amp;self) -&gt; &amp;[T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>]</h4></section></summary><div class="docblock"><p>Views the wholly-filled elements of the <code>BitSlice</code>.</p>
<p>This will not include partially-owned edge elements, as they may be
aliased by other handles. To gain access to all elements that the
<code>BitSlice</code> region covers, use one of the following:</p>
<ul>
<li><a href="#method.as_slice"><code>.as_slice</code></a> produces a shared slice over all elements, marked
aliased as appropriate.</li>
<li><a href="#method.domain"><code>.domain</code></a> produces a view describing each component of the region,
marking only the contended edges as aliased and the uncontended
interior as unaliased.</li>
</ul>
<h5 id="parameters-18"><a class="doc-anchor" href="#parameters-18">§</a>Parameters</h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-12"><a class="doc-anchor" href="#returns-12">§</a>Returns</h5>
<p>A slice of all the wholly-filled elements in the <code>BitSlice</code> backing
storage.</p>
<h5 id="examples-105"><a class="doc-anchor" href="#examples-105">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>data = [<span class="number">1u8</span>, <span class="number">66</span>];
<span class="kw">let </span>bits = data.view_bits::&lt;Msb0&gt;();

<span class="kw">let </span>accum = bits
  .as_raw_slice()
  .iter()
  .copied()
  .map(u8::count_ones)
  .sum::&lt;u32&gt;();
<span class="macro">assert_eq!</span>(accum, <span class="number">3</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_raw_slice_mut" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#1317-1319">source</a><h4 class="code-header">pub fn <a href="#method.as_raw_slice_mut" class="fn">as_raw_slice_mut</a>(&amp;mut self) -&gt; &amp;mut [T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>]</h4></section></summary><div class="docblock"><p>Views the wholly-filled elements of the <code>BitSlice</code>.</p>
<p>This will not include partially-owned edge elements, as they may be
aliased by other handles. To gain access to all elements that the
<code>BitSlice</code> region covers, use one of the following:</p>
<ul>
<li><a href="#method.as_aliased_slice"><code>.as_aliased_slice</code></a> produces a shared slice over all elements,
marked as aliased to allow for the possibliity of mutation.</li>
<li><a href="#method.domain_mut"><code>.domain_mut</code></a> produces a view describing each component of the
region, marking only the contended edges as aliased and the
uncontended interior as unaliased.</li>
</ul>
<h5 id="parameters-19"><a class="doc-anchor" href="#parameters-19">§</a>Parameters</h5>
<ul>
<li><code>&amp;mut self</code></li>
</ul>
<h5 id="returns-13"><a class="doc-anchor" href="#returns-13">§</a>Returns</h5>
<p>A mutable slice of all the wholly-filled elements in the <code>BitSlice</code>
backing storage.</p>
<h5 id="examples-106"><a class="doc-anchor" href="#examples-106">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = [<span class="number">1u8</span>, <span class="number">64</span>];
<span class="kw">let </span>bits = data.view_bits_mut::&lt;Msb0&gt;();
<span class="kw">for </span>elt <span class="kw">in </span>bits.as_raw_slice_mut() {
  <span class="kw-2">*</span>elt |= <span class="number">2</span>;
}
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>[<span class="number">3</span>, <span class="number">66</span>], bits.as_slice());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bit_domain" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#1404-1406">source</a><h4 class="code-header">pub fn <a href="#method.bit_domain" class="fn">bit_domain</a>(&amp;self) -&gt; <a class="enum" href="../domain/enum.BitDomain.html" title="enum bitvec::domain::BitDomain">BitDomain</a>&lt;'_, O, T&gt;</h4></section></summary><div class="docblock"><p>Splits the slice into the logical components of its memory domain.</p>
<p>This produces a set of read-only subslices, marking as much as possible
as affirmatively lacking any write-capable view (<code>T::NoAlias</code>). The
unaliased view is able to safely perform unsynchronized reads from
memory without causing undefined behavior, as the type system is able to
statically prove that no other write-capable views exist.</p>
<h5 id="parameters-20"><a class="doc-anchor" href="#parameters-20">§</a>Parameters</h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-14"><a class="doc-anchor" href="#returns-14">§</a>Returns</h5>
<p>A <code>BitDomain</code> structure representing the logical components of the
memory region.</p>
<h5 id="safety-exception"><a class="doc-anchor" href="#safety-exception">§</a>Safety Exception</h5>
<p>The following snippet describes a means of constructing a <code>T::NoAlias</code>
view into memory that is, in fact, aliased:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>core::sync::atomic::AtomicU8;
<span class="kw">type </span>Bs&lt;T&gt; = BitSlice&lt;LocalBits, T&gt;;

<span class="kw">let </span>data = [AtomicU8::new(<span class="number">0</span>), AtomicU8::new(<span class="number">0</span>), AtomicU8::new(<span class="number">0</span>)];
<span class="kw">let </span>bits: <span class="kw-2">&amp;</span>Bs&lt;AtomicU8&gt; = data.view_bits::&lt;LocalBits&gt;();
<span class="kw">let </span>subslice: <span class="kw-2">&amp;</span>Bs&lt;AtomicU8&gt; = <span class="kw-2">&amp;</span>bits[<span class="number">4 </span>.. <span class="number">20</span>];

<span class="kw">let </span>(<span class="kw">_</span>, noalias, <span class="kw">_</span>): (<span class="kw">_</span>, <span class="kw-2">&amp;</span>Bs&lt;u8&gt;, <span class="kw">_</span>) =
  subslice.bit_domain().region().unwrap();</code></pre></div>
<p>The <code>noalias</code> reference, which has memory type <code>u8</code>, assumes that it can
act as an <code>&amp;u8</code> reference: unsynchronized loads are permitted, as no
handle exists which is capable of modifying the middle bit of <code>data</code>.
This means that LLVM is permitted to issue loads from memory <em>wherever</em>
it wants in the block during which <code>noalias</code> is live, as all loads are
equivalent.</p>
<p>Use of the <code>bits</code> or <code>subslice</code> handles, which are still live for the
lifetime of <code>noalias</code>, to issue <a href="#method.set_aliased"><code>.set_aliased</code></a> calls into the middle
element introduce <strong>undefined behavior</strong>. <code>bitvec</code> permits safe code to
introduce this undefined behavior solely because it requires deliberate
opt-in – you must start from atomic data; this cannot occur when <code>data</code>
is non-atomic – and use of the shared-mutation facility simultaneously
with the unaliasing view.</p>
<p>The <a href="#method.set_aliased"><code>.set_aliased</code></a> method is speculative, and will be marked as
<code>unsafe</code> or removed at any suspicion that its presence in the library
has any costs.</p>
<h5 id="examples-107"><a class="doc-anchor" href="#examples-107">§</a>Examples</h5>
<p>This method can be used to accelerate reads from a slice that is marked
as aliased.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;
<span class="kw">type </span>Bs&lt;T&gt; = BitSlice&lt;LocalBits, T&gt;;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>LocalBits, u8; <span class="number">0</span>; <span class="number">24</span>];
<span class="kw">let </span>(a, b): (
  <span class="kw-2">&amp;mut </span>Bs&lt;&lt;u8 <span class="kw">as </span>BitStore&gt;::Alias&gt;,
  <span class="kw-2">&amp;mut </span>Bs&lt;&lt;u8 <span class="kw">as </span>BitStore&gt;::Alias&gt;,
) = bits.split_at_mut(<span class="number">4</span>);
<span class="kw">let </span>(partial, full, <span class="kw">_</span>): (
  <span class="kw-2">&amp;</span>Bs&lt;&lt;u8 <span class="kw">as </span>BitStore&gt;::Alias&gt;,
  <span class="kw-2">&amp;</span>Bs&lt;&lt;u8 <span class="kw">as </span>BitStore&gt;::Mem&gt;,
  <span class="kw">_</span>,
) = b.bit_domain().region().unwrap();
read_from(partial); <span class="comment">// uses alias-aware reads
</span>read_from(full); <span class="comment">// uses ordinary reads</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bit_domain_mut" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#1431-1433">source</a><h4 class="code-header">pub fn <a href="#method.bit_domain_mut" class="fn">bit_domain_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../domain/enum.BitDomainMut.html" title="enum bitvec::domain::BitDomainMut">BitDomainMut</a>&lt;'_, O, T&gt;</h4></section></summary><div class="docblock"><p>Splits the slice into the logical components of its memory domain.</p>
<p>This produces a set of mutable subslices, marking as much as possible as
affirmatively lacking any other view (<code>T::Mem</code>). The bare view is able
to safely perform unsynchronized reads from and writes to memory without
causing undefined behavior, as the type system is able to statically
prove that no other views exist.</p>
<h5 id="why-this-is-more-sound-than-bit_domain"><a class="doc-anchor" href="#why-this-is-more-sound-than-bit_domain">§</a>Why This Is More Sound Than <code>.bit_domain</code></h5>
<p>The <code>&amp;mut</code> exclusion rule makes it impossible to construct two
references over the same memory where one of them is marked <code>&amp;mut</code>. This
makes it impossible to hold a live reference to memory <em>separately</em> from
any references produced from this method. For the duration of all
references produced by this method, all ancestor references used to
reach this method call are either suspended or dead, and the compiler
will not allow you to use them.</p>
<p>As such, this method cannot introduce undefined behavior where a
reference incorrectly believes that the referent memory region is
immutable.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.domain" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#1474-1476">source</a><h4 class="code-header">pub fn <a href="#method.domain" class="fn">domain</a>(&amp;self) -&gt; <a class="enum" href="../domain/enum.Domain.html" title="enum bitvec::domain::Domain">Domain</a>&lt;'_, T&gt; <a href="#" class="tooltip" data-notable-ty="Domain&lt;&#39;_, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Splits the slice into immutable references to its underlying memory
components.</p>
<p>Unlike <a href="#method.bit_domain"><code>.bit_domain</code></a> and <a href="#method.bit_domain_mut"><code>.bit_domain_mut</code></a>, this does not return
smaller <code>BitSlice</code> handles but rather appropriately-marked references to
the underlying memory elements.</p>
<p>The aliased references allow mutation of these elements. You are
required to not use mutating methods on these references <em>at all</em>. This
function is not marked <code>unsafe</code>, but this is a contract you must uphold.
Use <a href="#method.domain_mut"><code>.domain_mut</code></a> to modify the underlying elements.</p>
<blockquote>
<p>It is not currently possible to forbid mutation through these
references. This may change in the future.</p>
</blockquote>
<h5 id="safety-exception-1"><a class="doc-anchor" href="#safety-exception-1">§</a>Safety Exception</h5>
<p>As with <a href="#method.bit_domain"><code>.bit_domain</code></a>, this produces unsynchronized immutable
references over the fully-populated interior elements. If this view is
constructed from a <code>BitSlice</code> handle over atomic memory, then it will
remove the atomic access behavior for the interior elements. This <em>by
itself</em> is safe, as long as no contemporaneous atomic writes to that
memory can occur. You must not retain and use an atomic reference to the
memory region marked as <code>NoAlias</code> for the duration of this view’s
existence.</p>
<h5 id="parameters-21"><a class="doc-anchor" href="#parameters-21">§</a>Parameters</h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-15"><a class="doc-anchor" href="#returns-15">§</a>Returns</h5>
<p>A read-only descriptor of the memory elements backing <code>*self</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.domain_mut" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#1504-1506">source</a><h4 class="code-header">pub fn <a href="#method.domain_mut" class="fn">domain_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../domain/enum.DomainMut.html" title="enum bitvec::domain::DomainMut">DomainMut</a>&lt;'_, T&gt;</h4></section></summary><div class="docblock"><p>Splits the slice into mutable references to its underlying memory
elements.</p>
<p>Like <a href="#method.domain"><code>.domain</code></a>, this returns appropriately-marked references to the
underlying memory elements. These references are all writable.</p>
<p>The aliased edge references permit modifying memory beyond their bit
marker. You are required to only mutate the region of these edge
elements that you currently govern. This function is not marked
<code>unsafe</code>, but this is a contract you must uphold.</p>
<blockquote>
<p>It is not currently possible to forbid out-of-bounds mutation through
these references. This may change in the future.</p>
</blockquote>
<h5 id="parameters-22"><a class="doc-anchor" href="#parameters-22">§</a>Parameters</h5>
<ul>
<li><code>&amp;mut self</code></li>
</ul>
<h5 id="returns-16"><a class="doc-anchor" href="#returns-16">§</a>Returns</h5>
<p>A descriptor of the memory elements underneath <code>*self</code>, permitting
mutation.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_at_unchecked" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#1547-1549">source</a><h4 class="code-header">pub unsafe fn <a href="#method.split_at_unchecked" class="fn">split_at_unchecked</a>(&amp;self, mid: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Self</a>, <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class="docblock"><p>Splits a slice at some mid-point, without checking boundary conditions.</p>
<p>This is generally not recommended; use with caution! For a safe
alternative, see <a href="#method.split_at"><code>split_at</code></a>.</p>
<h5 id="parameters-23"><a class="doc-anchor" href="#parameters-23">§</a>Parameters</h5>
<ul>
<li><code>&amp;self</code></li>
<li><code>mid</code>: The index at which to split the slice. This must be in the
range <code>0 .. self.len()</code>.</li>
</ul>
<h5 id="returns-17"><a class="doc-anchor" href="#returns-17">§</a>Returns</h5>
<ul>
<li><code>.0</code>: <code>&amp;self[.. mid]</code></li>
<li><code>.1</code>: <code>&amp;self[mid ..]</code></li>
</ul>
<h5 id="safety-6"><a class="doc-anchor" href="#safety-6">§</a>Safety</h5>
<p>This function is <strong>not</strong> safe. It performs raw pointer arithmetic to
construct two new references. If <code>mid</code> is out of bounds, then the first
slice will be too large, and the second will be <em>catastrophically</em>
incorrect. As both are references to invalid memory, they are undefined
to <em>construct</em>, and may not ever be used.</p>
<h5 id="examples-108"><a class="doc-anchor" href="#examples-108">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>data = <span class="number">0x0180u16</span>;
<span class="kw">let </span>bits = data.view_bits::&lt;Msb0&gt;();

<span class="kw">let </span>(one, two) = <span class="kw">unsafe </span>{ bits.split_at_unchecked(<span class="number">8</span>) };
<span class="macro">assert!</span>(one[<span class="number">7</span>]);
<span class="macro">assert!</span>(two[<span class="number">0</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_at_unchecked_mut" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#1593-1602">source</a><h4 class="code-header">pub unsafe fn <a href="#method.split_at_unchecked_mut" class="fn">split_at_unchecked_mut</a>(
    &amp;mut self,
    mid: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>,
) -&gt; (&amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;, &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;)</h4></section></summary><div class="docblock"><p>Splits a mutable slice at some mid-point, without checking boundary
conditions.</p>
<p>This is generally not recommended; use with caution! For a safe
alternative, see <a href="#method.split_at_mut"><code>split_at_mut</code></a>.</p>
<h5 id="parameters-24"><a class="doc-anchor" href="#parameters-24">§</a>Parameters</h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>mid</code>: The index at which to split the slice. This must be in the
range <code>0 .. self.len()</code>.</li>
</ul>
<h5 id="returns-18"><a class="doc-anchor" href="#returns-18">§</a>Returns</h5>
<ul>
<li><code>.0</code>: <code>&amp;mut self[.. mid]</code></li>
<li><code>.1</code>: <code>&amp;mut self[mid ..]</code></li>
</ul>
<h5 id="safety-7"><a class="doc-anchor" href="#safety-7">§</a>Safety</h5>
<p>This function is <strong>not</strong> safe. It performs raw pointer arithmetic to
construct two new references. If <code>mid</code> is out of bounds, then the first
slice will be too large, and the second will be <em>catastrophically</em>
incorrect. As both are references to invalid memory, they are undefined
to <em>construct</em>, and may not ever be used.</p>
<h5 id="examples-109"><a class="doc-anchor" href="#examples-109">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">0u16</span>;
<span class="kw">let </span>bits = data.view_bits_mut::&lt;Msb0&gt;();

<span class="kw">let </span>(one, two) = <span class="kw">unsafe </span>{ bits.split_at_unchecked_mut(<span class="number">8</span>) };
one.set(<span class="number">7</span>, <span class="bool-val">true</span>);
two.set(<span class="number">0</span>, <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(data, <span class="number">0x0180u16</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.swap_unchecked" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#1665-1670">source</a><h4 class="code-header">pub unsafe fn <a href="#method.swap_unchecked" class="fn">swap_unchecked</a>(&amp;mut self, a: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>, b: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Swaps the bits at two indices without checking boundary conditions.</p>
<p>This is generally not recommended; use with caution! For a safe
alternative, see <a href="#method.swap"><code>swap</code></a>.</p>
<h5 id="parameters-25"><a class="doc-anchor" href="#parameters-25">§</a>Parameters</h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>a</code>: One index to swap.</li>
<li><code>b</code>: The other index to swap.</li>
</ul>
<h5 id="effects-4"><a class="doc-anchor" href="#effects-4">§</a>Effects</h5>
<p>The bit at index <code>a</code> is written into index <code>b</code>, and the bit at index <code>b</code>
is written into <code>a</code>.</p>
<h5 id="safety-8"><a class="doc-anchor" href="#safety-8">§</a>Safety</h5>
<p>Both <code>a</code> and <code>b</code> must be less than <code>self.len()</code>. Indices greater than
the length will cause out-of-bounds memory access, which can lead to
memory unsafety and a program crash.</p>
<h5 id="examples-110"><a class="doc-anchor" href="#examples-110">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">8u8</span>;
<span class="kw">let </span>bits = data.view_bits_mut::&lt;Msb0&gt;();

<span class="kw">unsafe </span>{ bits.swap_unchecked(<span class="number">0</span>, <span class="number">4</span>); }

<span class="macro">assert_eq!</span>(data, <span class="number">128</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.copy_unchecked" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#1709-1712">source</a><h4 class="code-header">pub unsafe fn <a href="#method.copy_unchecked" class="fn">copy_unchecked</a>(&amp;mut self, from: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>, to: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Copies a bit from one index to another without checking boundary
conditions.</p>
<h5 id="parameters-26"><a class="doc-anchor" href="#parameters-26">§</a>Parameters</h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>from</code>: The index whose bit is to be copied</li>
<li><code>to</code>: The index into which the copied bit is written.</li>
</ul>
<h5 id="effects-5"><a class="doc-anchor" href="#effects-5">§</a>Effects</h5>
<p>The bit at <code>from</code> is written into <code>to</code>.</p>
<h5 id="safety-9"><a class="doc-anchor" href="#safety-9">§</a>Safety</h5>
<p>Both <code>from</code> and <code>to</code> must be less than <code>self.len()</code>, in order for
<code>self</code> to legally read from and write to them, respectively.</p>
<p>If <code>self</code> had been split from a larger slice, reading from <code>from</code> or
writing to <code>to</code> may not <em>necessarily</em> cause a memory-safety violation in
the Rust model, due to the aliasing system <code>bitvec</code> employs. However,
writing outside the bounds of a slice reference is <em>always</em> a logical
error, as it causes changes observable by another reference handle.</p>
<h5 id="examples-111"><a class="doc-anchor" href="#examples-111">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">1u8</span>;
<span class="kw">let </span>bits = data.view_bits_mut::&lt;Lsb0&gt;();

<span class="kw">unsafe </span>{ bits.copy_unchecked(<span class="number">0</span>, <span class="number">2</span>) };

<span class="macro">assert_eq!</span>(data, <span class="number">5</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.copy_within_unchecked" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#1748-1764">source</a><h4 class="code-header">pub unsafe fn <a href="#method.copy_within_unchecked" class="fn">copy_within_unchecked</a>&lt;R&gt;(&amp;mut self, src: R, dest: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>)<div class="where">where
    R: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Copies bits from one part of the slice to another part of itself.</p>
<p><code>src</code> is the range within <code>self</code> to copy from. <code>dest</code> is the starting
index of the range within <code>self</code> to copy to, which will have the same
length as <code>src</code>. The two ranges may overlap. The ends of the two ranges
must be less than or equal to <code>self.len()</code>.</p>
<h5 id="effects-6"><a class="doc-anchor" href="#effects-6">§</a>Effects</h5>
<p><code>self[src]</code> is copied to <code>self[dest .. dest + src.end() - src.start()]</code>.</p>
<h5 id="panics-32"><a class="doc-anchor" href="#panics-32">§</a>Panics</h5>
<p>This function will panic if either range exceeds the end of the slice,
or if the end of <code>src</code> is before the start.</p>
<h5 id="safety-10"><a class="doc-anchor" href="#safety-10">§</a>Safety</h5>
<p>Both the <code>src</code> range and the target range <code>dest .. dest + src.len()</code>
must not exceed the <code>self.len()</code> slice range.</p>
<h5 id="examples-112"><a class="doc-anchor" href="#examples-112">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">0x07u8</span>;
<span class="kw">let </span>bits = data.view_bits_mut::&lt;Msb0&gt;();

<span class="kw">unsafe </span>{ bits.copy_within_unchecked(<span class="number">5 </span>.., <span class="number">0</span>); }

<span class="macro">assert_eq!</span>(data, <span class="number">0xE7</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.offset_from" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#1816-1820">source</a><h4 class="code-header">pub fn <a href="#method.offset_from" class="fn">offset_from</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Self</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.isize.html">isize</a></h4></section></summary><div class="docblock"><p>Produces the absolute offset in bits between two slice heads.</p>
<p>While this method is sound for any two arbitrary bit slices, the answer
it produces is meaningful <em>only</em> when one argument is a strict subslice
of the other. If the two slices are created from different buffers
entirely, a comparison is undefined; if the two slices are disjoint
regions of the same buffer, then the semantically correct distance is
between the tail of the lower and the head of the upper, which this
does not measure.</p>
<h5 id="visual-description"><a class="doc-anchor" href="#visual-description">§</a>Visual Description</h5>
<p>Consider the following sequence of bits:</p>
<div class="example-wrap"><pre class="language-text"><code>[ 0 1 2 3 4 5 6 7 8 9 a b ]
  |       ^^^^^^^       |
  ^^^^^^^^^^^^^^^^^^^^^^^
</code></pre></div>
<p>It does not matter whether there are bits between the tail of the
smaller and the larger slices. The offset is computed from the bit
distance between the two heads.</p>
<h5 id="behavior-4"><a class="doc-anchor" href="#behavior-4">§</a>Behavior</h5>
<p>This function computes the <em>semantic</em> distance between the heads, rather
than the *electrical. It does not take into account the <code>BitOrder</code>
implementation of the slice. See the [<code>::electrical_distance</code>] method
for that comparison.</p>
<h5 id="safety-and-soundness"><a class="doc-anchor" href="#safety-and-soundness">§</a>Safety and Soundness</h5>
<p>One of <code>self</code> or <code>other</code> must contain the other for this comparison to
be meaningful.</p>
<h5 id="parameters-27"><a class="doc-anchor" href="#parameters-27">§</a>Parameters</h5>
<ul>
<li><code>&amp;self</code></li>
<li><code>other</code>: Another bit slice. This must be either a strict subregion or
a strict superregion of <code>self</code>.</li>
</ul>
<h5 id="returns-19"><a class="doc-anchor" href="#returns-19">§</a>Returns</h5>
<p>The distance in (semantic) bits betwen the heads of each region. The
value is positive when <code>other</code> is higher in the address space than
<code>self</code>, and negative when <code>other</code> is lower in the address space than
<code>self</code>.</p>
<p>[<code>::electrical_distance]</code>: #method.electrical_comparison</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.electrical_distance" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#1840-1858">source</a><h4 class="code-header">pub fn <a href="#method.electrical_distance" class="fn">electrical_distance</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Self</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.isize.html">isize</a></h4></section></summary><div class="docblock"><p>Computes the electrical distance between the heads of two slices.</p>
<p>This method uses the slices’ <code>BitOrder</code> implementation to compute the
bit position of their heads, then computes the shift distance, in bits,
between them.</p>
<p>This computation presumes that the bits are counted in the same
direction as are bytes in the abstract memory map.</p>
<h5 id="parameters-28"><a class="doc-anchor" href="#parameters-28">§</a>Parameters</h5>
<ul>
<li><code>&amp;self</code></li>
<li><code>other</code>: Another bit slice. This must be either a strict subregion or
a strict superregion of <code>self</code>.</li>
</ul>
<h5 id="returns-20"><a class="doc-anchor" href="#returns-20">§</a>Returns</h5>
<p>The electrical bit distance between the heads of <code>self</code> and <code>other</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_at_aliased_mut" class="method"><a class="src rightside" href="../../src/bitvec/slice.rs.html#1933-1939">source</a><h4 class="code-header">pub fn <a href="#method.split_at_aliased_mut" class="fn">split_at_aliased_mut</a>(&amp;mut self, mid: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut Self</a>, <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut Self</a>)</h4></section></summary><div class="docblock"><p>Splits a mutable slice at some mid-point.</p>
<p>This method has the same behavior as <a href="#method.split_at_mut"><code>split_at_mut</code></a>, except that it
does not apply an aliasing marker to the partitioned subslices.</p>
<h5 id="safety-11"><a class="doc-anchor" href="#safety-11">§</a>Safety</h5>
<p>Because this method is defined only on <code>BitSlice</code>s whose <code>T</code> type is
alias-safe, the subslices do not need to be additionally marked.</p>
</div></details><section id="associatedconstant.MAX_BITS" class="associatedconstant"><a class="src rightside" href="../../src/bitvec/slice.rs.html#1957">source</a><h4 class="code-header">pub const <a href="#associatedconstant.MAX_BITS" class="constant">MAX_BITS</a>: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a> = 2_305_843_009_213_693_951usize</h4></section><section id="associatedconstant.MAX_ELTS" class="associatedconstant"><a class="src rightside" href="../../src/bitvec/slice.rs.html#1972">source</a><h4 class="code-header">pub const <a href="#associatedconstant.MAX_ELTS" class="constant">MAX_ELTS</a>: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a> = BitPtr&lt;T&gt;::REGION_MAX_ELTS</h4></section></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-AsMut%3CBitSlice%3CO,+T%3E%3E-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#207-216">source</a><a href="#impl-AsMut%3CBitSlice%3CO,+T%3E%3E-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_mut" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#213-215">source</a><a href="#method.as_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsMut.html#tymethod.as_mut" class="fn">as_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <a href="#" class="tooltip" data-notable-ty="&amp;mut BitSlice&lt;O, T&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Converts this type into a mutable reference of the (usually inferred) input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AsRef%3CBitSlice%3CO,+T%3E%3E-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#195-204">source</a><a href="#impl-AsRef%3CBitSlice%3CO,+T%3E%3E-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_ref" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#201-203">source</a><a href="#method.as_ref" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html#tymethod.as_ref" class="fn">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <a href="#" class="tooltip" data-notable-ty="&amp;BitSlice&lt;O, T&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Binary-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#320-329">source</a><a href="#impl-Binary-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Binary.html" title="trait core::fmt::Binary">Binary</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-3" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#326-328">source</a><a href="#method.fmt-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Binary.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.81.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Binary.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitAnd%3CRhs%3E-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#29-42">source</a><a href="#impl-BitAnd%3CRhs%3E-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitAnd.html" title="trait core::ops::bit::BitAnd">BitAnd</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,
    <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;Rhs&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitAnd.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;</h4></section></summary><div class='docblock'>The resulting type after applying the <code>&amp;</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.bitand" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#38-41">source</a><a href="#method.bitand" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitAnd.html#tymethod.bitand" class="fn">bitand</a>(self, rhs: Rhs) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitAnd.html#associatedtype.Output" title="type core::ops::bit::BitAnd::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>&amp;</code> operation. <a href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitAnd.html#tymethod.bitand">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitAndAssign%3CRhs%3E-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#45-55">source</a><a href="#impl-BitAndAssign%3CRhs%3E-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,
    <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;Rhs&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.bitand_assign" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#52-54">source</a><a href="#method.bitand_assign" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign" class="fn">bitand_assign</a>(&amp;mut self, rhs: Rhs)</h4></section></summary><div class='docblock'>Performs the <code>&amp;=</code> operation. <a href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitField-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/field.rs.html#688-717">source</a><a href="#impl-BitField-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,
    <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.load_le" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/field.rs.html#695-698">source</a><a href="#method.load_le" class="anchor">§</a><h4 class="code-header">fn <a href="../field/trait.BitField.html#tymethod.load_le" class="fn">load_le</a>&lt;M&gt;(&amp;self) -&gt; M<div class="where">where
    M: <a class="trait" href="../mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,</div></h4></section></summary><div class='docblock'>Loads from <code>self</code>, using little-endian element <code>T</code> ordering. <a href="../field/trait.BitField.html#tymethod.load_le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.load_be" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/field.rs.html#701-704">source</a><a href="#method.load_be" class="anchor">§</a><h4 class="code-header">fn <a href="../field/trait.BitField.html#tymethod.load_be" class="fn">load_be</a>&lt;M&gt;(&amp;self) -&gt; M<div class="where">where
    M: <a class="trait" href="../mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,</div></h4></section></summary><div class='docblock'>Loads from <code>self</code>, using big-endian element <code>T</code> ordering. <a href="../field/trait.BitField.html#tymethod.load_be">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.store_le" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/field.rs.html#707-710">source</a><a href="#method.store_le" class="anchor">§</a><h4 class="code-header">fn <a href="../field/trait.BitField.html#tymethod.store_le" class="fn">store_le</a>&lt;M&gt;(&amp;mut self, value: M)<div class="where">where
    M: <a class="trait" href="../mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,</div></h4></section></summary><div class='docblock'>Stores into <code>self</code>, using little-endian element ordering. <a href="../field/trait.BitField.html#tymethod.store_le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.store_be" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/field.rs.html#713-716">source</a><a href="#method.store_be" class="anchor">§</a><h4 class="code-header">fn <a href="../field/trait.BitField.html#tymethod.store_be" class="fn">store_be</a>&lt;M&gt;(&amp;mut self, value: M)<div class="where">where
    M: <a class="trait" href="../mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,</div></h4></section></summary><div class='docblock'>Stores into <code>self</code>, using big-endian element ordering. <a href="../field/trait.BitField.html#tymethod.store_be">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.load" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/field.rs.html#129-136">source</a><a href="#method.load" class="anchor">§</a><h4 class="code-header">fn <a href="../field/trait.BitField.html#method.load" class="fn">load</a>&lt;M&gt;(&amp;self) -&gt; M<div class="where">where
    M: <a class="trait" href="../mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,</div></h4></section></summary><div class='docblock'>Loads the bits in the <code>self</code> region into a local value. <a href="../field/trait.BitField.html#method.load">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.store" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/field.rs.html#170-177">source</a><a href="#method.store" class="anchor">§</a><h4 class="code-header">fn <a href="../field/trait.BitField.html#method.store" class="fn">store</a>&lt;M&gt;(&amp;mut self, value: M)<div class="where">where
    M: <a class="trait" href="../mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,</div></h4></section></summary><div class='docblock'>Stores a sequence of bits from the user into the domain of <code>self</code>. <a href="../field/trait.BitField.html#method.store">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitOr%3CRhs%3E-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#58-71">source</a><a href="#impl-BitOr%3CRhs%3E-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitOr.html" title="trait core::ops::bit::BitOr">BitOr</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,
    <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;Rhs&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-3" class="associatedtype trait-impl"><a href="#associatedtype.Output-3" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitOr.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;</h4></section></summary><div class='docblock'>The resulting type after applying the <code>|</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.bitor" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#67-70">source</a><a href="#method.bitor" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitOr.html#tymethod.bitor" class="fn">bitor</a>(self, rhs: Rhs) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitOr.html#associatedtype.Output" title="type core::ops::bit::BitOr::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>|</code> operation. <a href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitOr.html#tymethod.bitor">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitOrAssign%3CRhs%3E-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#74-84">source</a><a href="#impl-BitOrAssign%3CRhs%3E-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,
    <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;Rhs&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.bitor_assign" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#81-83">source</a><a href="#method.bitor_assign" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign" class="fn">bitor_assign</a>(&amp;mut self, rhs: Rhs)</h4></section></summary><div class='docblock'>Performs the <code>|=</code> operation. <a href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitXor%3CRhs%3E-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#87-100">source</a><a href="#impl-BitXor%3CRhs%3E-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitXor.html" title="trait core::ops::bit::BitXor">BitXor</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,
    <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;Rhs&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-2" class="associatedtype trait-impl"><a href="#associatedtype.Output-2" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitXor.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;</h4></section></summary><div class='docblock'>The resulting type after applying the <code>^</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.bitxor" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#96-99">source</a><a href="#method.bitxor" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitXor.html#tymethod.bitxor" class="fn">bitxor</a>(self, rhs: Rhs) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitXor.html#associatedtype.Output" title="type core::ops::bit::BitXor::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>^</code> operation. <a href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitXor.html#tymethod.bitxor">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitXorAssign%3CRhs%3E-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#103-113">source</a><a href="#impl-BitXorAssign%3CRhs%3E-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,
    <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;Rhs&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.bitxor_assign" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#110-112">source</a><a href="#method.bitxor_assign" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign" class="fn">bitxor_assign</a>(&amp;mut self, rhs: Rhs)</h4></section></summary><div class='docblock'>Performs the <code>^=</code> operation. <a href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Borrow%3CBitSlice%3CO,+T%3E%3E-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#44-53">source</a><a href="#impl-Borrow%3CBitSlice%3CO,+T%3E%3E-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#50-52">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <a href="#" class="tooltip" data-notable-ty="&amp;BitSlice&lt;O, T&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BorrowMut%3CBitSlice%3CO,+T%3E%3E-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#56-65">source</a><a href="#impl-BorrowMut%3CBitSlice%3CO,+T%3E%3E-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#62-64">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <a href="#" class="tooltip" data-notable-ty="&amp;mut BitSlice&lt;O, T&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#67-93">source</a><a href="#impl-Clone-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#74-76">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; Self</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.81.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#79-92">source</a><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, other: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.81.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#292-305">source</a><a href="#impl-Debug-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#298-304">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.81.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#281-290">source</a><a href="#impl-Default-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#287-289">source</a><a href="#method.default" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; Self</h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/1.81.0/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Deref-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#116-127">source</a><a href="#impl-Deref-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Target" class="associatedtype trait-impl"><a href="#associatedtype.Target" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.Deref.html#associatedtype.Target" class="associatedtype">Target</a> = <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</h4></section></summary><div class='docblock'>The resulting type after dereferencing.</div></details><details class="toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#124-126">source</a><a href="#method.deref" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.Deref.html#tymethod.deref" class="fn">deref</a>(&amp;self) -&gt; &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a></h4></section></summary><div class='docblock'>Dereferences the value.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-DerefMut-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#130-139">source</a><a href="#impl-DerefMut-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.deref_mut" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#136-138">source</a><a href="#method.deref_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.DerefMut.html#tymethod.deref_mut" class="fn">deref_mut</a>(&amp;mut self) -&gt; &amp;mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a></h4></section></summary><div class='docblock'>Mutably dereferences the value.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Display-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#308-317">source</a><a href="#impl-Display-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#314-316">source</a><a href="#method.fmt-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Display.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.81.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Display.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Drop-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#141-153">source</a><a href="#impl-Drop-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#147-152">source</a><a href="#method.drop" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/ops/drop/trait.Drop.html#tymethod.drop" class="fn">drop</a>(&amp;mut self)</h4></section></summary><div class='docblock'>Executes the destructor for this type. <a href="https://doc.rust-lang.org/1.81.0/core/ops/drop/trait.Drop.html#tymethod.drop">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Extend%3C%26bool%3E-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/iter.rs.html#67-77">source</a><a href="#impl-Extend%3C%26bool%3E-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.extend-1" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/iter.rs.html#73-76">source</a><a href="#method.extend-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.Extend.html#tymethod.extend" class="fn">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>&gt;,</div></h4></section></summary><div class='docblock'>Extends a collection with the contents of an iterator. <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.Extend.html#tymethod.extend">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.extend_one-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/iter/traits/collect.rs.html#454">source</a><a href="#method.extend_one-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.Extend.html#method.extend_one" class="fn">extend_one</a>(&amp;mut self, item: A)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Extends a collection with exactly one element.</div></details><details class="toggle method-toggle" open><summary><section id="method.extend_reserve-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/iter/traits/collect.rs.html#462">source</a><a href="#method.extend_reserve-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.Extend.html#method.extend_reserve" class="fn">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Reserves capacity in a collection for the given number of additional elements. <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.Extend.html#method.extend_reserve">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Extend%3Cbool%3E-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/iter.rs.html#37-65">source</a><a href="#impl-Extend%3Cbool%3E-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.extend" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/iter.rs.html#43-64">source</a><a href="#method.extend" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.Extend.html#tymethod.extend" class="fn">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>&gt;,</div></h4></section></summary><div class='docblock'>Extends a collection with the contents of an iterator. <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.Extend.html#tymethod.extend">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.extend_one" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/iter/traits/collect.rs.html#454">source</a><a href="#method.extend_one" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.Extend.html#method.extend_one" class="fn">extend_one</a>(&amp;mut self, item: A)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Extends a collection with exactly one element.</div></details><details class="toggle method-toggle" open><summary><section id="method.extend_reserve" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/iter/traits/collect.rs.html#462">source</a><a href="#method.extend_reserve" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.Extend.html#method.extend_reserve" class="fn">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Reserves capacity in a collection for the given number of additional elements. <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.Extend.html#method.extend_reserve">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26BitSlice%3CO,+T%3E%3E-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#219-228">source</a><a href="#impl-From%3C%26BitSlice%3CO,+T%3E%3E-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#225-227">source</a><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(slice: &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26mut+BitSlice%3CO,+T%3E%3E-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#231-240">source</a><a href="#impl-From%3C%26mut+BitSlice%3CO,+T%3E%3E-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#237-239">source</a><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(slice: &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CBitBox%3CO,+T%3E%3E-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#243-252">source</a><a href="#impl-From%3CBitBox%3CO,+T%3E%3E-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#249-251">source</a><a href="#method.from-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(boxed: <a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;O, T&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CBitVec%3CO,+T%3E%3E-for-BitBox%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/boxed/traits.rs.html#213-222">source</a><a href="#impl-From%3CBitVec%3CO,+T%3E%3E-for-BitBox%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;&gt; for <a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/boxed/traits.rs.html#219-221">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(bv: <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromIterator%3C%26bool%3E-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/iter.rs.html#96-106">source</a><a href="#impl-FromIterator%3C%26bool%3E-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.FromIterator.html" title="trait core::iter::traits::collect::FromIterator">FromIterator</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_iter" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/iter.rs.html#102-105">source</a><a href="#method.from_iter" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter" class="fn">from_iter</a>&lt;I&gt;(iter: I) -&gt; Self<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>&gt;,</div></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromIterator%3Cbool%3E-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/iter.rs.html#79-94">source</a><a href="#impl-FromIterator%3Cbool%3E-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.FromIterator.html" title="trait core::iter::traits::collect::FromIterator">FromIterator</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_iter-1" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/iter.rs.html#85-93">source</a><a href="#method.from_iter-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter" class="fn">from_iter</a>&lt;I&gt;(iter: I) -&gt; Self<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>&gt;,</div></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Hash-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#383-393">source</a><a href="#impl-Hash-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#389-392">source</a><a href="#method.hash" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/hash/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;H&gt;(&amp;self, state: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut H</a>)<div class="where">where
    H: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,</div></h4></section></summary><div class='docblock'>Feeds this value into the given <a href="https://doc.rust-lang.org/1.81.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.81.0/core/hash/trait.Hash.html#tymethod.hash">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="src" href="https://doc.rust-lang.org/1.81.0/src/core/hash/mod.rs.html#238-240">source</a></span><a href="#method.hash_slice" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/hash/trait.Hash.html#method.hash_slice" class="fn">hash_slice</a>&lt;H&gt;(data: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.slice.html">[Self]</a>, state: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut H</a>)<div class="where">where
    H: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given <a href="https://doc.rust-lang.org/1.81.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.81.0/core/hash/trait.Hash.html#method.hash_slice">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Index%3CIdx%3E-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#156-168">source</a><a href="#impl-Index%3CIdx%3E-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T, Idx&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;Idx&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,
    <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;Idx&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-4" class="associatedtype trait-impl"><a href="#associatedtype.Output-4" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.81.0/core/ops/index/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; as <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;Idx&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class="toggle method-toggle" open><summary><section id="method.index" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#165-167">source</a><a href="#method.index" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/ops/index/trait.Index.html#tymethod.index" class="fn">index</a>(&amp;self, index: Idx) -&gt; &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.81.0/core/ops/index/trait.Index.html#tymethod.index">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IndexMut%3CIdx%3E-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#171-181">source</a><a href="#impl-IndexMut%3CIdx%3E-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T, Idx&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;Idx&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,
    <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;Idx&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.index_mut" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#178-180">source</a><a href="#method.index_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fn">index_mut</a>(&amp;mut self, index: Idx) -&gt; &amp;mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.81.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Into%3CVec%3CT%3E%3E-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#255-264">source</a><a href="#impl-Into%3CVec%3CT%3E%3E-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#261-263">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h4></section></summary><div class='docblock'>Converts this type into the (usually inferred) input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IntoIterator-for-%26BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/iter.rs.html#126-138">source</a><a href="#impl-IntoIterator-for-%26BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for &amp;'a <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: 'a + <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.IntoIter-2" class="associatedtype trait-impl"><a href="#associatedtype.IntoIter-2" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = &lt;&amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; as <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class="toggle" open><summary><section id="associatedtype.Item-2" class="associatedtype trait-impl"><a href="#associatedtype.Item-2" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;&amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; as <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a></h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="toggle method-toggle" open><summary><section id="method.into_iter-2" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/iter.rs.html#135-137">source</a><a href="#method.into_iter-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fn">into_iter</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'>Creates an iterator from a value. <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IntoIterator-for-%26mut+BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/iter.rs.html#141-153">source</a><a href="#impl-IntoIterator-for-%26mut+BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for &amp;'a mut <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: 'a + <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.IntoIter" class="associatedtype trait-impl"><a href="#associatedtype.IntoIter" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = &lt;&amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; as <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class="toggle" open><summary><section id="associatedtype.Item" class="associatedtype trait-impl"><a href="#associatedtype.Item" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;&amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; as <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a></h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="toggle method-toggle" open><summary><section id="method.into_iter" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/iter.rs.html#150-152">source</a><a href="#method.into_iter" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fn">into_iter</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'>Creates an iterator from a value. <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IntoIterator-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/iter.rs.html#108-123">source</a><a href="#impl-IntoIterator-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: 'static + <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: 'static + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.IntoIter-1" class="associatedtype trait-impl"><a href="#associatedtype.IntoIter-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = <a class="struct" href="struct.IntoIter.html" title="struct bitvec::vec::IntoIter">IntoIter</a>&lt;O, T&gt;</h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class="toggle" open><summary><section id="associatedtype.Item-1" class="associatedtype trait-impl"><a href="#associatedtype.Item-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="toggle method-toggle" open><summary><section id="method.into_iter-1" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/iter.rs.html#117-122">source</a><a href="#method.into_iter-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fn">into_iter</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'>Creates an iterator from a value. <a href="https://doc.rust-lang.org/1.81.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-LowerHex-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#332-341">source</a><a href="#impl-LowerHex-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.LowerHex.html" title="trait core::fmt::LowerHex">LowerHex</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-5" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#338-340">source</a><a href="#method.fmt-5" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.LowerHex.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.81.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.LowerHex.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Not-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#188-202">source</a><a href="#impl-Not-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.Not.html" title="trait core::ops::bit::Not">Not</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="docblock"><p>This implementation inverts all elements in the live buffer. You cannot rely
on the value of bits in the buffer that are outside the domain of
<code>BitVec::as_mit_bitslice</code>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-1" class="associatedtype trait-impl"><a href="#associatedtype.Output-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.Not.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;</h4></section></summary><div class='docblock'>The resulting type after applying the <code>!</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.not" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/ops.rs.html#196-201">source</a><a href="#method.not" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.Not.html#tymethod.not" class="fn">not</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.Not.html#associatedtype.Output" title="type core::ops::bit::Not::Output">Output</a></h4></section></summary><div class='docblock'>Performs the unary <code>!</code> operation. <a href="https://doc.rust-lang.org/1.81.0/core/ops/bit/trait.Not.html#tymethod.not">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Octal-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#344-353">source</a><a href="#impl-Octal-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Octal.html" title="trait core::fmt::Octal">Octal</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-2" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#350-352">source</a><a href="#method.fmt-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Octal.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.81.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Octal.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Ord-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#103-112">source</a><a href="#impl-Ord-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cmp" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#109-111">source</a><a href="#method.cmp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.Ord.html#tymethod.cmp" class="fn">cmp</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Self</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'>This method returns an <a href="https://doc.rust-lang.org/1.81.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.Ord.html#tymethod.cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.max" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/1.81.0/src/core/cmp.rs.html#855-857">source</a></span><a href="#method.max" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.Ord.html#method.max" class="fn">max</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the maximum of two values. <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.Ord.html#method.max">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.min" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/1.81.0/src/core/cmp.rs.html#876-878">source</a></span><a href="#method.min" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.Ord.html#method.min" class="fn">min</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the minimum of two values. <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.Ord.html#method.min">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clamp" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> · <a class="src" href="https://doc.rust-lang.org/1.81.0/src/core/cmp.rs.html#902-905">source</a></span><a href="#method.clamp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.Ord.html#method.clamp" class="fn">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>,</div></h4></section></summary><div class='docblock'>Restrict a value to a certain interval. <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.Ord.html#method.clamp">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitVec%3CO2,+T2%3E%3E-for-%26BitSlice%3CO1,+T1%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#129-140">source</a><a href="#impl-PartialEq%3CBitVec%3CO2,+T2%3E%3E-for-%26BitSlice%3CO1,+T1%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O2, T2&gt;&gt; for &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O1, T1&gt;<div class="where">where
    O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,
    T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#137-139">source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O2, T2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.81.0/src/core/cmp.rs.html#262">source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitVec%3CO2,+T2%3E%3E-for-%26mut+BitSlice%3CO1,+T1%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#143-154">source</a><a href="#impl-PartialEq%3CBitVec%3CO2,+T2%3E%3E-for-%26mut+BitSlice%3CO1,+T1%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O2, T2&gt;&gt; for &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O1, T1&gt;<div class="where">where
    O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,
    T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-2" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#151-153">source</a><a href="#method.eq-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O2, T2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.81.0/src/core/cmp.rs.html#262">source</a></span><a href="#method.ne-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitVec%3CO2,+T2%3E%3E-for-BitSlice%3CO1,+T1%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#115-126">source</a><a href="#impl-PartialEq%3CBitVec%3CO2,+T2%3E%3E-for-BitSlice%3CO1,+T1%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O2, T2&gt;&gt; for <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O1, T1&gt;<div class="where">where
    O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,
    T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-3" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#123-125">source</a><a href="#method.eq-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O2, T2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-3" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.81.0/src/core/cmp.rs.html#262">source</a></span><a href="#method.ne-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CRhs%3E-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#157-167">source</a><a href="#impl-PartialEq%3CRhs%3E-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,
    Rhs: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-1" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#164-166">source</a><a href="#method.eq-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.81.0/src/core/cmp.rs.html#262">source</a></span><a href="#method.ne-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitVec%3CO,+T%3E%3E-for-BitSlice%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#170-179">source</a><a href="#impl-PartialOrd%3CBitVec%3CO,+T%3E%3E-for-BitSlice%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;&gt; for <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#176-178">source</a><a href="#method.partial_cmp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.81.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.81.0/src/core/cmp.rs.html#1179">source</a></span><a href="#method.lt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.81.0/src/core/cmp.rs.html#1197">source</a></span><a href="#method.le" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.81.0/src/core/cmp.rs.html#1214">source</a></span><a href="#method.gt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.81.0/src/core/cmp.rs.html#1232">source</a></span><a href="#method.ge" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CRhs%3E-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#182-192">source</a><a href="#impl-PartialOrd%3CRhs%3E-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,
    Rhs: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp-1" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#189-191">source</a><a href="#method.partial_cmp-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.81.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.81.0/src/core/cmp.rs.html#1179">source</a></span><a href="#method.lt-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.81.0/src/core/cmp.rs.html#1197">source</a></span><a href="#method.le-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.81.0/src/core/cmp.rs.html#1214">source</a></span><a href="#method.gt-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.81.0/src/core/cmp.rs.html#1232">source</a></span><a href="#method.ge-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Pointer-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#355-368">source</a><a href="#impl-Pointer-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Pointer.html" title="trait core::fmt::Pointer">Pointer</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-4" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#361-367">source</a><a href="#method.fmt-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Pointer.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.81.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Pointer.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-TryFrom%3CVec%3CT%3E%3E-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#267-278">source</a><a href="#impl-TryFrom%3CVec%3CT%3E%3E-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#275-277">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(vec: <a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-UpperHex-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#371-380">source</a><a href="#impl-UpperHex-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.UpperHex.html" title="trait core::fmt::UpperHex">UpperHex</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-6" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#377-379">source</a><a href="#method.fmt-6" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.UpperHex.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.81.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.UpperHex.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Write-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/field/io.rs.html#104-122">source</a><a href="#impl-Write-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,
    <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</div></h3></section></summary><div class="docblock"><p>Mirrors the implementation on <code>Vec&lt;u8&gt;</code> (found <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-Write">here</a>).</p>
<p>The implementation copies bytes from <code>buf</code> into the tail end of <code>self</code>. The
performance characteristics of this operation are dependent on the type
parameters of the <code>BitVec</code>, and the position of its tail.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.write" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/field/io.rs.html#111-115">source</a><a href="#method.write" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/std/io/trait.Write.html#tymethod.write" class="fn">write</a>(&amp;mut self, buf: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]) -&gt; <a class="type" href="https://doc.rust-lang.org/1.81.0/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class='docblock'>Write a buffer into this writer, returning how many bytes were written. <a href="https://doc.rust-lang.org/1.81.0/std/io/trait.Write.html#tymethod.write">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.flush" class="method trait-impl"><a class="src rightside" href="../../src/bitvec/field/io.rs.html#119-121">source</a><a href="#method.flush" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/std/io/trait.Write.html#tymethod.flush" class="fn">flush</a>(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.81.0/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class='docblock'>Flush this output stream, ensuring that all intermediately buffered
contents reach their destination. <a href="https://doc.rust-lang.org/1.81.0/std/io/trait.Write.html#tymethod.flush">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.write_vectored" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span> · <a class="src" href="https://doc.rust-lang.org/1.81.0/src/std/io/mod.rs.html#1614">source</a></span><a href="#method.write_vectored" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/std/io/trait.Write.html#method.write_vectored" class="fn">write_vectored</a>(&amp;mut self, bufs: &amp;[<a class="struct" href="https://doc.rust-lang.org/1.81.0/std/io/struct.IoSlice.html" title="struct std::io::IoSlice">IoSlice</a>&lt;'_&gt;]) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>, <a class="struct" href="https://doc.rust-lang.org/1.81.0/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Like <a href="https://doc.rust-lang.org/1.81.0/std/io/trait.Write.html#tymethod.write" title="method std::io::Write::write"><code>write</code></a>, except that it writes from a slice of buffers. <a href="https://doc.rust-lang.org/1.81.0/std/io/trait.Write.html#method.write_vectored">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_write_vectored" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/std/io/mod.rs.html#1629">source</a><a href="#method.is_write_vectored" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/std/io/trait.Write.html#method.is_write_vectored" class="fn">is_write_vectored</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>can_vector</code>)</span></div></span><div class='docblock'>Determines if this <code>Write</code>r has an efficient <a href="https://doc.rust-lang.org/1.81.0/std/io/trait.Write.html#method.write_vectored" title="method std::io::Write::write_vectored"><code>write_vectored</code></a>
implementation. <a href="https://doc.rust-lang.org/1.81.0/std/io/trait.Write.html#method.is_write_vectored">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.write_all" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.81.0/src/std/io/mod.rs.html#1691">source</a></span><a href="#method.write_all" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/std/io/trait.Write.html#method.write_all" class="fn">write_all</a>(&amp;mut self, buf: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.81.0/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Attempts to write an entire buffer into this writer. <a href="https://doc.rust-lang.org/1.81.0/std/io/trait.Write.html#method.write_all">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.write_all_vectored" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/std/io/mod.rs.html#1753">source</a><a href="#method.write_all_vectored" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/std/io/trait.Write.html#method.write_all_vectored" class="fn">write_all_vectored</a>(&amp;mut self, bufs: &amp;mut [<a class="struct" href="https://doc.rust-lang.org/1.81.0/std/io/struct.IoSlice.html" title="struct std::io::IoSlice">IoSlice</a>&lt;'_&gt;]) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.81.0/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>write_all_vectored</code>)</span></div></span><div class='docblock'>Attempts to write multiple buffers into this writer. <a href="https://doc.rust-lang.org/1.81.0/std/io/trait.Write.html#method.write_all_vectored">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.write_fmt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.81.0/src/std/io/mod.rs.html#1806">source</a></span><a href="#method.write_fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/std/io/trait.Write.html#method.write_fmt" class="fn">write_fmt</a>(&amp;mut self, fmt: <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/fmt/struct.Arguments.html" title="struct core::fmt::Arguments">Arguments</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.81.0/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Writes a formatted string into this writer, returning any error
encountered. <a href="https://doc.rust-lang.org/1.81.0/std/io/trait.Write.html#method.write_fmt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.by_ref" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.81.0/src/std/io/mod.rs.html#1866-1868">source</a></span><a href="#method.by_ref" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/std/io/trait.Write.html#method.by_ref" class="fn">by_ref</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut Self</a><div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Creates a “by reference” adapter for this instance of <code>Write</code>. <a href="https://doc.rust-lang.org/1.81.0/std/io/trait.Write.html#method.by_ref">Read more</a></div></details></div></details><section id="impl-Eq-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#95-100">source</a><a href="#impl-Eq-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section><section id="impl-Send-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#395-400">source</a><a href="#impl-Send-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section><section id="impl-Sync-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#402-407">source</a><a href="#impl-Sync-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section><section id="impl-Unpin-for-BitVec%3CO,+T%3E" class="impl"><a class="src rightside" href="../../src/bitvec/vec/traits.rs.html#409-414">source</a><a href="#impl-Unpin-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,
    T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</div></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-BitVec%3CO,+T%3E" class="impl"><a href="#impl-Freeze-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;</h3></section><section id="impl-RefUnwindSafe-for-BitVec%3CO,+T%3E" class="impl"><a href="#impl-RefUnwindSafe-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,
    T: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</div></h3></section><section id="impl-UnwindSafe-for-BitVec%3CO,+T%3E" class="impl"><a href="#impl-UnwindSafe-for-BitVec%3CO,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<div class="where">where
    O: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,
    T: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</div></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.81.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/borrow.rs.html#209">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/borrow.rs.html#211">source</a><a href="#method.borrow-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/borrow.rs.html#217">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/borrow.rs.html#218">source</a><a href="#method.borrow_mut-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/clone.rs.html#271">source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/clone.rs.html#272">source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">default unsafe fn <a href="https://doc.rust-lang.org/1.81.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dst: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.pointer.html">*mut T</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dst</code>. <a href="https://doc.rust-lang.org/1.81.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Conv-for-T" class="impl"><a class="src rightside" href="../../src/tap/conv.rs.html#58">source</a><a href="#impl-Conv-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../tap/conv/trait.Conv.html" title="trait tap::conv::Conv">Conv</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.conv" class="method trait-impl"><a class="src rightside" href="../../src/tap/conv.rs.html#49-52">source</a><a href="#method.conv" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/conv/trait.Conv.html#method.conv" class="fn">conv</a>&lt;T&gt;(self) -&gt; T<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h4></section></summary><div class='docblock'>Converts <code>self</code> into <code>T</code> using <code>Into&lt;T&gt;</code>. <a href="../../tap/conv/trait.Conv.html#method.conv">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Conv-for-T-1" class="impl"><a class="src rightside" href="../../src/wyz/conv.rs.html#107">source</a><a href="#impl-Conv-for-T-1" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../wyz/conv/trait.Conv.html" title="trait wyz::conv::Conv">Conv</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.conv-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/conv.rs.html#101-102">source</a><a href="#method.conv-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/conv/trait.Conv.html#method.conv" class="fn">conv</a>&lt;T&gt;(self) -&gt; T<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h4></section></summary><div class='docblock'>Converts <code>self</code> into a target type. <a href="../../wyz/conv/trait.Conv.html#method.conv">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-FmtForward-for-T" class="impl"><a class="src rightside" href="../../src/wyz/fmt.rs.html#93">source</a><a href="#impl-FmtForward-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../wyz/fmt/trait.FmtForward.html" title="trait wyz::fmt::FmtForward">FmtForward</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt_binary" class="method trait-impl"><a class="src rightside" href="../../src/wyz/fmt.rs.html#39-40">source</a><a href="#method.fmt_binary" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_binary" class="fn">fmt_binary</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtBinary.html" title="struct wyz::fmt::FmtBinary">FmtBinary</a>&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Binary.html" title="trait core::fmt::Binary">Binary</a>,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>Binary</code> implementation when <code>Debug</code>-formatted.</div></details><details class="toggle method-toggle" open><summary><section id="method.fmt_display" class="method trait-impl"><a class="src rightside" href="../../src/wyz/fmt.rs.html#46-47">source</a><a href="#method.fmt_display" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_display" class="fn">fmt_display</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtDisplay.html" title="struct wyz::fmt::FmtDisplay">FmtDisplay</a>&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a>,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>Display</code> implementation when
<code>Debug</code>-formatted.</div></details><details class="toggle method-toggle" open><summary><section id="method.fmt_lower_exp" class="method trait-impl"><a class="src rightside" href="../../src/wyz/fmt.rs.html#53-54">source</a><a href="#method.fmt_lower_exp" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_lower_exp" class="fn">fmt_lower_exp</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtLowerExp.html" title="struct wyz::fmt::FmtLowerExp">FmtLowerExp</a>&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.LowerExp.html" title="trait core::fmt::LowerExp">LowerExp</a>,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>LowerExp</code> implementation when
<code>Debug</code>-formatted.</div></details><details class="toggle method-toggle" open><summary><section id="method.fmt_lower_hex" class="method trait-impl"><a class="src rightside" href="../../src/wyz/fmt.rs.html#60-61">source</a><a href="#method.fmt_lower_hex" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_lower_hex" class="fn">fmt_lower_hex</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtLowerHex.html" title="struct wyz::fmt::FmtLowerHex">FmtLowerHex</a>&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.LowerHex.html" title="trait core::fmt::LowerHex">LowerHex</a>,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>LowerHex</code> implementation when
<code>Debug</code>-formatted.</div></details><details class="toggle method-toggle" open><summary><section id="method.fmt_octal" class="method trait-impl"><a class="src rightside" href="../../src/wyz/fmt.rs.html#66-67">source</a><a href="#method.fmt_octal" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_octal" class="fn">fmt_octal</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtOctal.html" title="struct wyz::fmt::FmtOctal">FmtOctal</a>&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Octal.html" title="trait core::fmt::Octal">Octal</a>,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>Octal</code> implementation when <code>Debug</code>-formatted.</div></details><details class="toggle method-toggle" open><summary><section id="method.fmt_pointer" class="method trait-impl"><a class="src rightside" href="../../src/wyz/fmt.rs.html#73-74">source</a><a href="#method.fmt_pointer" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_pointer" class="fn">fmt_pointer</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtPointer.html" title="struct wyz::fmt::FmtPointer">FmtPointer</a>&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Pointer.html" title="trait core::fmt::Pointer">Pointer</a>,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>Pointer</code> implementation when
<code>Debug</code>-formatted.</div></details><details class="toggle method-toggle" open><summary><section id="method.fmt_upper_exp" class="method trait-impl"><a class="src rightside" href="../../src/wyz/fmt.rs.html#80-81">source</a><a href="#method.fmt_upper_exp" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_upper_exp" class="fn">fmt_upper_exp</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtUpperExp.html" title="struct wyz::fmt::FmtUpperExp">FmtUpperExp</a>&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.UpperExp.html" title="trait core::fmt::UpperExp">UpperExp</a>,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>UpperExp</code> implementation when
<code>Debug</code>-formatted.</div></details><details class="toggle method-toggle" open><summary><section id="method.fmt_upper_hex" class="method trait-impl"><a class="src rightside" href="../../src/wyz/fmt.rs.html#87-88">source</a><a href="#method.fmt_upper_hex" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_upper_hex" class="fn">fmt_upper_hex</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtUpperHex.html" title="struct wyz::fmt::FmtUpperHex">FmtUpperHex</a>&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.UpperHex.html" title="trait core::fmt::UpperHex">UpperHex</a>,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>UpperHex</code> implementation when
<code>Debug</code>-formatted.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/convert/mod.rs.html#765">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/convert/mod.rs.html#768">source</a><a href="#method.from-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/convert/mod.rs.html#748-750">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/convert/mod.rs.html#758">source</a><a href="#method.into-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Pipe-for-T" class="impl"><a class="src rightside" href="../../src/tap/pipe.rs.html#234">source</a><a href="#impl-Pipe-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../tap/pipe/trait.Pipe.html" title="trait tap::pipe::Pipe">Pipe</a> for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.pipe" class="method trait-impl"><a class="src rightside" href="../../src/tap/pipe.rs.html#73-76">source</a><a href="#method.pipe" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe" class="fn">pipe</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(Self) -&gt; R) -&gt; R<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Pipes by value. This is generally the method you want to use. <a href="../../tap/pipe/trait.Pipe.html#method.pipe">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_ref" class="method trait-impl"><a class="src rightside" href="../../src/tap/pipe.rs.html#97-99">source</a><a href="#method.pipe_ref" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_ref" class="fn">pipe_ref</a>&lt;'a, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a Self</a>) -&gt; R) -&gt; R<div class="where">where
    R: 'a,</div></h4></section></summary><div class='docblock'>Borrows <code>self</code> and passes that borrow into the pipe function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_ref">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_ref_mut" class="method trait-impl"><a class="src rightside" href="../../src/tap/pipe.rs.html#122-127">source</a><a href="#method.pipe_ref_mut" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_ref_mut" class="fn">pipe_ref_mut</a>&lt;'a, R&gt;(&amp;'a mut self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a mut Self</a>) -&gt; R) -&gt; R<div class="where">where
    R: 'a,</div></h4></section></summary><div class='docblock'>Mutably borrows <code>self</code> and passes that borrow into the pipe function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_ref_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_borrow" class="method trait-impl"><a class="src rightside" href="../../src/tap/pipe.rs.html#145-149">source</a><a href="#method.pipe_borrow" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_borrow" class="fn">pipe_borrow</a>&lt;'a, B, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a B</a>) -&gt; R) -&gt; R<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;B&gt;,
    B: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    R: 'a,</div></h4></section></summary><div class='docblock'>Borrows <code>self</code>, then passes <code>self.borrow()</code> into the pipe function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_borrow">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_borrow_mut" class="method trait-impl"><a class="src rightside" href="../../src/tap/pipe.rs.html#169-176">source</a><a href="#method.pipe_borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_borrow_mut" class="fn">pipe_borrow_mut</a>&lt;'a, B, R&gt;(
    &amp;'a mut self,
    func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a mut B</a>) -&gt; R,
) -&gt; R<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;B&gt;,
    B: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    R: 'a,</div></h4></section></summary><div class='docblock'>Mutably borrows <code>self</code>, then passes <code>self.borrow_mut()</code> into the pipe
function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_borrow_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_as_ref" class="method trait-impl"><a class="src rightside" href="../../src/tap/pipe.rs.html#183-187">source</a><a href="#method.pipe_as_ref" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_as_ref" class="fn">pipe_as_ref</a>&lt;'a, U, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a U</a>) -&gt; R) -&gt; R<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;U&gt;,
    U: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    R: 'a,</div></h4></section></summary><div class='docblock'>Borrows <code>self</code>, then passes <code>self.as_ref()</code> into the pipe function.</div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_as_mut" class="method trait-impl"><a class="src rightside" href="../../src/tap/pipe.rs.html#195-202">source</a><a href="#method.pipe_as_mut" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_as_mut" class="fn">pipe_as_mut</a>&lt;'a, U, R&gt;(&amp;'a mut self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a mut U</a>) -&gt; R) -&gt; R<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;U&gt;,
    U: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    R: 'a,</div></h4></section></summary><div class='docblock'>Mutably borrows <code>self</code>, then passes <code>self.as_mut()</code> into the pipe
function.</div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_deref" class="method trait-impl"><a class="src rightside" href="../../src/tap/pipe.rs.html#209-213">source</a><a href="#method.pipe_deref" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_deref" class="fn">pipe_deref</a>&lt;'a, T, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a T</a>) -&gt; R) -&gt; R<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = T&gt;,
    T: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    R: 'a,</div></h4></section></summary><div class='docblock'>Borrows <code>self</code>, then passes <code>self.deref()</code> into the pipe function.</div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_deref_mut" class="method trait-impl"><a class="src rightside" href="../../src/tap/pipe.rs.html#221-228">source</a><a href="#method.pipe_deref_mut" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_deref_mut" class="fn">pipe_deref_mut</a>&lt;'a, T, R&gt;(
    &amp;'a mut self,
    func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a mut T</a>) -&gt; R,
) -&gt; R<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>&lt;Target = T&gt; + <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,
    T: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    R: 'a,</div></h4></section></summary><div class='docblock'>Mutably borrows <code>self</code>, then passes <code>self.deref_mut()</code> into the pipe
function.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Pipe-for-T-1" class="impl"><a class="src rightside" href="../../src/wyz/pipe.rs.html#345">source</a><a href="#impl-Pipe-for-T-1" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../wyz/pipe/trait.Pipe.html" title="trait wyz::pipe::Pipe">Pipe</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.pipe-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/pipe.rs.html#89-90">source</a><a href="#method.pipe-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/pipe/trait.Pipe.html#method.pipe" class="fn">pipe</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(Self) -&gt; R) -&gt; R</h4></section></summary><div class='docblock'>Pipes a value into a function that cannot ordinarily be called in suffix
position. <a href="../../wyz/pipe/trait.Pipe.html#method.pipe">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-PipeAsRef-for-T" class="impl"><a class="src rightside" href="../../src/wyz/pipe.rs.html#354">source</a><a href="#impl-PipeAsRef-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../wyz/pipe/trait.PipeAsRef.html" title="trait wyz::pipe::PipeAsRef">PipeAsRef</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.pipe_as_ref-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/pipe.rs.html#254-258">source</a><a href="#method.pipe_as_ref-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/pipe/trait.PipeAsRef.html#method.pipe_as_ref" class="fn">pipe_as_ref</a>&lt;'a, T, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a T</a>) -&gt; R) -&gt; R<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;T&gt;,
    T: 'a,
    R: 'a,</div></h4></section></summary><div class='docblock'>Pipes a trait borrow into a function that cannot normally be called in
suffix position. <a href="../../wyz/pipe/trait.PipeAsRef.html#method.pipe_as_ref">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_as_mut-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/pipe.rs.html#278-285">source</a><a href="#method.pipe_as_mut-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/pipe/trait.PipeAsRef.html#method.pipe_as_mut" class="fn">pipe_as_mut</a>&lt;'a, T, R&gt;(&amp;'a mut self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a mut T</a>) -&gt; R) -&gt; R<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;T&gt;,
    T: 'a,
    R: 'a,</div></h4></section></summary><div class='docblock'>Pipes a trait mutable borrow into a function that cannot normally be
called in suffix position. <a href="../../wyz/pipe/trait.PipeAsRef.html#method.pipe_as_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-PipeBorrow-for-T" class="impl"><a class="src rightside" href="../../src/wyz/pipe.rs.html#351">source</a><a href="#impl-PipeBorrow-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../wyz/pipe/trait.PipeBorrow.html" title="trait wyz::pipe::PipeBorrow">PipeBorrow</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.pipe_borrow-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/pipe.rs.html#191-195">source</a><a href="#method.pipe_borrow-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/pipe/trait.PipeBorrow.html#method.pipe_borrow" class="fn">pipe_borrow</a>&lt;'a, T, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a T</a>) -&gt; R) -&gt; R<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt;,
    T: 'a,
    R: 'a,</div></h4></section></summary><div class='docblock'>Pipes a trait borrow into a function that cannot normally be called in
suffix position. <a href="../../wyz/pipe/trait.PipeBorrow.html#method.pipe_borrow">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_borrow_mut-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/pipe.rs.html#224-231">source</a><a href="#method.pipe_borrow_mut-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/pipe/trait.PipeBorrow.html#method.pipe_borrow_mut" class="fn">pipe_borrow_mut</a>&lt;'a, T, R&gt;(
    &amp;'a mut self,
    func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a mut T</a>) -&gt; R,
) -&gt; R<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt;,
    T: 'a,
    R: 'a,</div></h4></section></summary><div class='docblock'>Pipes a trait mutable borrow into a function that cannot normally be
called in suffix position. <a href="../../wyz/pipe/trait.PipeBorrow.html#method.pipe_borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-PipeDeref-for-T" class="impl"><a class="src rightside" href="../../src/wyz/pipe.rs.html#357">source</a><a href="#impl-PipeDeref-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../wyz/pipe/trait.PipeDeref.html" title="trait wyz::pipe::PipeDeref">PipeDeref</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.pipe_deref-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/pipe.rs.html#307-313">source</a><a href="#method.pipe_deref-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/pipe/trait.PipeDeref.html#method.pipe_deref" class="fn">pipe_deref</a>&lt;'a, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a>) -&gt; R) -&gt; R<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,
    R: 'a,</div></h4></section></summary><div class='docblock'>Pipes a dereference into a function that cannot normally be called in
suffix position. <a href="../../wyz/pipe/trait.PipeDeref.html#method.pipe_deref">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_deref_mut-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/pipe.rs.html#333-339">source</a><a href="#method.pipe_deref_mut-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/pipe/trait.PipeDeref.html#method.pipe_deref_mut" class="fn">pipe_deref_mut</a>&lt;'a, R&gt;(
    &amp;'a mut self,
    func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a>) -&gt; R,
) -&gt; R<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>,
    R: 'a,</div></h4></section></summary><div class='docblock'>Pipes a mutable dereference into a function that cannot normally be
called in suffix position. <a href="../../wyz/pipe/trait.PipeDeref.html#method.pipe_deref_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-PipeRef-for-T" class="impl"><a class="src rightside" href="../../src/wyz/pipe.rs.html#348">source</a><a href="#impl-PipeRef-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../wyz/pipe/trait.PipeRef.html" title="trait wyz::pipe::PipeRef">PipeRef</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.pipe_ref-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/pipe.rs.html#130-131">source</a><a href="#method.pipe_ref-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/pipe/trait.PipeRef.html#method.pipe_ref" class="fn">pipe_ref</a>&lt;'a, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a Self</a>) -&gt; R) -&gt; R<div class="where">where
    R: 'a,</div></h4></section></summary><div class='docblock'>Pipes a reference into a function that cannot ordinarily be called in
suffix position. <a href="../../wyz/pipe/trait.PipeRef.html#method.pipe_ref">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_mut" class="method trait-impl"><a class="src rightside" href="../../src/wyz/pipe.rs.html#158-159">source</a><a href="#method.pipe_mut" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/pipe/trait.PipeRef.html#method.pipe_mut" class="fn">pipe_mut</a>&lt;'a, R&gt;(&amp;'a mut self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a mut Self</a>) -&gt; R) -&gt; R<div class="where">where
    R: 'a,</div></h4></section></summary><div class='docblock'>Pipes a mutable reference into a function that cannot ordinarily be
called in suffix position. <a href="../../wyz/pipe/trait.PipeRef.html#method.pipe_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Tap-for-T" class="impl"><a class="src rightside" href="../../src/tap/tap.rs.html#329">source</a><a href="#impl-Tap-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../tap/tap/trait.Tap.html" title="trait tap::tap::Tap">Tap</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.tap" class="method trait-impl"><a class="src rightside" href="../../src/tap/tap.rs.html#78">source</a><a href="#method.tap" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap" class="fn">tap</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Self</a>)) -&gt; Self</h4></section></summary><div class='docblock'>Immutable access to a value. <a href="../../tap/tap/trait.Tap.html#method.tap">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_mut" class="method trait-impl"><a class="src rightside" href="../../src/tap/tap.rs.html#116">source</a><a href="#method.tap_mut" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_mut" class="fn">tap_mut</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut Self</a>)) -&gt; Self</h4></section></summary><div class='docblock'>Mutable access to a value. <a href="../../tap/tap/trait.Tap.html#method.tap_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_borrow" class="method trait-impl"><a class="src rightside" href="../../src/tap/tap.rs.html#129-132">source</a><a href="#method.tap_borrow" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_borrow" class="fn">tap_borrow</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;B</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;B&gt;,
    B: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Immutable access to the <code>Borrow&lt;B&gt;</code> of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_borrow">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_borrow_mut" class="method trait-impl"><a class="src rightside" href="../../src/tap/tap.rs.html#146-149">source</a><a href="#method.tap_borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_mut" class="fn">tap_borrow_mut</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut B</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;B&gt;,
    B: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Mutable access to the <code>BorrowMut&lt;B&gt;</code> of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_ref" class="method trait-impl"><a class="src rightside" href="../../src/tap/tap.rs.html#163-166">source</a><a href="#method.tap_ref" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_ref" class="fn">tap_ref</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;R</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;R&gt;,
    R: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Immutable access to the <code>AsRef&lt;R&gt;</code> view of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_ref">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_ref_mut" class="method trait-impl"><a class="src rightside" href="../../src/tap/tap.rs.html#180-183">source</a><a href="#method.tap_ref_mut" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_ref_mut" class="fn">tap_ref_mut</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut R</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;R&gt;,
    R: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Mutable access to the <code>AsMut&lt;R&gt;</code> view of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_ref_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_deref" class="method trait-impl"><a class="src rightside" href="../../src/tap/tap.rs.html#197-200">source</a><a href="#method.tap_deref" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_deref" class="fn">tap_deref</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;T</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = T&gt;,
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Immutable access to the <code>Deref::Target</code> of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_deref">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_deref_mut" class="method trait-impl"><a class="src rightside" href="../../src/tap/tap.rs.html#214-217">source</a><a href="#method.tap_deref_mut" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_deref_mut" class="fn">tap_deref_mut</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut T</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>&lt;Target = T&gt; + <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Mutable access to the <code>Deref::Target</code> of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_deref_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_dbg" class="method trait-impl"><a class="src rightside" href="../../src/tap/tap.rs.html#227">source</a><a href="#method.tap_dbg" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_dbg" class="fn">tap_dbg</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Self</a>)) -&gt; Self</h4></section></summary><div class='docblock'>Calls <code>.tap()</code> only in debug builds, and is erased in release builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_mut_dbg" class="method trait-impl"><a class="src rightside" href="../../src/tap/tap.rs.html#237">source</a><a href="#method.tap_mut_dbg" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_mut_dbg" class="fn">tap_mut_dbg</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut Self</a>)) -&gt; Self</h4></section></summary><div class='docblock'>Calls <code>.tap_mut()</code> only in debug builds, and is erased in release
builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_borrow_dbg" class="method trait-impl"><a class="src rightside" href="../../src/tap/tap.rs.html#247-250">source</a><a href="#method.tap_borrow_dbg" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_dbg" class="fn">tap_borrow_dbg</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;B</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;B&gt;,
    B: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Calls <code>.tap_borrow()</code> only in debug builds, and is erased in release
builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_borrow_mut_dbg" class="method trait-impl"><a class="src rightside" href="../../src/tap/tap.rs.html#261-264">source</a><a href="#method.tap_borrow_mut_dbg" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_mut_dbg" class="fn">tap_borrow_mut_dbg</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut B</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;B&gt;,
    B: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Calls <code>.tap_borrow_mut()</code> only in debug builds, and is erased in release
builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_ref_dbg" class="method trait-impl"><a class="src rightside" href="../../src/tap/tap.rs.html#275-278">source</a><a href="#method.tap_ref_dbg" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_ref_dbg" class="fn">tap_ref_dbg</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;R</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;R&gt;,
    R: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Calls <code>.tap_ref()</code> only in debug builds, and is erased in release
builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_ref_mut_dbg" class="method trait-impl"><a class="src rightside" href="../../src/tap/tap.rs.html#289-292">source</a><a href="#method.tap_ref_mut_dbg" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_ref_mut_dbg" class="fn">tap_ref_mut_dbg</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut R</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;R&gt;,
    R: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Calls <code>.tap_ref_mut()</code> only in debug builds, and is erased in release
builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_deref_dbg" class="method trait-impl"><a class="src rightside" href="../../src/tap/tap.rs.html#303-306">source</a><a href="#method.tap_deref_dbg" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_deref_dbg" class="fn">tap_deref_dbg</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;T</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = T&gt;,
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Calls <code>.tap_deref()</code> only in debug builds, and is erased in release
builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_deref_mut_dbg" class="method trait-impl"><a class="src rightside" href="../../src/tap/tap.rs.html#317-320">source</a><a href="#method.tap_deref_mut_dbg" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_deref_mut_dbg" class="fn">tap_deref_mut_dbg</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut T</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>&lt;Target = T&gt; + <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Calls <code>.tap_deref_mut()</code> only in debug builds, and is erased in release
builds.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Tap-for-T-1" class="impl"><a class="src rightside" href="../../src/wyz/tap.rs.html#340">source</a><a href="#impl-Tap-for-T-1" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../wyz/tap/trait.Tap.html" title="trait wyz::tap::Tap">Tap</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.tap-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/tap.rs.html#278-281">source</a><a href="#method.tap-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/tap/trait.Tap.html#method.tap" class="fn">tap</a>&lt;F, R&gt;(self, func: F) -&gt; Self<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Self</a>) -&gt; R,</div></h4></section></summary><div class='docblock'>Provides immutable access for inspection. <a href="../../wyz/tap/trait.Tap.html#method.tap">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_dbg-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/tap.rs.html#290-293">source</a><a href="#method.tap_dbg-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/tap/trait.Tap.html#method.tap_dbg" class="fn">tap_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Self</a>) -&gt; R,</div></h4></section></summary><div class='docblock'>Calls <code>tap</code> in debug builds, and does nothing in release builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_mut-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/tap.rs.html#316-319">source</a><a href="#method.tap_mut-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/tap/trait.Tap.html#method.tap_mut" class="fn">tap_mut</a>&lt;F, R&gt;(self, func: F) -&gt; Self<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut Self</a>) -&gt; R,</div></h4></section></summary><div class='docblock'>Provides mutable access for modification. <a href="../../wyz/tap/trait.Tap.html#method.tap_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_mut_dbg-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/tap.rs.html#328-331">source</a><a href="#method.tap_mut_dbg-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/tap/trait.Tap.html#method.tap_mut_dbg" class="fn">tap_mut_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut Self</a>) -&gt; R,</div></h4></section></summary><div class='docblock'>Calls <code>tap_mut</code> in debug builds, and does nothing in release builds.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TapAsRef%3CU%3E-for-T" class="impl"><a class="src rightside" href="../../src/wyz/tap.rs.html#560">source</a><a href="#impl-TapAsRef%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../../wyz/tap/trait.TapAsRef.html" title="trait wyz::tap::TapAsRef">TapAsRef</a>&lt;U&gt; for T<div class="where">where
    U: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.tap_ref-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/tap.rs.html#512-515">source</a><a href="#method.tap_ref-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/tap/trait.TapAsRef.html#method.tap_ref" class="fn">tap_ref</a>&lt;F, R&gt;(self, func: F) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;T&gt;,
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;T</a>) -&gt; R,</div></h4></section></summary><div class='docblock'>Provides immutable access to the reference for inspection.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_ref_dbg-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/tap.rs.html#524-527">source</a><a href="#method.tap_ref_dbg-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/tap/trait.TapAsRef.html#method.tap_ref_dbg" class="fn">tap_ref_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;T&gt;,
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;T</a>) -&gt; R,</div></h4></section></summary><div class='docblock'>Calls <code>tap_ref</code> in debug builds, and does nothing in release builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_ref_mut-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/tap.rs.html#536-539">source</a><a href="#method.tap_ref_mut-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/tap/trait.TapAsRef.html#method.tap_ref_mut" class="fn">tap_ref_mut</a>&lt;F, R&gt;(self, func: F) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;T&gt;,
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut T</a>) -&gt; R,</div></h4></section></summary><div class='docblock'>Provides mutable access to the reference for modification.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_ref_mut_dbg-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/tap.rs.html#548-551">source</a><a href="#method.tap_ref_mut_dbg-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/tap/trait.TapAsRef.html#method.tap_ref_mut_dbg" class="fn">tap_ref_mut_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;T&gt;,
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut T</a>) -&gt; R,</div></h4></section></summary><div class='docblock'>Calls <code>tap_ref_mut</code> in debug builds, and does nothing in release builds.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TapBorrow%3CU%3E-for-T" class="impl"><a class="src rightside" href="../../src/wyz/tap.rs.html#438">source</a><a href="#impl-TapBorrow%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../../wyz/tap/trait.TapBorrow.html" title="trait wyz::tap::TapBorrow">TapBorrow</a>&lt;U&gt; for T<div class="where">where
    U: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.tap_borrow-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/tap.rs.html#385-389">source</a><a href="#method.tap_borrow-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/tap/trait.TapBorrow.html#method.tap_borrow" class="fn">tap_borrow</a>&lt;F, R&gt;(self, func: F) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt;,
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;T</a>) -&gt; R,</div></h4></section></summary><div class='docblock'>Provides immutable access to the borrow for inspection. <a href="../../wyz/tap/trait.TapBorrow.html#method.tap_borrow">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_borrow_dbg-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/tap.rs.html#398-402">source</a><a href="#method.tap_borrow_dbg-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/tap/trait.TapBorrow.html#method.tap_borrow_dbg" class="fn">tap_borrow_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt;,
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;T</a>) -&gt; R,</div></h4></section></summary><div class='docblock'>Calls <code>tap_borrow</code> in debug builds, and does nothing in release builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_borrow_mut-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/tap.rs.html#411-415">source</a><a href="#method.tap_borrow_mut-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/tap/trait.TapBorrow.html#method.tap_borrow_mut" class="fn">tap_borrow_mut</a>&lt;F, R&gt;(self, func: F) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt;,
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut T</a>) -&gt; R,</div></h4></section></summary><div class='docblock'>Provides mutable access to the borrow for modification.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_borrow_mut_dbg-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/tap.rs.html#425-429">source</a><a href="#method.tap_borrow_mut_dbg-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/tap/trait.TapBorrow.html#method.tap_borrow_mut_dbg" class="fn">tap_borrow_mut_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt;,
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut T</a>) -&gt; R,</div></h4></section></summary><div class='docblock'>Calls <code>tap_borrow_mut</code> in debug builds, and does nothing in release
builds.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TapDeref-for-T" class="impl"><a class="src rightside" href="../../src/wyz/tap.rs.html#636">source</a><a href="#impl-TapDeref-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../wyz/tap/trait.TapDeref.html" title="trait wyz::tap::TapDeref">TapDeref</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.tap_deref-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/tap.rs.html#589-592">source</a><a href="#method.tap_deref-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/tap/trait.TapDeref.html#method.tap_deref" class="fn">tap_deref</a>&lt;F, R&gt;(self, func: F) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a>) -&gt; R,</div></h4></section></summary><div class='docblock'>Immutably dereferences <code>self</code> for inspection.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_deref_dbg-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/tap.rs.html#600-603">source</a><a href="#method.tap_deref_dbg-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/tap/trait.TapDeref.html#method.tap_deref_dbg" class="fn">tap_deref_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a>) -&gt; R,</div></h4></section></summary><div class='docblock'>Calls <code>tap_deref</code> in debug builds, and does nothing in release builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_deref_mut-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/tap.rs.html#612-615">source</a><a href="#method.tap_deref_mut-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/tap/trait.TapDeref.html#method.tap_deref_mut" class="fn">tap_deref_mut</a>&lt;F, R&gt;(self, func: F) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a>) -&gt; R,</div></h4></section></summary><div class='docblock'>Mutably dereferences <code>self</code> for modification.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_deref_mut_dbg-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/tap.rs.html#624-627">source</a><a href="#method.tap_deref_mut_dbg-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/tap/trait.TapDeref.html#method.tap_deref_mut_dbg" class="fn">tap_deref_mut_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a>) -&gt; R,</div></h4></section></summary><div class='docblock'>Calls <code>tap_deref_mut</code> in debug builds, and does nothing in release
builds.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/alloc/borrow.rs.html#83-85">source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.81.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/alloc/borrow.rs.html#88">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.81.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/alloc/borrow.rs.html#92">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.81.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToString-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/alloc/string.rs.html#2555">source</a><a href="#impl-ToString-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/alloc/string/trait.ToString.html" title="trait alloc::string::ToString">ToString</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_string" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/alloc/string.rs.html#2561">source</a><a href="#method.to_string" class="anchor">§</a><h4 class="code-header">default fn <a href="https://doc.rust-lang.org/1.81.0/alloc/string/trait.ToString.html#tymethod.to_string" class="fn">to_string</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class='docblock'>Converts the given value to a <code>String</code>. <a href="https://doc.rust-lang.org/1.81.0/alloc/string/trait.ToString.html#tymethod.to_string">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryConv-for-T" class="impl"><a class="src rightside" href="../../src/tap/conv.rs.html#87">source</a><a href="#impl-TryConv-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../tap/conv/trait.TryConv.html" title="trait tap::conv::TryConv">TryConv</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.try_conv" class="method trait-impl"><a class="src rightside" href="../../src/tap/conv.rs.html#78-81">source</a><a href="#method.try_conv" class="anchor">§</a><h4 class="code-header">fn <a href="../../tap/conv/trait.TryConv.html#method.try_conv" class="fn">try_conv</a>&lt;T&gt;(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryInto.html#associatedtype.Error" title="type core::convert::TryInto::Error">Error</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;T&gt;,</div></h4></section></summary><div class='docblock'>Attempts to convert <code>self</code> into <code>T</code> using <code>TryInto&lt;T&gt;</code>. <a href="../../tap/conv/trait.TryConv.html#method.try_conv">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryConv-for-T-1" class="impl"><a class="src rightside" href="../../src/wyz/conv.rs.html#209">source</a><a href="#impl-TryConv-for-T-1" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../wyz/conv/trait.TryConv.html" title="trait wyz::conv::TryConv">TryConv</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.try_conv-1" class="method trait-impl"><a class="src rightside" href="../../src/wyz/conv.rs.html#203-204">source</a><a href="#method.try_conv-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../wyz/conv/trait.TryConv.html#method.try_conv" class="fn">try_conv</a>&lt;T&gt;(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryInto.html#associatedtype.Error" title="type core::convert::TryInto::Error">Error</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;T&gt;,</div></h4></section></summary><div class='docblock'>Attempts to convert <code>self</code> into a target type. <a href="../../wyz/conv/trait.TryConv.html#method.try_conv">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/convert/mod.rs.html#805-807">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/convert/mod.rs.html#812">source</a><a href="#method.try_from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/convert/mod.rs.html#790-792">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-2" class="associatedtype trait-impl"><a href="#associatedtype.Error-2" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/convert/mod.rs.html#797">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"&BitSlice<O, T>":"<h3>Notable traits for <code>&amp;'a <a class=\"struct\" href=\"../slice/struct.BitSlice.html\" title=\"struct bitvec::slice::BitSlice\">BitSlice</a>&lt;O, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, O, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;'a <a class=\"struct\" href=\"../slice/struct.BitSlice.html\" title=\"struct bitvec::slice::BitSlice\">BitSlice</a>&lt;O, T&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,\n    <a class=\"struct\" href=\"../slice/struct.BitSlice.html\" title=\"struct bitvec::slice::BitSlice\">BitSlice</a>&lt;O, T&gt;: <a class=\"trait\" href=\"../field/trait.BitField.html\" title=\"trait bitvec::field::BitField\">BitField</a>,</div></div>","&mut BitSlice<O, T>":"<h3>Notable traits for <code>&amp;'a mut <a class=\"struct\" href=\"../slice/struct.BitSlice.html\" title=\"struct bitvec::slice::BitSlice\">BitSlice</a>&lt;O, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, O, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for &amp;'a mut <a class=\"struct\" href=\"../slice/struct.BitSlice.html\" title=\"struct bitvec::slice::BitSlice\">BitSlice</a>&lt;O, T&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,\n    <a class=\"struct\" href=\"../slice/struct.BitSlice.html\" title=\"struct bitvec::slice::BitSlice\">BitSlice</a>&lt;O, T::<a class=\"associatedtype\" href=\"../store/trait.BitStore.html#associatedtype.Alias\" title=\"type bitvec::store::BitStore::Alias\">Alias</a>&gt;: <a class=\"trait\" href=\"../field/trait.BitField.html\" title=\"trait bitvec::field::BitField\">BitField</a>,</div></div>","BitVec<O, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct bitvec::vec::BitVec\">BitVec</a>&lt;O, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;O, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct bitvec::vec::BitVec\">BitVec</a>&lt;O, T&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,\n    <a class=\"struct\" href=\"../slice/struct.BitSlice.html\" title=\"struct bitvec::slice::BitSlice\">BitSlice</a>&lt;O, T::<a class=\"associatedtype\" href=\"../store/trait.BitStore.html#associatedtype.Alias\" title=\"type bitvec::store::BitStore::Alias\">Alias</a>&gt;: <a class=\"trait\" href=\"../field/trait.BitField.html\" title=\"trait bitvec::field::BitField\">BitField</a>,</div></div>","Chunks<'_, O, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../slice/struct.Chunks.html\" title=\"struct bitvec::slice::Chunks\">Chunks</a>&lt;'a, O, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, O, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.Chunks.html\" title=\"struct bitvec::slice::Chunks\">Chunks</a>&lt;'a, O, T&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: 'a + <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"struct\" href=\"../slice/struct.BitSlice.html\" title=\"struct bitvec::slice::BitSlice\">BitSlice</a>&lt;O, T&gt;;</div>","ChunksExact<'_, O, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../slice/struct.ChunksExact.html\" title=\"struct bitvec::slice::ChunksExact\">ChunksExact</a>&lt;'a, O, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, O, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.ChunksExact.html\" title=\"struct bitvec::slice::ChunksExact\">ChunksExact</a>&lt;'a, O, T&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: 'a + <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"struct\" href=\"../slice/struct.BitSlice.html\" title=\"struct bitvec::slice::BitSlice\">BitSlice</a>&lt;O, T&gt;;</div>","ChunksExactMut<'_, O, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../slice/struct.ChunksExactMut.html\" title=\"struct bitvec::slice::ChunksExactMut\">ChunksExactMut</a>&lt;'a, O, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, O, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.ChunksExactMut.html\" title=\"struct bitvec::slice::ChunksExactMut\">ChunksExactMut</a>&lt;'a, O, T&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: 'a + <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a mut <a class=\"struct\" href=\"../slice/struct.BitSlice.html\" title=\"struct bitvec::slice::BitSlice\">BitSlice</a>&lt;O, T::<a class=\"associatedtype\" href=\"../store/trait.BitStore.html#associatedtype.Alias\" title=\"type bitvec::store::BitStore::Alias\">Alias</a>&gt;;</div>","ChunksMut<'_, O, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../slice/struct.ChunksMut.html\" title=\"struct bitvec::slice::ChunksMut\">ChunksMut</a>&lt;'a, O, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, O, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.ChunksMut.html\" title=\"struct bitvec::slice::ChunksMut\">ChunksMut</a>&lt;'a, O, T&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: 'a + <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a mut <a class=\"struct\" href=\"../slice/struct.BitSlice.html\" title=\"struct bitvec::slice::BitSlice\">BitSlice</a>&lt;O, T::<a class=\"associatedtype\" href=\"../store/trait.BitStore.html#associatedtype.Alias\" title=\"type bitvec::store::BitStore::Alias\">Alias</a>&gt;;</div>","Domain<'_, T>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../domain/enum.Domain.html\" title=\"enum bitvec::domain::Domain\">Domain</a>&lt;'a, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"enum\" href=\"../domain/enum.Domain.html\" title=\"enum bitvec::domain::Domain\">Domain</a>&lt;'a, T&gt;<div class=\"where\">where\n    T: 'a + <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = T::<a class=\"associatedtype\" href=\"../store/trait.BitStore.html#associatedtype.Mem\" title=\"type bitvec::store::BitStore::Mem\">Mem</a>;</div>","Drain<'_, O, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Drain.html\" title=\"struct bitvec::vec::Drain\">Drain</a>&lt;'_, O, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;O, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Drain.html\" title=\"struct bitvec::vec::Drain\">Drain</a>&lt;'_, O, T&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.bool.html\">bool</a>;</div>","Iter<'_, O, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../slice/struct.Iter.html\" title=\"struct bitvec::slice::Iter\">Iter</a>&lt;'a, O, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, O, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.Iter.html\" title=\"struct bitvec::slice::Iter\">Iter</a>&lt;'a, O, T&gt;<div class=\"where\">where\n    O: 'a + <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: 'a + <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.usize.html\">usize</a> as <a class=\"trait\" href=\"../slice/trait.BitSliceIndex.html\" title=\"trait bitvec::slice::BitSliceIndex\">BitSliceIndex</a>&lt;'a, O, T&gt;&gt;::<a class=\"associatedtype\" href=\"../slice/trait.BitSliceIndex.html#associatedtype.Immut\" title=\"type bitvec::slice::BitSliceIndex::Immut\">Immut</a>;</div>","IterMut<'_, O, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../slice/struct.IterMut.html\" title=\"struct bitvec::slice::IterMut\">IterMut</a>&lt;'a, O, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, O, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.IterMut.html\" title=\"struct bitvec::slice::IterMut\">IterMut</a>&lt;'a, O, T&gt;<div class=\"where\">where\n    O: 'a + <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: 'a + <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.usize.html\">usize</a> as <a class=\"trait\" href=\"../slice/trait.BitSliceIndex.html\" title=\"trait bitvec::slice::BitSliceIndex\">BitSliceIndex</a>&lt;'a, O, T::<a class=\"associatedtype\" href=\"../store/trait.BitStore.html#associatedtype.Alias\" title=\"type bitvec::store::BitStore::Alias\">Alias</a>&gt;&gt;::<a class=\"associatedtype\" href=\"../slice/trait.BitSliceIndex.html#associatedtype.Mut\" title=\"type bitvec::slice::BitSliceIndex::Mut\">Mut</a>;</div>","RChunks<'_, O, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../slice/struct.RChunks.html\" title=\"struct bitvec::slice::RChunks\">RChunks</a>&lt;'a, O, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, O, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.RChunks.html\" title=\"struct bitvec::slice::RChunks\">RChunks</a>&lt;'a, O, T&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: 'a + <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"struct\" href=\"../slice/struct.BitSlice.html\" title=\"struct bitvec::slice::BitSlice\">BitSlice</a>&lt;O, T&gt;;</div>","RChunksExact<'_, O, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../slice/struct.RChunksExact.html\" title=\"struct bitvec::slice::RChunksExact\">RChunksExact</a>&lt;'a, O, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, O, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.RChunksExact.html\" title=\"struct bitvec::slice::RChunksExact\">RChunksExact</a>&lt;'a, O, T&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: 'a + <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"struct\" href=\"../slice/struct.BitSlice.html\" title=\"struct bitvec::slice::BitSlice\">BitSlice</a>&lt;O, T&gt;;</div>","RChunksExactMut<'_, O, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../slice/struct.RChunksExactMut.html\" title=\"struct bitvec::slice::RChunksExactMut\">RChunksExactMut</a>&lt;'a, O, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, O, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.RChunksExactMut.html\" title=\"struct bitvec::slice::RChunksExactMut\">RChunksExactMut</a>&lt;'a, O, T&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: 'a + <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a mut <a class=\"struct\" href=\"../slice/struct.BitSlice.html\" title=\"struct bitvec::slice::BitSlice\">BitSlice</a>&lt;O, T::<a class=\"associatedtype\" href=\"../store/trait.BitStore.html#associatedtype.Alias\" title=\"type bitvec::store::BitStore::Alias\">Alias</a>&gt;;</div>","RChunksMut<'_, O, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../slice/struct.RChunksMut.html\" title=\"struct bitvec::slice::RChunksMut\">RChunksMut</a>&lt;'a, O, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, O, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.RChunksMut.html\" title=\"struct bitvec::slice::RChunksMut\">RChunksMut</a>&lt;'a, O, T&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: 'a + <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a mut <a class=\"struct\" href=\"../slice/struct.BitSlice.html\" title=\"struct bitvec::slice::BitSlice\">BitSlice</a>&lt;O, T::<a class=\"associatedtype\" href=\"../store/trait.BitStore.html#associatedtype.Alias\" title=\"type bitvec::store::BitStore::Alias\">Alias</a>&gt;;</div>","RSplit<'_, O, T, F>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../slice/struct.RSplit.html\" title=\"struct bitvec::slice::RSplit\">RSplit</a>&lt;'a, O, T, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, O, T, P&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.RSplit.html\" title=\"struct bitvec::slice::RSplit\">RSplit</a>&lt;'a, O, T, P&gt;<div class=\"where\">where\n    O: 'a + <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: 'a + <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,\n    P: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.usize.html\">usize</a>, &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.bool.html\">bool</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"struct\" href=\"../slice/struct.BitSlice.html\" title=\"struct bitvec::slice::BitSlice\">BitSlice</a>&lt;O, T&gt;;</div>","RSplitMut<'_, O, T, F>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../slice/struct.RSplitMut.html\" title=\"struct bitvec::slice::RSplitMut\">RSplitMut</a>&lt;'a, O, T, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, O, T, P&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.RSplitMut.html\" title=\"struct bitvec::slice::RSplitMut\">RSplitMut</a>&lt;'a, O, T, P&gt;<div class=\"where\">where\n    O: 'a + <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: 'a + <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,\n    P: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.usize.html\">usize</a>, &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.bool.html\">bool</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a mut <a class=\"struct\" href=\"../slice/struct.BitSlice.html\" title=\"struct bitvec::slice::BitSlice\">BitSlice</a>&lt;O, T::<a class=\"associatedtype\" href=\"../store/trait.BitStore.html#associatedtype.Alias\" title=\"type bitvec::store::BitStore::Alias\">Alias</a>&gt;;</div>","RSplitN<'_, O, T, F>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../slice/struct.RSplitN.html\" title=\"struct bitvec::slice::RSplitN\">RSplitN</a>&lt;'a, O, T, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, O, T, P&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.RSplitN.html\" title=\"struct bitvec::slice::RSplitN\">RSplitN</a>&lt;'a, O, T, P&gt;<div class=\"where\">where\n    O: 'a + <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: 'a + <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,\n    P: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.usize.html\">usize</a>, &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.bool.html\">bool</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;<a class=\"struct\" href=\"../slice/struct.RSplit.html\" title=\"struct bitvec::slice::RSplit\">RSplit</a>&lt;'a, O, T, P&gt; as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" title=\"type core::iter::traits::iterator::Iterator::Item\">Item</a>;</div>","RSplitNMut<'_, O, T, F>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../slice/struct.RSplitNMut.html\" title=\"struct bitvec::slice::RSplitNMut\">RSplitNMut</a>&lt;'a, O, T, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, O, T, P&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.RSplitNMut.html\" title=\"struct bitvec::slice::RSplitNMut\">RSplitNMut</a>&lt;'a, O, T, P&gt;<div class=\"where\">where\n    O: 'a + <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: 'a + <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,\n    P: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.usize.html\">usize</a>, &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.bool.html\">bool</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;<a class=\"struct\" href=\"../slice/struct.RSplitMut.html\" title=\"struct bitvec::slice::RSplitMut\">RSplitMut</a>&lt;'a, O, T, P&gt; as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" title=\"type core::iter::traits::iterator::Iterator::Item\">Item</a>;</div>","Splice<'_, O, T, I::IntoIter>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Splice.html\" title=\"struct bitvec::vec::Splice\">Splice</a>&lt;'_, O, T, I&gt;</code></h3><pre><code><div class=\"where\">impl&lt;O, T, I&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Splice.html\" title=\"struct bitvec::vec::Splice\">Splice</a>&lt;'_, O, T, I&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,\n    I: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>&lt;Item = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.bool.html\">bool</a>&gt;,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.bool.html\">bool</a>;</div>","Split<'_, O, T, F>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../slice/struct.Split.html\" title=\"struct bitvec::slice::Split\">Split</a>&lt;'a, O, T, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, O, T, P&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.Split.html\" title=\"struct bitvec::slice::Split\">Split</a>&lt;'a, O, T, P&gt;<div class=\"where\">where\n    O: 'a + <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: 'a + <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,\n    P: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.usize.html\">usize</a>, &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.bool.html\">bool</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"struct\" href=\"../slice/struct.BitSlice.html\" title=\"struct bitvec::slice::BitSlice\">BitSlice</a>&lt;O, T&gt;;</div>","SplitMut<'_, O, T, F>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../slice/struct.SplitMut.html\" title=\"struct bitvec::slice::SplitMut\">SplitMut</a>&lt;'a, O, T, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, O, T, P&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.SplitMut.html\" title=\"struct bitvec::slice::SplitMut\">SplitMut</a>&lt;'a, O, T, P&gt;<div class=\"where\">where\n    O: 'a + <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: 'a + <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,\n    P: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.usize.html\">usize</a>, &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.bool.html\">bool</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a mut <a class=\"struct\" href=\"../slice/struct.BitSlice.html\" title=\"struct bitvec::slice::BitSlice\">BitSlice</a>&lt;O, T::<a class=\"associatedtype\" href=\"../store/trait.BitStore.html#associatedtype.Alias\" title=\"type bitvec::store::BitStore::Alias\">Alias</a>&gt;;</div>","SplitN<'_, O, T, F>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../slice/struct.SplitN.html\" title=\"struct bitvec::slice::SplitN\">SplitN</a>&lt;'a, O, T, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, O, T, P&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.SplitN.html\" title=\"struct bitvec::slice::SplitN\">SplitN</a>&lt;'a, O, T, P&gt;<div class=\"where\">where\n    O: 'a + <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: 'a + <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,\n    P: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.usize.html\">usize</a>, &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.bool.html\">bool</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;<a class=\"struct\" href=\"../slice/struct.Split.html\" title=\"struct bitvec::slice::Split\">Split</a>&lt;'a, O, T, P&gt; as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" title=\"type core::iter::traits::iterator::Iterator::Item\">Item</a>;</div>","SplitNMut<'_, O, T, F>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../slice/struct.SplitNMut.html\" title=\"struct bitvec::slice::SplitNMut\">SplitNMut</a>&lt;'a, O, T, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, O, T, P&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.SplitNMut.html\" title=\"struct bitvec::slice::SplitNMut\">SplitNMut</a>&lt;'a, O, T, P&gt;<div class=\"where\">where\n    O: 'a + <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: 'a + <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,\n    P: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.usize.html\">usize</a>, &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.bool.html\">bool</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;<a class=\"struct\" href=\"../slice/struct.SplitMut.html\" title=\"struct bitvec::slice::SplitMut\">SplitMut</a>&lt;'a, O, T, P&gt; as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" title=\"type core::iter::traits::iterator::Iterator::Item\">Item</a>;</div>","Windows<'_, O, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../slice/struct.Windows.html\" title=\"struct bitvec::slice::Windows\">Windows</a>&lt;'a, O, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, O, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.Windows.html\" title=\"struct bitvec::slice::Windows\">Windows</a>&lt;'a, O, T&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"../order/trait.BitOrder.html\" title=\"trait bitvec::order::BitOrder\">BitOrder</a>,\n    T: 'a + <a class=\"trait\" href=\"../store/trait.BitStore.html\" title=\"trait bitvec::store::BitStore\">BitStore</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"struct\" href=\"../slice/struct.BitSlice.html\" title=\"struct bitvec::slice::BitSlice\">BitSlice</a>&lt;O, T&gt;;</div>"}</script></section></div></main></body></html>