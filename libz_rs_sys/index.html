<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate is a C API for zlib-rs. The API is broadly equivalent to `zlib-sys` and `zlib-ng-sys`, but does not currently provide the `gz*` family of functions."><title>libz_rs_sys - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="libz_rs_sys" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0 (17067e9ac 2025-05-09)" data-channel="1.87.0" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js" ><script src="../static.files/storage-82c7156e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../libz_rs_sys/index.html">libz_<wbr>rs_<wbr>sys</a><span class="version">0.5.1</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#features" title="Features">Features</a></li><li><a href="#example" title="Example">Example</a></li><li><a href="#memory-management" title="Memory Management">Memory Management</a></li><li><a href="#compression-levels" title="Compression Levels">Compression Levels</a></li><li><a href="#safety" title="Safety">Safety</a></li></ul><h3><a href="#structs">Crate Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>libz_rs_sys</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/libz_rs_sys/lib.rs.html#1-1900">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate is a C API for <a href="https://docs.rs/zlib-rs/latest/zlib_rs/">zlib-rs</a>. The API is broadly equivalent to <a href="https://docs.rs/libz-sys/latest/libz_sys/"><code>zlib-sys</code></a> and <a href="https://docs.rs/libz-ng-sys/latest/libz_ng_sys/"><code>zlib-ng-sys</code></a>, but does not currently provide the <code>gz*</code> family of functions.</p>
<p>From a rust perspective, this API is not very ergonomic. Use the <a href="https://crates.io/crates/flate2"><code>flate2</code></a> crate for a more
ergonomic rust interface to zlib.</p>
<h3 id="features"><a class="doc-anchor" href="#features">§</a>Features</h3>
<p><strong><code>custom-prefix</code></strong></p>
<p>Add a custom prefix to all exported symbols.</p>
<p>The value of the <code>LIBZ_RS_SYS_PREFIX</code> is used as a prefix for all exported symbols. For example:</p>
<div class="example-wrap"><pre class="language-text"><code>&gt; LIBZ_RS_SYS_PREFIX=&quot;MY_CUSTOM_PREFIX&quot; cargo build -p libz-rs-sys --features=custom-prefix
   Compiling libz-rs-sys v0.2.1 (/home/folkertdev/rust/zlib-rs/libz-rs-sys)
    Finished `dev` profile [optimized + debuginfo] target(s) in 0.21s
&gt; objdump -tT target/debug/liblibz_rs_sys.so | grep &quot;uncompress&quot;
0000000000081028 l     O .got	0000000000000000              _ZN7zlib_rs7inflate10uncompress17he7d985e55c58a189E$got
000000000002c570 l     F .text	00000000000001ef              _ZN7zlib_rs7inflate10uncompress17he7d985e55c58a189E
0000000000024330 g     F .text	000000000000008e              MY_CUSTOM_PREFIXuncompress
0000000000024330 g    DF .text	000000000000008e  Base        MY_CUSTOM_PREFIXuncompress</code></pre></div>
<p><strong><code>c-allocator</code>, <code>rust-allocator</code></strong></p>
<p>Pick the default allocator implementation that is used if no <code>zalloc</code> and <code>zfree</code> are configured in the input <code>z_stream</code>.</p>
<ul>
<li><code>c-allocator</code>: use <code>malloc</code>/<code>free</code> for the implementation of <code>zalloc</code> and <code>zfree</code></li>
<li><code>rust-allocator</code>: the rust global allocator for the implementation of <code>zalloc</code> and <code>zfree</code></li>
</ul>
<p>The <code>rust-allocator</code> is the default when this crate is used as a rust dependency, and slightly more efficient because alignment is handled by the allocator. When building a dynamic library, it may make sense to use <code>c-allocator</code> instead.</p>
<p><strong><code>std</code></strong></p>
<p>Assume that <code>std</code> is available. When this feature is turned off, this crate is compatible with <code>#![no_std]</code>.</p>
<h3 id="example"><a class="doc-anchor" href="#example">§</a>Example</h3>
<p>This example compresses (“deflates”) the string <code>"Hello, World!"</code> and then decompresses
(“inflates”) it again.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>strm = libz_rs_sys::z_stream::default();

<span class="kw">let </span>version = libz_rs_sys::zlibVersion();
<span class="kw">let </span>stream_size = core::mem::size_of_val(<span class="kw-2">&amp;</span>strm) <span class="kw">as </span>i32;

<span class="kw">let </span>level = <span class="number">6</span>; <span class="comment">// the default compression level
</span><span class="kw">let </span>err = <span class="kw">unsafe </span>{ libz_rs_sys::deflateInit_(<span class="kw-2">&amp;mut </span>strm, level, version, stream_size) };
<span class="macro">assert_eq!</span>(err, libz_rs_sys::Z_OK);

<span class="kw">let </span>input = <span class="string">"Hello, World!"</span>;
strm.avail_in = input.len() <span class="kw">as _</span>;
strm.next_in = input.as_ptr();

<span class="kw">let </span><span class="kw-2">mut </span>output = [<span class="number">0u8</span>; <span class="number">32</span>];
strm.avail_out = output.len() <span class="kw">as _</span>;
strm.next_out = output.as_mut_ptr();

<span class="kw">let </span>err = <span class="kw">unsafe </span>{ libz_rs_sys::deflate(<span class="kw-2">&amp;mut </span>strm, libz_rs_sys::Z_FINISH) };
<span class="macro">assert_eq!</span>(err, libz_rs_sys::Z_STREAM_END);

<span class="kw">let </span>err = <span class="kw">unsafe </span>{ libz_rs_sys::deflateEnd(<span class="kw-2">&amp;mut </span>strm) };
<span class="macro">assert_eq!</span>(err, libz_rs_sys::Z_OK);

<span class="kw">let </span>deflated = <span class="kw-2">&amp;mut </span>output[..strm.total_out <span class="kw">as </span>usize];

<span class="kw">let </span><span class="kw-2">mut </span>strm = libz_rs_sys::z_stream::default();
<span class="kw">let </span>err = <span class="kw">unsafe </span>{ libz_rs_sys::inflateInit_(<span class="kw-2">&amp;mut </span>strm, version, stream_size) };
<span class="macro">assert_eq!</span>(err, libz_rs_sys::Z_OK);

strm.avail_in = deflated.len() <span class="kw">as _</span>;
strm.next_in = deflated.as_ptr();

<span class="kw">let </span><span class="kw-2">mut </span>output = [<span class="number">0u8</span>; <span class="number">32</span>];
strm.avail_out = output.len() <span class="kw">as _</span>;
strm.next_out = output.as_mut_ptr();

<span class="kw">let </span>err = <span class="kw">unsafe </span>{ libz_rs_sys::inflate(<span class="kw-2">&amp;mut </span>strm, libz_rs_sys::Z_FINISH) };
<span class="macro">assert_eq!</span>(err, libz_rs_sys::Z_STREAM_END);

<span class="kw">let </span>err = <span class="kw">unsafe </span>{ libz_rs_sys::inflateEnd(<span class="kw-2">&amp;mut </span>strm) };
<span class="macro">assert_eq!</span>(err, libz_rs_sys::Z_OK);

<span class="kw">let </span>inflated = <span class="kw-2">&amp;</span>output[..strm.total_out <span class="kw">as </span>usize];

<span class="macro">assert_eq!</span>(inflated, input.as_bytes())</code></pre></div>
<h3 id="memory-management"><a class="doc-anchor" href="#memory-management">§</a>Memory Management</h3>
<p>Zlib does not assume a global allocator, but instead accepts <code>zalloc</code> and <code>zfree</code> functions for allocating and deallocating memory.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">type </span>alloc_func = <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(<span class="kw-2">*mut </span>c_void, c_uint, c_uint) -&gt; <span class="kw-2">*mut </span>c_void;
<span class="kw">type </span>free_func = <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(<span class="kw-2">*mut </span>c_void, <span class="kw-2">*mut </span>c_void);

<span class="kw">struct </span>z_stream {
    <span class="comment">// ...
    </span>zalloc: <span class="prelude-ty">Option</span>&lt;alloc_func&gt;,
    zfree: <span class="prelude-ty">Option</span>&lt;free_func&gt;,
    opaque: <span class="kw-2">*mut </span>c_void,
    <span class="comment">// ..
</span>}</code></pre></div>
<p>These functions can run arbitrary logic, so long as they satisfy their contract. This mechanism can be used e.g. on embedded systems to use an array in static memory as the working memory for (de)compression. For more information see the <a href="https://docs.rs/zlib-rs/latest/zlib_rs/c_api/struct.z_stream.html"><code>z_stream</code></a> documentation.</p>
<p>For convenience we provide two default memory allocators:</p>
<ul>
<li><code>rust</code> uses the rust global allocator</li>
<li><code>c</code> uses <code>malloc</code> and <code>free</code></li>
</ul>
<p>When used as a rust crate, the default is to use the rust global allocator. This behavior can be overridden using <a href="#features">feature flags</a> to either configure the C allocator as the default, or to configure no default allocator at all. If no default is configured, and no custom allocation and deallocation functions are provided, initialization will return an error.</p>
<h3 id="compression-levels"><a class="doc-anchor" href="#compression-levels">§</a>Compression Levels</h3>
<p>The zlib library supports compression levels 0 up to and including 9. The level indicates a tradeoff between time spent on the compression versus the compression ratio, the factor by which the input is reduced in size:</p>
<ul>
<li>level 0: no compression at all</li>
<li>level 1: fastest compression</li>
<li>level 6: default (a good tradeoff between speed and compression ratio)</li>
<li>level 9: best compression</li>
</ul>
<p>Beyond this intuition, the exact behavior of the compression levels is not specified. The implementation of <code>zlib-rs</code> follows the implementation of <a href="https://github.com/zlib-ng/zlib-ng"><code>zlib-ng</code></a>, and deviates from the one in stock zlib.</p>
<p>In particular, our compression level 1 is extremely fast, but also just does not compress that well. On the <code>silesia-small.tar</code> input file, we see these output sizes:</p>
<div><table><thead><tr><th>implementation</th><th>compression level</th><th>output size (mb)</th></tr></thead><tbody>
<tr><td>-</td><td>0</td><td><code>15.74</code></td></tr>
<tr><td>stock</td><td>1</td><td><code> 7.05</code></td></tr>
<tr><td>rs</td><td>1</td><td><code> 8.52</code></td></tr>
<tr><td>rs</td><td>2</td><td><code> 6.90</code></td></tr>
<tr><td>rs</td><td>4</td><td><code> 6.55</code></td></tr>
</tbody></table>
</div>
<p>But, <code>zlib-rs</code> is much faster than stock zlib. In our benchmarks, it is only at level 4 that we spend roughly as much time as stock zlib on level 1:</p>
<div><table><thead><tr><th>implementation</th><th>compression level</th><th>wall time (ms)</th></tr></thead><tbody>
<tr><td>stock</td><td>1</td><td>185</td></tr>
<tr><td>rs</td><td>2</td><td>139</td></tr>
<tr><td>rs</td><td>4</td><td>181</td></tr>
</tbody></table>
</div>
<p>In our example, the main options are:</p>
<ul>
<li>level 1: worse compression, but much faster</li>
<li>level 2: equivalent compression, but significantly faster</li>
<li>level 4: better compression, at the same speed</li>
</ul>
<p>In summary, when you upgrade from stock zlib, we recommend that you benchmark on your data and target platform, and pick the right compression level for your use case.</p>
<h2 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h2>
<p>Most of the functions in this module are <code>unsafe fn</code>s, meaning that their behavior may be
undefined if certain assumptions are broken by the caller. In most cases, documentation
in this module refers to the safety assumptions of standard library functions.</p>
<p>In most cases, pointers must be either <code>NULL</code> or satisfy the requirements of <code>&amp;*ptr</code> or <code>&amp;mut *ptr</code>. This requirement maps to the requirements of <a href="https://doc.rust-lang.org/core/primitive.pointer.html#method.as_ref"><code>pointer::as_ref</code></a> and <a href="https://doc.rust-lang.org/core/primitive.pointer.html#method.as_mut"><code>pointer::as_mut</code></a>
for immutable and mutable pointers respectively.</p>
<p>For pointer and length pairs, describing some sequence of elements in memory, the requirements
of <a href="https://doc.rust-lang.org/1.87.0/core/slice/raw/fn.from_raw_parts.html" title="fn core::slice::raw::from_raw_parts"><code>core::slice::from_raw_parts</code></a> or <a href="https://doc.rust-lang.org/1.87.0/core/slice/raw/fn.from_raw_parts_mut.html" title="fn core::slice::raw::from_raw_parts_mut"><code>core::slice::from_raw_parts_mut</code></a> apply. In some cases,
the element type <code>T</code> is converted into <code>MaybeUninit&lt;T&gt;</code>, meaning that while the slice must be
valid, the elements in the slice can be uninitialized. Using uninitialized buffers for output
is more performant.</p>
<p>Finally, some functions accept a string argument, which must either be <code>NULL</code> or satisfy the
requirements of <a href="https://doc.rust-lang.org/1.87.0/core/ffi/c_str/struct.CStr.html#method.from_ptr" title="associated function core::ffi::c_str::CStr::from_ptr"><code>core::ffi::CStr::from_ptr</code></a>.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.gz_header.html" title="struct libz_rs_sys::gz_header">gz_<wbr>header</a></dt><dd>gzip header information passed to and from zlib routines.
See RFC 1952 for more details on the meanings of these fields.</dd><dt><a class="struct" href="struct.z_stream.html" title="struct libz_rs_sys::z_stream">z_<wbr>stream</a></dt><dd>The current stream state</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.internal_state.html" title="enum libz_rs_sys::internal_state">internal_<wbr>state</a></dt></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><dl class="item-table"><dt><a class="constant" href="constant.Z_ASCII.html" title="constant libz_rs_sys::Z_ASCII">Z_ASCII</a></dt><dt><a class="constant" href="constant.Z_BEST_COMPRESSION.html" title="constant libz_rs_sys::Z_BEST_COMPRESSION">Z_<wbr>BEST_<wbr>COMPRESSION</a></dt><dt><a class="constant" href="constant.Z_BEST_SPEED.html" title="constant libz_rs_sys::Z_BEST_SPEED">Z_<wbr>BEST_<wbr>SPEED</a></dt><dt><a class="constant" href="constant.Z_BINARY.html" title="constant libz_rs_sys::Z_BINARY">Z_<wbr>BINARY</a></dt><dt><a class="constant" href="constant.Z_BLOCK.html" title="constant libz_rs_sys::Z_BLOCK">Z_BLOCK</a></dt><dt><a class="constant" href="constant.Z_BUF_ERROR.html" title="constant libz_rs_sys::Z_BUF_ERROR">Z_<wbr>BUF_<wbr>ERROR</a></dt><dt><a class="constant" href="constant.Z_DATA_ERROR.html" title="constant libz_rs_sys::Z_DATA_ERROR">Z_<wbr>DATA_<wbr>ERROR</a></dt><dt><a class="constant" href="constant.Z_DEFAULT_COMPRESSION.html" title="constant libz_rs_sys::Z_DEFAULT_COMPRESSION">Z_<wbr>DEFAULT_<wbr>COMPRESSION</a></dt><dt><a class="constant" href="constant.Z_DEFAULT_STRATEGY.html" title="constant libz_rs_sys::Z_DEFAULT_STRATEGY">Z_<wbr>DEFAULT_<wbr>STRATEGY</a></dt><dt><a class="constant" href="constant.Z_DEFLATED.html" title="constant libz_rs_sys::Z_DEFLATED">Z_<wbr>DEFLATED</a></dt><dt><a class="constant" href="constant.Z_ERRNO.html" title="constant libz_rs_sys::Z_ERRNO">Z_ERRNO</a></dt><dt><a class="constant" href="constant.Z_FILTERED.html" title="constant libz_rs_sys::Z_FILTERED">Z_<wbr>FILTERED</a></dt><dt><a class="constant" href="constant.Z_FINISH.html" title="constant libz_rs_sys::Z_FINISH">Z_<wbr>FINISH</a></dt><dt><a class="constant" href="constant.Z_FIXED.html" title="constant libz_rs_sys::Z_FIXED">Z_FIXED</a></dt><dt><a class="constant" href="constant.Z_FULL_FLUSH.html" title="constant libz_rs_sys::Z_FULL_FLUSH">Z_<wbr>FULL_<wbr>FLUSH</a></dt><dt><a class="constant" href="constant.Z_HUFFMAN_ONLY.html" title="constant libz_rs_sys::Z_HUFFMAN_ONLY">Z_<wbr>HUFFMAN_<wbr>ONLY</a></dt><dt><a class="constant" href="constant.Z_MEM_ERROR.html" title="constant libz_rs_sys::Z_MEM_ERROR">Z_<wbr>MEM_<wbr>ERROR</a></dt><dt><a class="constant" href="constant.Z_NEED_DICT.html" title="constant libz_rs_sys::Z_NEED_DICT">Z_<wbr>NEED_<wbr>DICT</a></dt><dt><a class="constant" href="constant.Z_NO_COMPRESSION.html" title="constant libz_rs_sys::Z_NO_COMPRESSION">Z_<wbr>NO_<wbr>COMPRESSION</a></dt><dt><a class="constant" href="constant.Z_NO_FLUSH.html" title="constant libz_rs_sys::Z_NO_FLUSH">Z_<wbr>NO_<wbr>FLUSH</a></dt><dt><a class="constant" href="constant.Z_OK.html" title="constant libz_rs_sys::Z_OK">Z_OK</a></dt><dt><a class="constant" href="constant.Z_PARTIAL_FLUSH.html" title="constant libz_rs_sys::Z_PARTIAL_FLUSH">Z_<wbr>PARTIAL_<wbr>FLUSH</a></dt><dt><a class="constant" href="constant.Z_RLE.html" title="constant libz_rs_sys::Z_RLE">Z_RLE</a></dt><dt><a class="constant" href="constant.Z_STREAM_END.html" title="constant libz_rs_sys::Z_STREAM_END">Z_<wbr>STREAM_<wbr>END</a></dt><dt><a class="constant" href="constant.Z_STREAM_ERROR.html" title="constant libz_rs_sys::Z_STREAM_ERROR">Z_<wbr>STREAM_<wbr>ERROR</a></dt><dt><a class="constant" href="constant.Z_SYNC_FLUSH.html" title="constant libz_rs_sys::Z_SYNC_FLUSH">Z_<wbr>SYNC_<wbr>FLUSH</a></dt><dt><a class="constant" href="constant.Z_TEXT.html" title="constant libz_rs_sys::Z_TEXT">Z_TEXT</a></dt><dt><a class="constant" href="constant.Z_TREES.html" title="constant libz_rs_sys::Z_TREES">Z_TREES</a></dt><dt><a class="constant" href="constant.Z_UNKNOWN.html" title="constant libz_rs_sys::Z_UNKNOWN">Z_<wbr>UNKNOWN</a></dt><dt><a class="constant" href="constant.Z_VERSION_ERROR.html" title="constant libz_rs_sys::Z_VERSION_ERROR">Z_<wbr>VERSION_<wbr>ERROR</a></dt></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.adler32.html" title="fn libz_rs_sys::adler32">adler32</a><sup title="unsafe function">⚠</sup></dt><dd>Calculates the <a href="https://en.wikipedia.org/wiki/Adler-32">adler32</a> checksum
of a sequence of bytes.</dd><dt><a class="fn" href="fn.adler32_combine.html" title="fn libz_rs_sys::adler32_combine">adler32_<wbr>combine</a></dt><dd>Combines the checksum of two slices into one.</dd><dt><a class="fn" href="fn.compress.html" title="fn libz_rs_sys::compress">compress</a><sup title="unsafe function">⚠</sup></dt><dd>Compresses <code>source</code> into <code>dest</code>, and writes the final deflated size into <code>destLen</code>.</dd><dt><a class="fn" href="fn.compress2.html" title="fn libz_rs_sys::compress2">compress2</a><sup title="unsafe function">⚠</sup></dt><dd>Compresses <code>source</code> into <code>dest</code>, and writes the final deflated size into <code>destLen</code>.</dd><dt><a class="fn" href="fn.compressBound.html" title="fn libz_rs_sys::compressBound">compress<wbr>Bound</a></dt><dd>Returns an upper bound on the compressed size after <a href="fn.compress.html" title="fn libz_rs_sys::compress"><code>compress</code></a> or <a href="fn.compress2.html" title="fn libz_rs_sys::compress2"><code>compress2</code></a> on <code>sourceLen</code> bytes.</dd><dt><a class="fn" href="fn.crc32.html" title="fn libz_rs_sys::crc32">crc32</a><sup title="unsafe function">⚠</sup></dt><dd>Calculates the <a href="https://en.wikipedia.org/wiki/Computation_of_cyclic_redundancy_checks#CRC-32_algorithm">crc32</a> checksum
of a sequence of bytes.</dd><dt><a class="fn" href="fn.crc32_combine.html" title="fn libz_rs_sys::crc32_combine">crc32_<wbr>combine</a></dt><dd>Combines the checksum of two slices into one.</dd><dt><a class="fn" href="fn.deflate.html" title="fn libz_rs_sys::deflate">deflate</a><sup title="unsafe function">⚠</sup></dt><dd>Compresses as much data as possible, and stops when the input buffer becomes empty or the output buffer becomes full.</dd><dt><a class="fn" href="fn.deflateBound.html" title="fn libz_rs_sys::deflateBound">deflate<wbr>Bound</a><sup title="unsafe function">⚠</sup></dt><dd>Returns an upper bound on the compressed size after deflation of <code>sourceLen</code> bytes.</dd><dt><a class="fn" href="fn.deflateCopy.html" title="fn libz_rs_sys::deflateCopy">deflate<wbr>Copy</a><sup title="unsafe function">⚠</sup></dt><dd>Sets the destination stream as a complete copy of the source stream.</dd><dt><a class="fn" href="fn.deflateEnd.html" title="fn libz_rs_sys::deflateEnd">deflate<wbr>End</a><sup title="unsafe function">⚠</sup></dt><dd>Deallocates all dynamically allocated data structures for this stream.</dd><dt><a class="fn" href="fn.deflateGetDictionary.html" title="fn libz_rs_sys::deflateGetDictionary">deflate<wbr>GetDictionary</a><sup title="unsafe function">⚠</sup></dt><dd>Returns the sliding dictionary being maintained by deflate.</dd><dt><a class="fn" href="fn.deflateInit2_.html" title="fn libz_rs_sys::deflateInit2_">deflate<wbr>Init2_</a><sup title="unsafe function">⚠</sup></dt><dd>Initializes the state for compression</dd><dt><a class="fn" href="fn.deflateInit_.html" title="fn libz_rs_sys::deflateInit_">deflate<wbr>Init_</a><sup title="unsafe function">⚠</sup></dt><dd>Initializes the state for compression</dd><dt><a class="fn" href="fn.deflateParams.html" title="fn libz_rs_sys::deflateParams">deflate<wbr>Params</a><sup title="unsafe function">⚠</sup></dt><dd>Dynamically update the compression level and compression strategy.</dd><dt><a class="fn" href="fn.deflatePending.html" title="fn libz_rs_sys::deflatePending">deflate<wbr>Pending</a><sup title="unsafe function">⚠</sup></dt><dd>Returns the number of bytes and bits of output that have been generated, but not yet provided in the available output.</dd><dt><a class="fn" href="fn.deflatePrime.html" title="fn libz_rs_sys::deflatePrime">deflate<wbr>Prime</a><sup title="unsafe function">⚠</sup></dt><dd>Inserts bits in the deflate output stream.</dd><dt><a class="fn" href="fn.deflateReset.html" title="fn libz_rs_sys::deflateReset">deflate<wbr>Reset</a><sup title="unsafe function">⚠</sup></dt><dd>This function is equivalent to <a href="fn.deflateEnd.html" title="fn libz_rs_sys::deflateEnd"><code>deflateEnd</code></a> followed by <a href="fn.deflateInit_.html" title="fn libz_rs_sys::deflateInit_"><code>deflateInit_</code></a>, but does not free and reallocate the internal compression state.</dd><dt><a class="fn" href="fn.deflateSetDictionary.html" title="fn libz_rs_sys::deflateSetDictionary">deflate<wbr>SetDictionary</a><sup title="unsafe function">⚠</sup></dt><dd>Initializes the compression dictionary from the given byte sequence without producing any compressed output.</dd><dt><a class="fn" href="fn.deflateSetHeader.html" title="fn libz_rs_sys::deflateSetHeader">deflate<wbr>SetHeader</a><sup title="unsafe function">⚠</sup></dt><dd>Provides gzip header information for when a gzip stream is requested by <a href="fn.deflateInit2_.html" title="fn libz_rs_sys::deflateInit2_"><code>deflateInit2_</code></a>.</dd><dt><a class="fn" href="fn.deflateTune.html" title="fn libz_rs_sys::deflateTune">deflate<wbr>Tune</a><sup title="unsafe function">⚠</sup></dt><dd>Fine tune deflate’s internal compression parameters.</dd><dt><a class="fn" href="fn.inflate.html" title="fn libz_rs_sys::inflate">inflate</a><sup title="unsafe function">⚠</sup></dt><dd>Decompresses as much data as possible, and stops when the input buffer becomes empty or the output buffer becomes full.</dd><dt><a class="fn" href="fn.inflateBack.html" title="fn libz_rs_sys::inflateBack">inflate<wbr>Back</a><sup title="unsafe function">⚠</sup></dt><dd>Decompresses as much data as possible, and stops when the input buffer becomes empty or the output buffer becomes full.</dd><dt><a class="fn" href="fn.inflateBackEnd.html" title="fn libz_rs_sys::inflateBackEnd">inflate<wbr>Back<wbr>End</a><sup title="unsafe function">⚠</sup></dt><dd>Deallocates all dynamically allocated data structures for this stream.</dd><dt><a class="fn" href="fn.inflateBackInit_.html" title="fn libz_rs_sys::inflateBackInit_">inflate<wbr>Back<wbr>Init_</a><sup title="unsafe function">⚠</sup></dt><dd>Initializes the state for decompression</dd><dt><a class="fn" href="fn.inflateCopy.html" title="fn libz_rs_sys::inflateCopy">inflate<wbr>Copy</a><sup title="unsafe function">⚠</sup></dt><dd>Sets the destination stream as a complete copy of the source stream.</dd><dt><a class="fn" href="fn.inflateEnd.html" title="fn libz_rs_sys::inflateEnd">inflate<wbr>End</a><sup title="unsafe function">⚠</sup></dt><dd>Deallocates all dynamically allocated data structures for this stream.</dd><dt><a class="fn" href="fn.inflateGetDictionary.html" title="fn libz_rs_sys::inflateGetDictionary">inflate<wbr>GetDictionary</a><sup title="unsafe function">⚠</sup></dt><dd>Returns the sliding dictionary being maintained by inflate.</dd><dt><a class="fn" href="fn.inflateGetHeader.html" title="fn libz_rs_sys::inflateGetHeader">inflate<wbr>GetHeader</a><sup title="unsafe function">⚠</sup></dt><dd>Requests that gzip header information be stored in the provided <a href="struct.gz_header.html" title="struct libz_rs_sys::gz_header"><code>gz_header</code></a> structure.</dd><dt><a class="fn" href="fn.inflateInit2_.html" title="fn libz_rs_sys::inflateInit2_">inflate<wbr>Init2_</a><sup title="unsafe function">⚠</sup></dt><dd>Initializes the state for decompression</dd><dt><a class="fn" href="fn.inflateInit_.html" title="fn libz_rs_sys::inflateInit_">inflate<wbr>Init_</a><sup title="unsafe function">⚠</sup></dt><dd>Initializes the state for decompression</dd><dt><a class="fn" href="fn.inflateMark.html" title="fn libz_rs_sys::inflateMark">inflate<wbr>Mark</a><sup title="unsafe function">⚠</sup></dt><dd>Gives information about the current location of the input stream.</dd><dt><a class="fn" href="fn.inflatePrime.html" title="fn libz_rs_sys::inflatePrime">inflate<wbr>Prime</a><sup title="unsafe function">⚠</sup></dt><dd>Inserts bits in the inflate input stream.</dd><dt><a class="fn" href="fn.inflateReset.html" title="fn libz_rs_sys::inflateReset">inflate<wbr>Reset</a><sup title="unsafe function">⚠</sup></dt><dd>Equivalent to <a href="fn.inflateEnd.html" title="fn libz_rs_sys::inflateEnd"><code>inflateEnd</code></a> followed by <a href="fn.inflateInit_.html" title="fn libz_rs_sys::inflateInit_"><code>inflateInit_</code></a>, but does not free and reallocate the internal decompression state.</dd><dt><a class="fn" href="fn.inflateReset2.html" title="fn libz_rs_sys::inflateReset2">inflate<wbr>Reset2</a><sup title="unsafe function">⚠</sup></dt><dd>This function is the same as <a href="fn.inflateReset.html" title="fn libz_rs_sys::inflateReset"><code>inflateReset</code></a>, but it also permits changing the wrap and window size requests.</dd><dt><a class="fn" href="fn.inflateSetDictionary.html" title="fn libz_rs_sys::inflateSetDictionary">inflate<wbr>SetDictionary</a><sup title="unsafe function">⚠</sup></dt><dd>Initializes the decompression dictionary from the given uncompressed byte sequence.</dd><dt><a class="fn" href="fn.inflateSync.html" title="fn libz_rs_sys::inflateSync">inflate<wbr>Sync</a><sup title="unsafe function">⚠</sup></dt><dd>Skips invalid compressed data until</dd><dt><a class="fn" href="fn.uncompress.html" title="fn libz_rs_sys::uncompress">uncompress</a><sup title="unsafe function">⚠</sup></dt><dd>Inflates <code>source</code> into <code>dest</code>, and writes the final inflated size into <code>destLen</code>.</dd><dt><a class="fn" href="fn.zError.html" title="fn libz_rs_sys::zError">zError</a></dt><dd>Get the error message for an error. This could be the value returned by e.g. <a href="fn.compress.html" title="fn libz_rs_sys::compress"><code>compress</code></a> or
<a href="fn.inflate.html" title="fn libz_rs_sys::inflate"><code>inflate</code></a>.</dd><dt><a class="fn" href="fn.zlibCompileFlags.html" title="fn libz_rs_sys::zlibCompileFlags">zlib<wbr>Compile<wbr>Flags</a></dt><dd>Return flags indicating compile-time options.</dd><dt><a class="fn" href="fn.zlibVersion.html" title="fn libz_rs_sys::zlibVersion">zlib<wbr>Version</a></dt><dd>The version of the zlib library.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.Bytef.html" title="type libz_rs_sys::Bytef">Bytef</a></dt><dt><a class="type" href="type.alloc_func.html" title="type libz_rs_sys::alloc_func">alloc_<wbr>func</a></dt><dt><a class="type" href="type.free_func.html" title="type libz_rs_sys::free_func">free_<wbr>func</a></dt><dt><a class="type" href="type.gz_headerp.html" title="type libz_rs_sys::gz_headerp">gz_<wbr>headerp</a></dt><dt><a class="type" href="type.in_func.html" title="type libz_rs_sys::in_func">in_func</a></dt><dt><a class="type" href="type.out_func.html" title="type libz_rs_sys::out_func">out_<wbr>func</a></dt><dt><a class="type" href="type.uInt.html" title="type libz_rs_sys::uInt">uInt</a></dt><dt><a class="type" href="type.uLong.html" title="type libz_rs_sys::uLong">uLong</a></dt><dt><a class="type" href="type.uLongf.html" title="type libz_rs_sys::uLongf">uLongf</a></dt><dt><a class="type" href="type.voidp.html" title="type libz_rs_sys::voidp">voidp</a></dt><dt><a class="type" href="type.voidpc.html" title="type libz_rs_sys::voidpc">voidpc</a></dt><dt><a class="type" href="type.voidpf.html" title="type libz_rs_sys::voidpf">voidpf</a></dt><dt><a class="type" href="type.z_off_t.html" title="type libz_rs_sys::z_off_t">z_off_t</a></dt><dt><a class="type" href="type.z_streamp.html" title="type libz_rs_sys::z_streamp">z_<wbr>streamp</a></dt></dl></section></div></main></body></html>