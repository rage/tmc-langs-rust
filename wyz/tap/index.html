<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Object Tapping"><title>wyz::tap - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="wyz" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../wyz/index.html">wyz</a><span class="version">0.2.0</span></h2></div><h2 class="location"><a href="#">Module tap</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#traits">Traits</a></li></ul></section><h2><a href="../index.html">In crate wyz</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">wyz</a>::<wbr><a class="mod" href="#">tap</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/wyz/tap.rs.html#1-913">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Object Tapping</p>
<p>This crate provides traits for transparently inserting operations into a method
chain. All traits take and return the object on which they act by value, and run
a provided function on a borrow of the value.</p>
<p>This allows methods that do not chain (such as mutators with <code>&amp;mut self -&gt; ()</code>
signatures) to be chained.</p>
<p>The traits in this crate provide methods that run some function, <code>Fn(&amp;T)</code> or
<code>Fn(&amp;mut T)</code>, on a value <code>T</code> without changing the binding status of that value.</p>
<h2 id="value-tapping"><a class="doc-anchor" href="#value-tapping">§</a>Value Tapping</h2>
<p>The primary trait of this crate is <a href="trait.Tap.html"><code>Tap</code></a>, which provides two methods: <a href="trait.Tap.html"><code>tap</code></a>
and <a href="trait.Tap.html#method.tap_mut"><code>tap_mut</code></a>. These provide immutable or mutable, respectively, borrows of
the tapped value to a user-provided function. The user function must not have a
return value.</p>
<p>This permits using inspector-style (<code>Fn(&amp;Self)</code>) or mutator-style
(<code>Fn(&amp;mut Self)</code>) functions in a method chain without breaks or reduction of
access to the main value.</p>
<p>Tap methods never change the type of the object on which they are called. The
<code>mut</code>-suffixed methods <em>are</em> permitted to change the <em>value</em> of their object.</p>
<h2 id="trait-tapping"><a class="doc-anchor" href="#trait-tapping">§</a>Trait Tapping</h2>
<p>Rust does not have subtyping in the object-oriented sense; rather, it uses
traits to indicate relationships between types and bring behavior of an interior
type to the exterior type. This crate provides taps that use the standard
conversion traits in order to assist in running tap methods generically.</p>
<h3 id="borrowed-tapping"><a class="doc-anchor" href="#borrowed-tapping">§</a>Borrowed Tapping</h3>
<p>The traits <code>std::borrow::Borrow</code> and <code>std::borrow::BorrowMut</code> allow container
types to behave as their contained types in borrowed contexts. The <a href="trait.TapBorrow.html"><code>TapBorrow</code></a>
trait provides methods, <a href="trait.TapBorrow.html#method.tap_borrow"><code>tap_borrow</code></a> and <a href="trait.TapBorrow.html#method.tap_borrow_mut"><code>tap_borrow_mut</code></a>, which depend on
<code>Borrow</code> and <code>BorrowMut</code>, respectively, to run the user-provided function on the
borrowed interior type.</p>
<p>This is useful for inspecting the interior of a <code>Cow</code> or other data structures
that abstract away the exact container type but provide uniform access to the
underlying data.</p>
<h3 id="polymorphic-tapping"><a class="doc-anchor" href="#polymorphic-tapping">§</a>Polymorphic Tapping</h3>
<p>The traits <code>std::convert::AsRef</code> and <code>std::convert::AsMut</code> allow composed types
to be used by reference as their component types. The <a href="trait.TapAsRef.html"><code>TapAsRef</code></a> trait
provides methods, <a href="trait.TapAsRef.html#method.tap_ref"><code>tap_ref</code></a> and <a href="trait.TapAsRef.html#method.tap_ref_mut"><code>tap_ref_mut</code></a>, which depend on <code>AsRef</code> and
<code>AsMut</code>, respectively, to run the user-provided function on the referred
component type.</p>
<p>This is useful for working with types like <code>Path</code>, which are commonly used as
generic targets such as <code>&lt;P: AsRef&lt;Path&gt;&gt;</code>. All such types <code>P</code> may have
<code>.tap_ref</code> called upon them with methods implemented on <code>Path</code>.</p>
<blockquote>
<p>Note: <code>Borrow</code> and <code>AsRef</code> are generic traits, which a type can implement many
times with different targets. As such, the referent type must be specified in
the tapped function. This can be done with a named method, or by marking the
type of the closure argument: <code>|x: &amp;Referent| ...</code>.</p>
</blockquote>
<h3 id="dereferenced-tapping"><a class="doc-anchor" href="#dereferenced-tapping">§</a>Dereferenced Tapping</h3>
<p>The traits <code>std::ops::Deref</code> and <code>std::ops::DerefMut</code> may be used to make owning
containers transparently defer to their contained data. This is used by <code>Vec</code>
and <code>String</code>, for example, to behave like <code>[T]</code> and <code>str</code> implicitly.</p>
<p>The <a href="trait.TapDeref.html"><code>TapDeref</code></a> trait provides <a href="trait.TapDeref.html#method.tap_deref"><code>tap_deref</code></a> and <a href="trait.TapDeref.html#method.tap_deref_mut"><code>tap_deref_mut</code></a> which call
<code>Deref</code> or <code>DerefMut</code>, respectively, on the tapped value before running the
provided function on the produced <code>Deref::Target</code> value.</p>
<p>Since <code>Deref</code> may only be implemented once, this trait does not require any
extra type information in its tap calls.</p>
<h2 id="conditional-tapping"><a class="doc-anchor" href="#conditional-tapping">§</a>Conditional Tapping</h2>
<p>Additional traits are provided to only invoke the tap when certain conditions
are met in the value being tapped.</p>
<h3 id="boolean-tapping"><a class="doc-anchor" href="#boolean-tapping">§</a>Boolean Tapping</h3>
<p>The [<code>TapBool</code>] trait, with methods [<code>tap_true</code>], [<code>tap_false</code>], and their
associated <code>_mut</code> variants, run the provided function only when the value is of
the correct variant. This trait is implemented on <code>bool</code> by default, and is
left open so that user crates may implement it on their own <code>bool</code>-like types.</p>
<h3 id="optional-tapping"><a class="doc-anchor" href="#optional-tapping">§</a>Optional Tapping</h3>
<p>The <a href="trait.TapOption.html"><code>TapOption</code></a> trait, with methods <a href="trait.TapOption.html#method.tap_some"><code>tap_some</code></a>, <a href="trait.TapOption.html#method.tap_some_mut"><code>tap_some_mut</code></a>, and
<a href="trait.TapOption.html#method.tap_none"><code>tap_none</code></a>, run the provided function only when the <code>Option</code> is of the
matching variant. The <code>tap_some</code> methods pass <code>&amp;T</code> or <code>&amp;mut T</code> to their
function; <code>tap_none</code> passes nothing.</p>
<p>Note that <code>tap_some_mut</code> may change the value of the inner object, but it cannot
change the <code>Option</code> from <code>Some</code> to <code>None</code>. If this behavior is desired, use
<code>tap_mut</code> to modify the <code>Option</code> wrapper directly, rather than <code>tap_some_mut</code> to
change the interior value.</p>
<h3 id="result-tapping"><a class="doc-anchor" href="#result-tapping">§</a>Result Tapping</h3>
<p>This acts exactly like <code>TapOption</code>, except that the alternate case has a value
that may be modified. It thus has methods <a href="trait.TapResult.html#method.tap_ok"><code>tap_ok</code></a>, <a href="trait.TapResult.html#method.tap_err"><code>tap_err</code></a>, and the
associated <code>_mut</code> variants.</p>
<h3 id="debug-tapping"><a class="doc-anchor" href="#debug-tapping">§</a>Debug Tapping</h3>
<p>All methods in the crate have a sibling method with the exact same name and
signature, except that the name is suffixed with <code>_dbg</code>. This method runs the
normal tap in a debug build, and is removed in release builds.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>wyz::tap::TapOption;

<span class="prelude-val">Some</span>(<span class="number">5i32</span>).tap_some_dbg(|n| <span class="macro">debug!</span>(<span class="string">"{}"</span>, n));</code></pre></div>
<p>This emits a debug trace when the crate is built in debug mode, and does nothing
when the crate is built in release mode.</p>
<h2 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h2>
<p>Import the trait or traits you wish to use, with <code>use wyz::tap::Tap;</code>, and then
attach <code>.tap</code> methods on the end of any expression you want to inspect or
modify. These methods never change the type or binding status of the object to
which they are attached, and can be added or removed without affecting
neighboring code.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<p>This uses <code>tap_mut</code> to modify a vector using methods that cannot be chained, and
without converting to an iterator and re-collecting.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>wyz::tap::Tap;

<span class="kw">let </span>v = <span class="macro">vec!</span>[<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>]
  .tap_mut(|v| v.sort())
  .tap_mut(|v| v.iter_mut().for_each(|e| <span class="kw-2">*</span>e <span class="kw-2">*</span>= <span class="number">2</span>))
  .tap_mut(|v| v.reverse());
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>v, <span class="kw-2">&amp;</span>[<span class="number">10</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>]);</code></pre></div>
<p>This uses <code>tap_some</code> to implement a conditional flag.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>wyz::tap::TapOption;

<span class="kw">let </span><span class="kw-2">mut </span>flag = <span class="bool-val">false</span>;

<span class="kw">let </span>n = <span class="prelude-val">None</span>::&lt;i32&gt;.tap_some(|<span class="kw">_</span>| flag = <span class="bool-val">true</span>);
<span class="macro">assert!</span>(n.is_none());
<span class="macro">assert!</span>(!flag);

<span class="kw">let </span>n: <span class="prelude-ty">Option</span>&lt;i32&gt; = <span class="prelude-val">Some</span>(<span class="number">1</span>).tap_some(|<span class="kw">_</span>| flag = <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(n.unwrap(), <span class="number">1</span>);
<span class="macro">assert!</span>(flag);</code></pre></div>
<p>And this uses <code>tap_err</code> to log errors without suppressing them.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>wyz::tap::TapResult;

<span class="kw">let </span><span class="kw-2">mut </span>err_ct = <span class="number">0</span>;

{
 <span class="kw">let </span><span class="kw-2">mut </span>action = |e: &amp;&amp;str| {
  err_ct += <span class="number">1</span>;
  <span class="macro">eprintln!</span>(<span class="string">"ERROR: {}"</span>, e);
 };

 <span class="prelude-val">Ok</span>::&lt;<span class="kw">_</span>, <span class="kw-2">&amp;</span>str&gt;(<span class="string">"success"</span>).tap_err(<span class="kw-2">&amp;mut </span>action);
 <span class="prelude-val">Err</span>::&lt;(), <span class="kw">_</span>&gt;(<span class="string">"failure"</span>).tap_err(<span class="kw-2">&amp;mut </span>action);
} <span class="comment">// I didn't want to write the closure twice

</span><span class="macro">assert_eq!</span>(err_ct, <span class="number">1</span>);
<span class="comment">//  printed "ERROR: failure"</span></code></pre></div>
<p>!</p>
</div></details><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Tap.html" title="trait wyz::tap::Tap">Tap</a></div><div class="desc docblock-short">Value Tap</div></li><li><div class="item-name"><a class="trait" href="trait.TapAsRef.html" title="trait wyz::tap::TapAsRef">TapAsRef</a></div><div class="desc docblock-short">Referential Tap</div></li><li><div class="item-name"><a class="trait" href="trait.TapBorrow.html" title="trait wyz::tap::TapBorrow">TapBorrow</a></div><div class="desc docblock-short">Borrowing Tap</div></li><li><div class="item-name"><a class="trait" href="trait.TapDeref.html" title="trait wyz::tap::TapDeref">TapDeref</a></div><div class="desc docblock-short">Dereferencing Tap</div></li><li><div class="item-name"><a class="trait" href="trait.TapOption.html" title="trait wyz::tap::TapOption">TapOption</a></div><div class="desc docblock-short">Optional Tap</div></li><li><div class="item-name"><a class="trait" href="trait.TapResult.html" title="trait wyz::tap::TapResult">TapResult</a></div><div class="desc docblock-short">Result Tap</div></li></ul></section></div></main></body></html>