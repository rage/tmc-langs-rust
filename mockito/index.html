<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Mockito is a library for generating and delivering HTTP mocks in Rust. You can use it for integration testing or offline work. Mockito runs a local pool of HTTP servers which create, deliver and remove the mocks."><title>mockito - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-84e720fa.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="mockito" data-themes="" data-resource-suffix="" data-rustdoc-version="1.89.0 (29483883e 2025-08-04)" data-channel="1.89.0" data-search-js="search-92309212.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-fd3af306.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../mockito/index.html"><img src="https://raw.githubusercontent.com/lipanski/mockito/master/docs/logo-black-100.png" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../mockito/index.html"><img src="https://raw.githubusercontent.com/lipanski/mockito/master/docs/logo-black-100.png" alt="logo"></a><h2><a href="../mockito/index.html">mockito</a><span class="version">1.7.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#features" title="Features">Features</a></li><li><a href="#getting-started" title="Getting Started">Getting Started</a></li><li><a href="#lifetime" title="Lifetime">Lifetime</a></li><li><a href="#async" title="Async">Async</a></li><li><a href="#configuring-the-server" title="Configuring the server">Configuring the server</a></li><li><a href="#matchers" title="Matchers">Matchers</a></li><li><a href="#matching-by-path-and-query" title="Matching by path and query">Matching by path and query</a><ul><li><a href="#example" title="Example">Example</a></li><li><a href="#example-1" title="Example">Example</a></li><li><a href="#example-2" title="Example">Example</a></li></ul></li><li><a href="#matching-by-query" title="Matching by query">Matching by query</a><ul><li><a href="#example-3" title="Example">Example</a></li><li><a href="#example-4" title="Example">Example</a></li><li><a href="#example-5" title="Example">Example</a></li></ul></li><li><a href="#matching-by-header" title="Matching by header">Matching by header</a><ul><li><a href="#example-6" title="Example">Example</a></li><li><a href="#example-7" title="Example">Example</a></li><li><a href="#example-8" title="Example">Example</a></li><li><a href="#example-9" title="Example">Example</a></li></ul></li><li><a href="#matching-by-body" title="Matching by body">Matching by body</a><ul><li><a href="#example-10" title="Example">Example</a></li><li><a href="#example-11" title="Example">Example</a></li><li><a href="#example-12" title="Example">Example</a></li></ul></li><li><a href="#the-anyof-matcher" title="The `AnyOf` matcher">The <code>AnyOf</code> matcher</a><ul><li><a href="#example-13" title="Example">Example</a></li></ul></li><li><a href="#the-allof-matcher" title="The `AllOf` matcher">The <code>AllOf</code> matcher</a><ul><li><a href="#example-14" title="Example">Example</a></li></ul></li><li><a href="#custom-matchers" title="Custom matchers">Custom matchers</a><ul><li><a href="#example-15" title="Example">Example</a></li></ul></li><li><a href="#asserts" title="Asserts">Asserts</a><ul><li><a href="#example-16" title="Example">Example</a></li><li><a href="#example-17" title="Example">Example</a></li><li><a href="#example-18" title="Example">Example</a></li><li><a href="#example-19" title="Example">Example</a></li><li><a href="#example-20" title="Example">Example</a></li></ul></li><li><a href="#non-matching-calls" title="Non-matching calls">Non-matching calls</a></li><li><a href="#cleaning-up" title="Cleaning up">Cleaning up</a></li><li><a href="#debug" title="Debug">Debug</a></li></ul><h3><a href="#structs">Crate Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>mockito</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/mockito/lib.rs.html#1-746">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Mockito is a library for <strong>generating and delivering HTTP mocks</strong> in Rust. You can use it for integration testing
or offline work. Mockito runs a local pool of HTTP servers which create, deliver and remove the mocks.</p>
<h2 id="features"><a class="doc-anchor" href="#features">ยง</a>Features</h2>
<ul>
<li>Supports HTTP1/2</li>
<li>Runs your tests in parallel</li>
<li>Comes with a wide range of request matchers (Regex, JSON, query parameters etc.)</li>
<li>Checks that a mock was called (spy)</li>
<li>Mocks multiple hosts at the same time</li>
<li>Exposes sync and async interfaces</li>
<li>Prints out a colored diff of the last unmatched request in case of errors</li>
<li>Simple, intuitive API</li>
<li>An awesome logo</li>
</ul>
<h2 id="getting-started"><a class="doc-anchor" href="#getting-started">ยง</a>Getting Started</h2>
<p>Add <code>mockito</code> to your <code>Cargo.toml</code> and start mocking:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[cfg(test)]
</span><span class="kw">mod </span>tests {
  <span class="attr">#[test]
  </span><span class="kw">fn </span>test_something() {
    <span class="comment">// Request a new server from the pool
    </span><span class="kw">let </span><span class="kw-2">mut </span>server = mockito::Server::new();

    <span class="comment">// Use one of these addresses to configure your client
    </span><span class="kw">let </span>host = server.host_with_port();
    <span class="kw">let </span>url = server.url();

    <span class="comment">// Create a mock
    </span><span class="kw">let </span>mock = server.mock(<span class="string">"GET"</span>, <span class="string">"/hello"</span>)
      .with_status(<span class="number">201</span>)
      .with_header(<span class="string">"content-type"</span>, <span class="string">"text/plain"</span>)
      .with_header(<span class="string">"x-api-key"</span>, <span class="string">"1234"</span>)
      .with_body(<span class="string">"world"</span>)
      .create();

    <span class="comment">// Any calls to GET /hello beyond this line will respond with 201, the
    // `content-type: text/plain` header and the body "world".

    // You can use `Mock::assert` to verify that your mock was called
    // mock.assert();
  </span>}
}</code></pre></div>
<p>If <a href="struct.Mock.html#method.assert" title="method mockito::Mock::assert"><code>Mock::assert</code></a> fails, a colored diff of the last unmatched request is displayed:</p>
<p><img src="https://raw.githubusercontent.com/lipanski/mockito/master/docs/colored-diff.png" alt="colored-diff.png" /></p>
<p>Use <strong>matchers</strong> to handle requests to the same endpoint in a different way:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[cfg(test)]
</span><span class="kw">mod </span>tests {
  <span class="attr">#[test]
  </span><span class="kw">fn </span>test_something() {
    <span class="kw">let </span><span class="kw-2">mut </span>server = mockito::Server::new();

    server.mock(<span class="string">"GET"</span>, <span class="string">"/greetings"</span>)
      .match_header(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)
      .match_body(mockito::Matcher::PartialJsonString(
          <span class="string">"{\"greeting\": \"hello\"}"</span>.to_string(),
      ))
      .with_body(<span class="string">"hello json"</span>)
      .create();

    server.mock(<span class="string">"GET"</span>, <span class="string">"/greetings"</span>)
      .match_header(<span class="string">"content-type"</span>, <span class="string">"application/text"</span>)
      .match_body(mockito::Matcher::Regex(<span class="string">"greeting=hello"</span>.to_string()))
      .with_body(<span class="string">"hello text"</span>)
      .create();
  }
}</code></pre></div>
<p>Start <strong>multiple servers</strong> to simulate requests to different hosts:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[cfg(test)]
</span><span class="kw">mod </span>tests {
  <span class="attr">#[test]
  </span><span class="kw">fn </span>test_something() {
    <span class="kw">let </span><span class="kw-2">mut </span>twitter = mockito::Server::new();
    <span class="kw">let </span><span class="kw-2">mut </span>github = mockito::Server::new();

    <span class="comment">// These mocks will be available at `twitter.url()`
    </span><span class="kw">let </span>twitter_mock = twitter.mock(<span class="string">"GET"</span>, <span class="string">"/api"</span>).create();

    <span class="comment">// These mocks will be available at `github.url()`
    </span><span class="kw">let </span>github_mock = github.mock(<span class="string">"GET"</span>, <span class="string">"/api"</span>).create();
  }
}</code></pre></div>
<p>Write <strong>async</strong> tests (make sure to use the <code>_async</code> methods!):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[cfg(test)]
</span><span class="kw">mod </span>tests {
  <span class="attr">#[tokio::test]
  </span><span class="kw">async fn </span>test_something() {
    <span class="kw">let </span><span class="kw-2">mut </span>server = Server::new_async().<span class="kw">await</span>;
    <span class="kw">let </span>m1 = server.mock(<span class="string">"GET"</span>, <span class="string">"/a"</span>).with_body(<span class="string">"aaa"</span>).create_async().<span class="kw">await</span>;
    <span class="kw">let </span>m2 = server.mock(<span class="string">"GET"</span>, <span class="string">"/b"</span>).with_body(<span class="string">"bbb"</span>).create_async().<span class="kw">await</span>;

    <span class="kw">let </span>(m1, m2) = <span class="macro">futures::join!</span>(m1, m2);

    <span class="comment">// You can use `Mock::assert_async` to verify that your mock was called
    // m1.assert_async().await;
    // m2.assert_async().await;
  </span>}
}</code></pre></div>
<p>Start a <strong>stand-alone server</strong> on a dedicated port:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>main() {
    <span class="kw">let </span>opts = mockito::ServerOpts {
        host: <span class="string">"0.0.0.0"</span>,
        port: <span class="number">1234</span>,
        ..Default::default()
    };
    <span class="kw">let </span><span class="kw-2">mut </span>server = mockito::Server::new_with_opts(opts);

    <span class="kw">let </span>_m = server.mock(<span class="string">"GET"</span>, <span class="string">"/"</span>).with_body(<span class="string">"hello world"</span>).create();

    <span class="comment">// loop {}
</span>}</code></pre></div>
<h2 id="lifetime"><a class="doc-anchor" href="#lifetime">ยง</a>Lifetime</h2>
<p>A mock is available only throughout the lifetime of the server. Once the server goes
out of scope, all mocks defined on that server are removed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>address;

{
    <span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();
    address = s.host_with_port();

    s.mock(<span class="string">"GET"</span>, <span class="string">"/"</span>).with_body(<span class="string">"hi"</span>).create();

    <span class="comment">// Requests to `address` will be responded with "hi" til here
</span>}

<span class="comment">// Requests to `address` will fail as of this point</span></code></pre></div>
<p>You can remove individual mocks earlier by calling <a href="struct.Mock.html#method.remove" title="method mockito::Mock::remove"><code>Mock::remove</code></a>.</p>
<h2 id="async"><a class="doc-anchor" href="#async">ยง</a>Async</h2>
<p>Mockito comes with both a sync and an async interface.</p>
<p>In order to write async tests, youโll need to use the <code>*_async</code> methods:</p>
<ul>
<li><a href="struct.Server.html#method.new_async" title="associated function mockito::Server::new_async"><code>Server::new_async</code></a></li>
<li><a href="struct.Server.html#method.new_with_opts_async" title="associated function mockito::Server::new_with_opts_async"><code>Server::new_with_opts_async</code></a></li>
<li><a href="struct.Mock.html#method.create_async" title="method mockito::Mock::create_async"><code>Mock::create_async</code></a></li>
<li><a href="struct.Mock.html#method.assert_async" title="method mockito::Mock::assert_async"><code>Mock::assert_async</code></a></li>
<li><a href="struct.Mock.html#method.matched_async" title="method mockito::Mock::matched_async"><code>Mock::matched_async</code></a></li>
<li><a href="struct.Mock.html#method.remove_async" title="method mockito::Mock::remove_async"><code>Mock::remove_async</code></a></li>
</ul>
<p>โฆotherwise your tests will not compile, and youโll see the following error:</p>
<div class="example-wrap"><pre class="language-text"><code>Cannot block the current thread from within a runtime.
This happens because a function attempted to block the current thread while the thread is being used to drive asynchronous tasks.</code></pre></div><h2 id="configuring-the-server"><a class="doc-anchor" href="#configuring-the-server">ยง</a>Configuring the server</h2>
<p>When calling <a href="struct.Server.html#method.new" title="associated function mockito::Server::new"><code>Server::new()</code></a>, a mock server with default options is returned from the server
pool. This should suffice for most use cases.</p>
<p>If youโd like to bypass the server pool or configure the server in a different
way, you can use <a href="struct.Server.html#method.new_with_opts" title="associated function mockito::Server::new_with_opts"><code>Server::new_with_opts</code></a>. The following <strong>options</strong> are available:</p>
<ul>
<li><code>host</code>: allows setting the host (defaults to <code>127.0.0.1</code>)</li>
<li><code>port</code>: allows setting the port (defaults to a randomly assigned free port)</li>
<li><code>assert_on_drop</code>: automatically call <a href="struct.Mock.html#method.assert" title="method mockito::Mock::assert"><code>Mock::assert()</code></a> before dropping a mock (defaults to <code>false</code>)</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>opts = mockito::ServerOpts { assert_on_drop: <span class="bool-val">true</span>, ..Default::default() };
<span class="kw">let </span>server = mockito::Server::new_with_opts(opts);</code></pre></div>
<h2 id="matchers"><a class="doc-anchor" href="#matchers">ยง</a>Matchers</h2>
<p>Mockito can match your request by method, path, query, headers or body.</p>
<p>Various matchers are provided by the <a href="enum.Matcher.html" title="enum mockito::Matcher"><code>Matcher</code></a> type: exact (string, binary, JSON), partial (regular expressions,
JSON), any or missing. The following guide will walk you through the most common matchers. Check the
<a href="enum.Matcher.html" title="enum mockito::Matcher"><code>Matcher</code></a> documentation for all the rest.</p>
<h2 id="matching-by-path-and-query"><a class="doc-anchor" href="#matching-by-path-and-query">ยง</a>Matching by path and query</h2>
<p>By default, the request path and query is compared by its exact value:</p>
<h3 id="example"><a class="doc-anchor" href="#example">ยง</a>Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();

<span class="comment">// Matches only calls to GET /hello
</span>s.mock(<span class="string">"GET"</span>, <span class="string">"/hello"</span>).create();

<span class="comment">// Matches only calls to GET /hello?world=1
</span>s.mock(<span class="string">"GET"</span>, <span class="string">"/hello?world=1"</span>).create();</code></pre></div>
<p>You can also match the path partially, by using a regular expression:</p>
<h3 id="example-1"><a class="doc-anchor" href="#example-1">ยง</a>Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();

<span class="comment">// Will match calls to GET /hello/1 and GET /hello/2
</span>s.mock(<span class="string">"GET"</span>,
    mockito::Matcher::Regex(<span class="string">r"^/hello/(1|2)$"</span>.to_string())
  ).create();</code></pre></div>
<p>Or you can catch all requests, by using the <a href="enum.Matcher.html#variant.Any" title="variant mockito::Matcher::Any"><code>Matcher::Any</code></a> variant:</p>
<h3 id="example-2"><a class="doc-anchor" href="#example-2">ยง</a>Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();

<span class="comment">// Will match any GET request
</span>s.mock(<span class="string">"GET"</span>, mockito::Matcher::Any).create();</code></pre></div>
<h2 id="matching-by-query"><a class="doc-anchor" href="#matching-by-query">ยง</a>Matching by query</h2>
<p>You can match the query part by using the <a href="struct.Mock.html#method.match_query" title="method mockito::Mock::match_query"><code>Mock::match_query</code></a> function together with the various matchers,
most notably <a href="enum.Matcher.html#variant.UrlEncoded" title="variant mockito::Matcher::UrlEncoded"><code>Matcher::UrlEncoded</code></a>:</p>
<h3 id="example-3"><a class="doc-anchor" href="#example-3">ยง</a>Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();

<span class="comment">// This will match requests containing the URL-encoded
// query parameter `greeting=good%20day`
</span>s.mock(<span class="string">"GET"</span>, <span class="string">"/test"</span>)
  .match_query(mockito::Matcher::UrlEncoded(<span class="string">"greeting"</span>.into(), <span class="string">"good day"</span>.into()))
  .create();

<span class="comment">// This will match requests containing the URL-encoded
// query parameters `hello=world` and `greeting=good%20day`
</span>s.mock(<span class="string">"GET"</span>, <span class="string">"/test"</span>)
  .match_query(mockito::Matcher::AllOf(<span class="macro">vec!</span>[
    mockito::Matcher::UrlEncoded(<span class="string">"hello"</span>.into(), <span class="string">"world"</span>.into()),
    mockito::Matcher::UrlEncoded(<span class="string">"greeting"</span>.into(), <span class="string">"good day"</span>.into())
  ]))
  .create();

<span class="comment">// You can achieve similar results with the regex matcher
</span>s.mock(<span class="string">"GET"</span>, <span class="string">"/test"</span>)
  .match_query(mockito::Matcher::Regex(<span class="string">"hello=world"</span>.into()))
  .create();</code></pre></div>
<p>Note that the key/value arguments for <a href="enum.Matcher.html#variant.UrlEncoded" title="variant mockito::Matcher::UrlEncoded"><code>Matcher::UrlEncoded</code></a> should be left in plain (unencoded) format.</p>
<p>You can also specify the query as part of the path argument in a <a href="struct.Server.html#method.mock" title="method mockito::Server::mock"><code>mock</code></a> call, in which case an exact
match will be performed:</p>
<h3 id="example-4"><a class="doc-anchor" href="#example-4">ยง</a>Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();

<span class="comment">// This will perform a full match against the query part
</span>s.mock(<span class="string">"GET"</span>, <span class="string">"/test?hello=world"</span>).create();</code></pre></div>
<p>If youโd like to ignore the query entirely, use the <a href="enum.Matcher.html#variant.Any" title="variant mockito::Matcher::Any"><code>Matcher::Any</code></a> variant:</p>
<h3 id="example-5"><a class="doc-anchor" href="#example-5">ยง</a>Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();

<span class="comment">// This will match requests to GET /test with any query
</span>s.mock(<span class="string">"GET"</span>, <span class="string">"/test"</span>).match_query(mockito::Matcher::Any).create();</code></pre></div>
<h2 id="matching-by-header"><a class="doc-anchor" href="#matching-by-header">ยง</a>Matching by header</h2>
<p>By default, headers are compared by their exact value. The header name letter case is ignored though.</p>
<h3 id="example-6"><a class="doc-anchor" href="#example-6">ยง</a>Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();

s.mock(<span class="string">"GET"</span>, <span class="string">"/hello"</span>)
  .match_header(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)
  .with_body(<span class="string">r#"{"hello": "world"}"#</span>)
  .create();

s.mock(<span class="string">"GET"</span>, <span class="string">"/hello"</span>)
  .match_header(<span class="string">"content-type"</span>, <span class="string">"text/plain"</span>)
  .with_body(<span class="string">"world"</span>)
  .create();

<span class="comment">// JSON requests to GET /hello will respond with JSON, while plain requests
// will respond with text.</span></code></pre></div>
<p>You can also match a header value with a <em>regular expressions</em>, by using the <a href="enum.Matcher.html#variant.Regex" title="variant mockito::Matcher::Regex"><code>Matcher::Regex</code></a> matcher:</p>
<h3 id="example-7"><a class="doc-anchor" href="#example-7">ยง</a>Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();

s.mock(<span class="string">"GET"</span>, <span class="string">"/hello"</span>)
  .match_header(<span class="string">"content-type"</span>, mockito::Matcher::Regex(<span class="string">r".*json.*"</span>.to_string()))
  .with_body(<span class="string">r#"{"hello": "world"}"#</span>)
  .create();</code></pre></div>
<p>Or you can match a header <em>only by its field name</em>, by setting the <a href="struct.Mock.html#method.match_header" title="method mockito::Mock::match_header"><code>Mock::match_header</code></a> value to <a href="enum.Matcher.html#variant.Any" title="variant mockito::Matcher::Any"><code>Matcher::Any</code></a>.</p>
<h3 id="example-8"><a class="doc-anchor" href="#example-8">ยง</a>Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();

s.mock(<span class="string">"GET"</span>, <span class="string">"/hello"</span>)
 .match_header(<span class="string">"content-type"</span>, mockito::Matcher::Any)
 .with_body(<span class="string">"something"</span>)
 .create();

<span class="comment">// Requests containing any content-type header value will be mocked.
// Requests not containing this header will return `501 Not Implemented`.</span></code></pre></div>
<p>You can mock requests that should be <em>missing a particular header field</em>, by setting the <a href="struct.Mock.html#method.match_header" title="method mockito::Mock::match_header"><code>Mock::match_header</code></a>
value to <a href="enum.Matcher.html#variant.Missing" title="variant mockito::Matcher::Missing"><code>Matcher::Missing</code></a>.</p>
<h3 id="example-9"><a class="doc-anchor" href="#example-9">ยง</a>Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();

s.mock(<span class="string">"GET"</span>, <span class="string">"/hello"</span>)
  .match_header(<span class="string">"authorization"</span>, mockito::Matcher::Missing)
  .with_body(<span class="string">"no authorization header"</span>)
  .create();

<span class="comment">// Requests without the authorization header will be matched.
// Requests containing the authorization header will return `501 Mock Not Found`.</span></code></pre></div>
<h2 id="matching-by-body"><a class="doc-anchor" href="#matching-by-body">ยง</a>Matching by body</h2>
<p>You can match a request by its body by using the <a href="struct.Mock.html#method.match_body" title="method mockito::Mock::match_body"><code>Mock::match_body</code></a> method.
By default, the request body is ignored, similar to passing the <a href="enum.Matcher.html#variant.Any" title="variant mockito::Matcher::Any"><code>Matcher::Any</code></a> argument to the <a href="struct.Mock.html#method.match_body" title="method mockito::Mock::match_body"><code>Mock::match_body</code></a> method.</p>
<p>You can match a body by an exact value:</p>
<h3 id="example-10"><a class="doc-anchor" href="#example-10">ยง</a>Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();

<span class="comment">// Will match requests to POST / whenever the request body is "hello"
</span>s.mock(<span class="string">"POST"</span>, <span class="string">"/"</span>).match_body(<span class="string">"hello"</span>).create();</code></pre></div>
<p>Or you can match the body by using a regular expression:</p>
<h3 id="example-11"><a class="doc-anchor" href="#example-11">ยง</a>Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();

<span class="comment">// Will match requests to POST / whenever the request body *contains* the word "hello" (e.g. "hello world")
</span>s.mock(<span class="string">"POST"</span>, <span class="string">"/"</span>).match_body(
    mockito::Matcher::Regex(<span class="string">"hello"</span>.to_string())
  ).create();</code></pre></div>
<p>Or you can match the body using a JSON object:</p>
<h3 id="example-12"><a class="doc-anchor" href="#example-12">ยง</a>Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>serde_json;

<span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();
<span class="comment">// Will match requests to POST / whenever the request body matches the json object
</span>s.mock(<span class="string">"POST"</span>, <span class="string">"/"</span>).match_body(mockito::Matcher::Json(<span class="macro">json!</span>({<span class="string">"hello"</span>: <span class="string">"world"</span>}))).create();</code></pre></div>
<p>If <code>serde_json::json!</code> is not exposed, you can use <a href="enum.Matcher.html#variant.JsonString" title="variant mockito::Matcher::JsonString"><code>Matcher::JsonString</code></a> the same way,
but by passing a <code>String</code> to the matcher:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();

<span class="comment">// Will match requests to POST / whenever the request body matches the json object
</span>s.mock(<span class="string">"POST"</span>, <span class="string">"/"</span>)
    .match_body(
       mockito::Matcher::JsonString(<span class="string">r#"{"hello": "world"}"#</span>.to_string())
    )
    .create();</code></pre></div>
<h2 id="the-anyof-matcher"><a class="doc-anchor" href="#the-anyof-matcher">ยง</a>The <code>AnyOf</code> matcher</h2>
<p>The <a href="enum.Matcher.html#variant.AnyOf" title="variant mockito::Matcher::AnyOf"><code>Matcher::AnyOf</code></a> construct takes a vector of matchers as arguments and will be enabled
if at least one of the provided matchers matches the request.</p>
<h3 id="example-13"><a class="doc-anchor" href="#example-13">ยง</a>Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();

<span class="comment">// Will match requests to POST / whenever the request body is either `hello=world` or `{"hello":"world"}`
</span>s.mock(<span class="string">"POST"</span>, <span class="string">"/"</span>)
    .match_body(
        mockito::Matcher::AnyOf(<span class="macro">vec!</span>[
            mockito::Matcher::Exact(<span class="string">"hello=world"</span>.to_string()),
            mockito::Matcher::JsonString(<span class="string">r#"{"hello": "world"}"#</span>.to_string()),
        ])
     )
    .create();</code></pre></div>
<h2 id="the-allof-matcher"><a class="doc-anchor" href="#the-allof-matcher">ยง</a>The <code>AllOf</code> matcher</h2>
<p>The <a href="enum.Matcher.html#variant.AllOf" title="variant mockito::Matcher::AllOf"><code>Matcher::AllOf</code></a> construct takes a vector of matchers as arguments and will be enabled
if all the provided matchers match the request.</p>
<h3 id="example-14"><a class="doc-anchor" href="#example-14">ยง</a>Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();

<span class="comment">// Will match requests to POST / whenever the request body contains both `hello` and `world`
</span>s.mock(<span class="string">"POST"</span>, <span class="string">"/"</span>)
    .match_body(
        mockito::Matcher::AllOf(<span class="macro">vec!</span>[
            mockito::Matcher::Regex(<span class="string">"hello"</span>.to_string()),
            mockito::Matcher::Regex(<span class="string">"world"</span>.to_string()),
        ])
     )
    .create();</code></pre></div>
<h2 id="custom-matchers"><a class="doc-anchor" href="#custom-matchers">ยง</a>Custom matchers</h2>
<p>If you need a more custom matcher, you can use the <a href="struct.Mock.html#method.match_request" title="method mockito::Mock::match_request"><code>Mock::match_request</code></a> function, which
takes a closure and exposes the <a href="struct.Request.html" title="struct mockito::Request"><code>Request</code></a> object as an argument. The closure should return
a boolean value.</p>
<h3 id="example-15"><a class="doc-anchor" href="#example-15">ยง</a>Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>mockito::Matcher;

<span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();

<span class="comment">// This will match requests that have the x-test header set
// and contain the word "hello" inside the body
</span>s.mock(<span class="string">"GET"</span>, <span class="string">"/"</span>)
    .match_request(|request| {
        request.has_header(<span class="string">"x-test"</span>) &amp;&amp;
            request.utf8_lossy_body().unwrap().contains(<span class="string">"hello"</span>)
    })
    .create();</code></pre></div>
<h2 id="asserts"><a class="doc-anchor" href="#asserts">ยง</a>Asserts</h2>
<p>You can use the <a href="struct.Mock.html#method.assert" title="method mockito::Mock::assert"><code>Mock::assert</code></a> method to <strong>assert that a mock was called</strong>. In other words,
<code>Mock#assert</code> can validate that your code performed the expected HTTP request.</p>
<p>By default, the method expects only <strong>one</strong> request to your mock.</p>
<h3 id="example-16"><a class="doc-anchor" href="#example-16">ยง</a>Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::net::TcpStream;
<span class="kw">use </span>std::io::{Read, Write};

<span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();
<span class="kw">let </span>mock = s.mock(<span class="string">"GET"</span>, <span class="string">"/hello"</span>).create();

{
    <span class="comment">// Place a request
    </span><span class="kw">let </span><span class="kw-2">mut </span>stream = TcpStream::connect(s.host_with_port()).unwrap();
    stream.write_all(<span class="string">"GET /hello HTTP/1.1\r\n\r\n"</span>.as_bytes()).unwrap();
    <span class="kw">let </span><span class="kw-2">mut </span>response = String::new();
    stream.read_to_string(<span class="kw-2">&amp;mut </span>response).unwrap();
    stream.flush().unwrap();
}

mock.assert();</code></pre></div>
<p>When several mocks can match a request, Mockito applies the first one that still expects requests.
You can use this behaviour to provide <strong>different responses for subsequent requests to the same endpoint</strong>.</p>
<h3 id="example-17"><a class="doc-anchor" href="#example-17">ยง</a>Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::net::TcpStream;
<span class="kw">use </span>std::io::{Read, Write};

<span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();
<span class="kw">let </span>english_hello_mock = s.mock(<span class="string">"GET"</span>, <span class="string">"/hello"</span>).with_body(<span class="string">"good bye"</span>).create();
<span class="kw">let </span>french_hello_mock = s.mock(<span class="string">"GET"</span>, <span class="string">"/hello"</span>).with_body(<span class="string">"au revoir"</span>).create();

{
    <span class="comment">// Place a request to GET /hello
    </span><span class="kw">let </span><span class="kw-2">mut </span>stream = TcpStream::connect(s.host_with_port()).unwrap();
    stream.write_all(<span class="string">"GET /hello HTTP/1.1\r\n\r\n"</span>.as_bytes()).unwrap();
    <span class="kw">let </span><span class="kw-2">mut </span>response = String::new();
    stream.read_to_string(<span class="kw-2">&amp;mut </span>response).unwrap();
    stream.flush().unwrap();
}

english_hello_mock.assert();

{
    <span class="comment">// Place another request to GET /hello
    </span><span class="kw">let </span><span class="kw-2">mut </span>stream = TcpStream::connect(s.host_with_port()).unwrap();
    stream.write_all(<span class="string">"GET /hello HTTP/1.1\r\n\r\n"</span>.as_bytes()).unwrap();
    <span class="kw">let </span><span class="kw-2">mut </span>response = String::new();
    stream.read_to_string(<span class="kw-2">&amp;mut </span>response).unwrap();
    stream.flush().unwrap();
}

french_hello_mock.assert();</code></pre></div>
<p>If youโre expecting more than 1 request, you can use the <a href="struct.Mock.html#method.expect" title="method mockito::Mock::expect"><code>Mock::expect</code></a> method to specify the exact amount of requests:</p>
<h3 id="example-18"><a class="doc-anchor" href="#example-18">ยง</a>Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::net::TcpStream;
<span class="kw">use </span>std::io::{Read, Write};

<span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();

<span class="kw">let </span>mock = s.mock(<span class="string">"GET"</span>, <span class="string">"/hello"</span>).expect(<span class="number">3</span>).create();

<span class="kw">for _ in </span><span class="number">0</span>..<span class="number">3 </span>{
    <span class="comment">// Place a request
    </span><span class="kw">let </span><span class="kw-2">mut </span>stream = TcpStream::connect(s.host_with_port()).unwrap();
    stream.write_all(<span class="string">"GET /hello HTTP/1.1\r\n\r\n"</span>.as_bytes()).unwrap();
    <span class="kw">let </span><span class="kw-2">mut </span>response = String::new();
    stream.read_to_string(<span class="kw-2">&amp;mut </span>response).unwrap();
    stream.flush().unwrap();
}

mock.assert();</code></pre></div>
<p>You can also work with ranges, by using the <a href="struct.Mock.html#method.expect_at_least" title="method mockito::Mock::expect_at_least"><code>Mock::expect_at_least</code></a> and <a href="struct.Mock.html#method.expect_at_most" title="method mockito::Mock::expect_at_most"><code>Mock::expect_at_most</code></a> methods:</p>
<h3 id="example-19"><a class="doc-anchor" href="#example-19">ยง</a>Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::net::TcpStream;
<span class="kw">use </span>std::io::{Read, Write};

<span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();

<span class="kw">let </span>mock = s.mock(<span class="string">"GET"</span>, <span class="string">"/hello"</span>).expect_at_least(<span class="number">2</span>).expect_at_most(<span class="number">4</span>).create();

<span class="kw">for _ in </span><span class="number">0</span>..<span class="number">3 </span>{
    <span class="comment">// Place a request
    </span><span class="kw">let </span><span class="kw-2">mut </span>stream = TcpStream::connect(s.host_with_port()).unwrap();
    stream.write_all(<span class="string">"GET /hello HTTP/1.1\r\n\r\n"</span>.as_bytes()).unwrap();
    <span class="kw">let </span><span class="kw-2">mut </span>response = String::new();
    stream.read_to_string(<span class="kw-2">&amp;mut </span>response).unwrap();
    stream.flush().unwrap();
}

mock.assert();</code></pre></div>
<p>The errors produced by the <a href="struct.Mock.html#method.assert" title="method mockito::Mock::assert"><code>Mock::assert</code></a> method contain information about the tested mock, but also about the
<strong>last unmatched request</strong>, which can be very useful to track down an error in your implementation or
a missing or incomplete mock. A colored diff is also displayed:</p>
<p><img src="https://raw.githubusercontent.com/lipanski/mockito/master/docs/colored-diff.png" alt="colored-diff.png" /></p>
<p>Color output is enabled by default, but can be toggled with the <code>color</code> feature flag.</p>
<p>Hereโs an example of how a <a href="struct.Mock.html#method.assert" title="method mockito::Mock::assert"><code>Mock::assert</code></a> error looks like:</p>
<div class="example-wrap"><pre class="language-text"><code>&gt; Expected 1 request(s) to:

POST /users?number=one
bob

...but received 0

&gt; The last unmatched request was:

POST /users?number=two
content-length: 5
alice

&gt; Difference:

# A colored diff
</code></pre></div>
<p>You can also use the <a href="struct.Mock.html#method.matched" title="method mockito::Mock::matched"><code>Mock::matched</code></a> method to return a boolean for whether the mock was called the
correct number of times without panicking</p>
<h3 id="example-20"><a class="doc-anchor" href="#example-20">ยง</a>Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::net::TcpStream;
<span class="kw">use </span>std::io::{Read, Write};

<span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();

<span class="kw">let </span>mock = s.mock(<span class="string">"GET"</span>, <span class="string">"/"</span>).create();

{
    <span class="kw">let </span><span class="kw-2">mut </span>stream = TcpStream::connect(s.host_with_port()).unwrap();
    stream.write_all(<span class="string">"GET / HTTP/1.1\r\n\r\n"</span>.as_bytes()).unwrap();
    <span class="kw">let </span><span class="kw-2">mut </span>response = String::new();
    stream.read_to_string(<span class="kw-2">&amp;mut </span>response).unwrap();
    stream.flush().unwrap();
}

<span class="macro">assert!</span>(mock.matched());

{
    <span class="kw">let </span><span class="kw-2">mut </span>stream = TcpStream::connect(s.host_with_port()).unwrap();
    stream.write_all(<span class="string">"GET / HTTP/1.1\r\n\r\n"</span>.as_bytes()).unwrap();
    <span class="kw">let </span><span class="kw-2">mut </span>response = String::new();
    stream.read_to_string(<span class="kw-2">&amp;mut </span>response).unwrap();
    stream.flush().unwrap();
}
<span class="macro">assert!</span>(!mock.matched());</code></pre></div>
<h2 id="non-matching-calls"><a class="doc-anchor" href="#non-matching-calls">ยง</a>Non-matching calls</h2>
<p>Any calls to the Mockito server that are not matched will return <em>501 Not Implemented</em>.</p>
<p>Note that <strong>mocks are matched in reverse order</strong> - the most recent one wins.</p>
<h2 id="cleaning-up"><a class="doc-anchor" href="#cleaning-up">ยง</a>Cleaning up</h2>
<p>As mentioned earlier, mocks are cleaned up whenever the server goes out of scope. If you
need to remove them earlier, you can call <a href="struct.Server.html#method.reset" title="method mockito::Server::reset"><code>Server::reset</code></a> to remove all mocks registered
so far:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();

s.mock(<span class="string">"GET"</span>, <span class="string">"/1"</span>).create();
s.mock(<span class="string">"GET"</span>, <span class="string">"/2"</span>).create();
s.mock(<span class="string">"GET"</span>, <span class="string">"/3"</span>).create();

s.reset();

<span class="comment">// Nothing is mocked at this point</span></code></pre></div>
<p>โฆor you can call <a href="struct.Mock.html#method.remove" title="method mockito::Mock::remove"><code>Mock::remove</code></a> to remove a single mock:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = mockito::Server::new();

<span class="kw">let </span>m1 = s.mock(<span class="string">"GET"</span>, <span class="string">"/1"</span>).create();
<span class="kw">let </span>m2 = s.mock(<span class="string">"GET"</span>, <span class="string">"/2"</span>).create();

m1.remove();

<span class="comment">// Only m2 is available at this point</span></code></pre></div>
<h2 id="debug"><a class="doc-anchor" href="#debug">ยง</a>Debug</h2>
<p>Mockito uses the <code>env_logger</code> crate under the hood to provide useful debugging information.</p>
<p>If youโd like to activate the debug output, introduce the <a href="https://crates.rs/crates/env_logger">env_logger</a> crate
to your project and initialize it before each test that needs debugging:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>example_test() {
    <span class="kw">let _ </span>= env_logger::try_init();
    <span class="comment">// ...
</span>}</code></pre></div>
<p>Run your tests with:</p>
<div class="example-wrap"><pre class="language-sh"><code>RUST_LOG=mockito=debug cargo test</code></pre></div></div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Error.html" title="struct mockito::Error">Error</a></dt><dd>Contains information about an error occurence</dd><dt><a class="struct" href="struct.Mock.html" title="struct mockito::Mock">Mock</a></dt><dd>Stores information about a mocked request. Should be initialized via <code>Server::mock()</code>.</dd><dt><a class="struct" href="struct.Request.html" title="struct mockito::Request">Request</a></dt><dd>Stores a HTTP request</dd><dt><a class="struct" href="struct.Server.html" title="struct mockito::Server">Server</a></dt><dd>One instance of the mock server.</dd><dt><a class="struct" href="struct.ServerGuard.html" title="struct mockito::ServerGuard">Server<wbr>Guard</a></dt><dd>A handle around a pooled <code>Server</code> object which dereferences to <code>Server</code>.</dd><dt><a class="struct" href="struct.ServerOpts.html" title="struct mockito::ServerOpts">Server<wbr>Opts</a></dt><dd>Options to configure a mock server. Provides a default implementation.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="enum" href="enum.ErrorKind.html" title="enum mockito::ErrorKind">Error<wbr>Kind</a></dt><dd>The type of an error</dd><dt><a class="enum" href="enum.Matcher.html" title="enum mockito::Matcher">Matcher</a></dt><dd>Allows matching the request path, headers or body in multiple ways: by the exact value, by any value (as
long as it is present), by regular expression or by checking that a particular header is missing.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="trait" href="trait.IntoHeaderName.html" title="trait mockito::IntoHeaderName">Into<wbr>Header<wbr>Name</a></dt></dl></section></div></main></body></html>