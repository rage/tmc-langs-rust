searchState.loadedDescShard("nom", 0, "nom, eating data byte by byte\nImplementation of <code>Parser::and</code>\nImplementation of <code>Parser::and_then</code>\nHelper trait for types that can be viewed as a byte slice\nTransforms common types to a char for basic token parsing\nAbstracts comparison operations\nIndicates wether a comparison was successful, an error, or …\nThe <code>Err</code> enum indicates the parser was not successful\nContains the error value\nThe parser had an error (recoverable)\nComparison failed\nEquivalent From implementation to avoid orphan rules in …\nAbstracts something which can extend an <code>Extend</code>. Used to …\nThe type that will be produced\nThe parser had an unrecoverable error: we got to the right …\nLook for a substring in self\nLook for a token in self\nHelper trait to convert a parser’s result to a more …\nImplementation of <code>Parser::flat_map</code>\nHelper trait to show a byte slice as a hex dump\nHolds the result of parsing functions\nThere was not enough data\nWe need more data to be sure\nAbstracts common iteration operations on the input type\nAbstract method to calculate the input length\nAbstracts slicing operations\nMethods to take as much input as possible until the …\nImplementation of <code>Parser::into</code>\nThe current input type is a sequence of that <code>Item</code> type.\nThe current input type is a sequence of that <code>Item</code> type.\nThe current input type is a sequence of that <code>Item</code> type.\nAn iterator over the input type, producing the item and …\nAn iterator over the input type, producing the item\nImplementation of <code>Parser::map</code>\nContains information on needed data if a parser returned …\nUseful functions to calculate the offset between slices …\nContains the success value\nComparison was successful\nImplementation of <code>Parser::or</code>\nUsed to integrate <code>str</code>’s <code>parse()</code> method\nAll nom parsers implement this trait\nContains the required data size in bytes\nSlicing operations using ranges.\nHelper trait to convert numbers to usize.\nNeeds more data, but we do not know how much\nDummy trait used for default implementations (currently …\nAdd an error if the child parser fails.\nTry a list of parsers and return the result of the first …\nApplies a second parser after the first one, return their …\nApplies a second parser after the first one, return their …\nApplies a second parser over the output of the first one\nApplies a second parser over the output of the first one\nCasts the input type to a byte slice\nmakes a char from self\nBit level parsers\nTransforms its byte slice input into a bit stream for the …\nChoice combinators\nParsers recognizing bytes streams\nCounterpart to <code>bits</code>, <code>bytes!</code> transforms its bit stream …\nUsed to wrap common expressions and function as macros.\nMatches one character: …\nCharacter specific parsers and combinators\nGeneral purpose combinators\nCompares self to another value for equality\nCompares self to another value for equality independently …\nReplaces a <code>Incomplete</code> returned by the child parser with an …\n…\nTransform to another error type\nAutomatically converts between errors if the underlying …\n<code>count!(I -&gt; IResult&lt;I,O&gt;, nb) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code> …\nPrints a message if the parser fails.\nPrints a message if the parser fails.\nPrints a message and the input if the parser fails.\nPrints a message and the input if the parser fails.\nPrints a message and the input if the parser fails.\n…\n…\n<code>eof!()</code> returns its input if it is at the end of input data.\nError management\nCreates a parse error from a <code>nom::ErrorKind</code>, the position …\nCreates a parse error from a <code>nom::ErrorKind</code> and the …\n…\n…\n<code>exact!()</code> will fail if the child parser does not consume …\nAccumulate the input into an accumulator\nReturns the byte position of the substring if it is found\nReturns true if self contains the token\nconverts the parser’s result to a type that is more …\ntranslate parser result from IResult&lt;I,O,u32&gt; to IResult&lt;…\nCreates a second parser from the output of the first one, …\nCreates a second parser from the output of the first one, …\n…\n…\n…\n…\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf the parameter is <code>nom::number::Endianness::Big</code>, parse a …\nIf the parameter is <code>nom::number::Endianness::Big</code>, parse a …\nIf the parameter is <code>nom::number::Endianness::Big</code>, parse a …\nIf the parameter is <code>nom::number::Endianness::Big</code>, parse a …\nCalculates the input length, as indicated by its name, and …\nautomatically converts the parser’s output and error …\nautomatically converts the parser’s output and error …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>into!(I -&gt; IResult&lt;I, O1, E1&gt;) =&gt; I -&gt; IResult&lt;I, O2, E2&gt;</code> …\n<code>is_a!(&amp;[T]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code> returns the …\nTests that self is an alphabetic character\nTests that self is an alphabetic character or a decimal …\nTests that self is a decimal digit\nTests that self is an hex digit\nTests if the result is Incomplete\nIndicates if we know how many bytes we need\n<code>is_not!(&amp;[T:AsBytes]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code> …\nTests that self is an octal digit\nReturns an iterator over the elements\nReturns an iterator over the elements and their byte …\nGets the len in bytes for self\n…\n<code>length_data!(I -&gt; IResult&lt;I, nb&gt;) =&gt; O</code>\n…\nLib module to re-export everything needed from <code>std</code> or <code>core</code>/…\n<code>many0!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code> …\n<code>many0_count!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, usize&gt;</code> …\n<code>many1!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code> …\n<code>many1_count!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, usize&gt;</code> …\n…\n…\nMaps a function over the result of a parser\nMaps a function over the result of a parser\nMaps a <code>Needed</code> to <code>Needed</code> by applying a function to a …\nApplies the given function to the inner error\n<code>map!(I -&gt; IResult&lt;I, O&gt;, O -&gt; P) =&gt; I -&gt; IResult&lt;I, P&gt;</code>\nMaps <code>Err&lt;(T, ErrorKind)&gt;</code> to <code>Err&lt;(U, ErrorKind)&gt;</code> with the …\n…\n…\nCombinators applying their child parser multiple times\nMakes a function from a parser combination\nMakes a function from a parser combination with arguments.\nMakes a function from a parser combination, with …\nCreates <code>Needed</code> instance, returns <code>Needed::Unknown</code> if the …\nCreate a new <code>Extend</code> of the correct type\nMatches anything but the provided characters.\n<code>not!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, ()&gt;</code> returns a …\nParsers recognizing numbers\nOffset between the first byte of self and the first byte …\nCharacter level parsers Matches one of the provided …\n<code>opt!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code> make …\n…\nApplies a second parser over the input if the first one …\nApplies a second parser over the input if the first one …\n…\nA parser takes in input type, and returns a <code>Result</code> …\nSucceeds if <code>parse()</code> succeeded. The byte slice …\n<code>parse_to!(O) =&gt; I -&gt; IResult&lt;I, O&gt;</code> Uses the <code>parse</code> method …\n<code>peek!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code> returns a …\n…\nFinds the byte position of the element\n…\n<code>recognize!(I -&gt; IResult&lt;I, O&gt; ) =&gt; I -&gt; IResult&lt;I, I&gt;</code> if …\nPrevents backtracking if the child parser fails.\n…\n…\n…\nCombinators applying parsers in sequence\nSlices self according to the range argument\nGet the byte offset from the element’s position in the …\nLooks for the first element of the input type for which …\nLooks for the first element of the input type for which …\nLooks for the first element of the input type for which …\nLooks for the first element of the input type for which …\n…\n<code>tag!(&amp;[T]: nom::AsBytes) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code> …\nMatches the given bit pattern.\n<code>tag_no_case!(&amp;[T]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code> declares …\nReturns a slice of <code>count</code> bytes. panics if count &gt; length\n<code>take!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code> generates a …\nConsumes the specified number of bits and returns them as …\nSplit the stream at the <code>count</code> byte offset. panics if count …\n<code>take_str!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;str&gt;</code> same as <code>take!</code> …\n<code>take_till!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code> …\n<code>take_till1!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code> …\n<code>take_until!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code> consumes …\n<code>take_until1!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code> consumes …\n<code>take_while!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code> …\n<code>take_while1!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code> …\n…\n…\n…\nConverts the value of <code>self</code> to a hex dump, returning the …\nConverts the value of <code>self</code> to a hex dump beginning at <code>from</code> …\nObtaining ownership\nAutomatically converts between errors if the underlying …\nconverts self to usize\nA bit like <code>std::try!</code>, this macro will return the remaining …\n…\nIf the parameter is <code>nom::number::Endianness::Big</code>, parse a …\nIf the parameter is <code>nom::number::Endianness::Big</code>, parse a …\nIf the parameter is <code>nom::number::Endianness::Big</code>, parse a …\nIf the parameter is <code>nom::number::Endianness::Big</code>, parse a …\n<code>value!(T, R -&gt; IResult&lt;R, S&gt; ) =&gt; R -&gt; IResult&lt;R, T&gt;</code>\n…\nConverts a byte-level input to a bit-level input, for …\nCounterpart to <code>bits</code>, <code>bytes</code> transforms its bit stream input …\nBit level parsers\nBit level parsers\nGenerates a parser taking <code>count</code> bits and comparing them to …\nGenerates a parser taking <code>count</code> bits\nGenerates a parser taking <code>count</code> bits and comparing them to …\nGenerates a parser taking <code>count</code> bits\nHelper trait for the alt() combinator.\nHelper trait for the permutation() combinator.\nTests a list of parsers one by one until one succeeds.\nTests each parser in the tuple and returns the result of …\nApplies a list of parsers in any order.\nTries to apply all parsers in the tuple in various orders …\nParsers recognizing bytes streams, complete input version\nParsers recognizing bytes streams, streaming version\nMatches a byte string with escaped characters.\nMatches a byte string with escaped characters.\nReturns the longest slice of the matches the pattern.\nParse till certain characters are met.\nRecognizes a pattern\nRecognizes a case insensitive pattern.\nReturns an input slice containing the first N input …\nReturns the longest input slice (if any) till a predicate …\nReturns the longest (at least 1) input slice till a …\nReturns the input slice up to the first occurrence of the …\nReturns the longest input slice (if any) that matches the …\nReturns the longest (at least 1) input slice that matches …\nReturns the longest (m &lt;= len &lt;= n) input slice  that …\nMatches a byte string with escaped characters.\nMatches a byte string with escaped characters.\nReturns the longest slice of the matches the pattern.\nParse till certain characters are met.\nRecognizes a pattern.\nRecognizes a case insensitive pattern.\nReturns an input slice containing the first N input …\nReturns the longest input slice (if any) till a predicate …\nReturns the longest (at least 1) input slice till a …\nReturns the input slice up to the first occurrence of the …\nReturns the longest input slice (if any) that matches the …\nReturns the longest (at least 1) input slice that matches …\nReturns the longest (m &lt;= len &lt;= n) input slice  that …\nCharacter specific parsers and combinators, complete input …\nTests if byte is ASCII alphabetic: A-Z, a-z\nTests if byte is ASCII alphanumeric: A-Z, a-z, 0-9\nTests if byte is ASCII digit: 0-9\nTests if byte is ASCII hex digit: 0-9, A-F, a-f\nTests if byte is ASCII newline: \\n\nTests if byte is ASCII octal digit: 0-7\nTests if byte is ASCII space or tab\nCharacter specific parsers and combinators, streaming …\nRecognizes zero or more lowercase and uppercase ASCII …\nRecognizes one or more lowercase and uppercase ASCII …\nRecognizes zero or more ASCII numerical and alphabetic …\nRecognizes one or more ASCII numerical and alphabetic …\nMatches one byte as a character. Note that the input type …\nRecognizes one character.\nRecognizes the string “\\r\\n”.\nRecognizes zero or more ASCII numerical characters: 0-9\nRecognizes one or more ASCII numerical characters: 0-9\nRecognizes zero or more ASCII hexadecimal numerical …\nRecognizes one or more ASCII hexadecimal numerical …\nRecognizes an end of line (both ‘\\n’ and ‘\\r\\n’).\nRecognizes zero or more spaces, tabs, carriage returns and …\nRecognizes one or more spaces, tabs, carriage returns and …\nMatches a newline character ‘\\n’.\nRecognizes a character that is not in the provided …\nRecognizes a string of any char except ‘\\r\\n’ or ‘\\n…\nRecognizes zero or more octal characters: 0-7\nRecognizes one or more octal characters: 0-7\nRecognizes one of the provided characters.\nRecognizes one character and checks that it satisfies a …\nRecognizes zero or more spaces and tabs.\nRecognizes one or more spaces and tabs.\nMatches a tab character ‘\\t’.\nRecognizes zero or more lowercase and uppercase ASCII …\nRecognizes one or more lowercase and uppercase ASCII …\nRecognizes zero or more ASCII numerical and alphabetic …\nRecognizes one or more ASCII numerical and alphabetic …\nMatches one byte as a character. Note that the input type …\nRecognizes one character.\nRecognizes the string “\\r\\n”.\nRecognizes zero or more ASCII numerical characters: 0-9\nRecognizes one or more ASCII numerical characters: 0-9\nRecognizes zero or more ASCII hexadecimal numerical …\nRecognizes one or more ASCII hexadecimal numerical …\nRecognizes an end of line (both ‘\\n’ and ‘\\r\\n’).\nRecognizes zero or more spaces, tabs, carriage returns and …\nRecognizes one or more spaces, tabs, carriage returns and …\nMatches a newline character ‘\\n’.\nRecognizes a character that is not in the provided …\nRecognizes a string of any char except ‘\\r\\n’ or ‘\\n…\nRecognizes zero or more octal characters: 0-7\nRecognizes one or more octal characters: 0-7\nRecognizes one of the provided characters.\nRecognizes one character and checks that it satisfies a …\nRecognizes zero or more spaces and tabs.\nRecognizes one or more spaces and tabs.\nMatches a tab character ‘\\t’.\nMain structure associated to the iterator function.\nSucceeds if all the input has been consumed by its child …\nTransforms Incomplete into <code>Error</code>.\nCalls the parser if the condition is met.\nif the child parser was successful, return the consumed …\ntransforms an error to failure\nreturns its input if it is at the end of input data\nReturns the remaining input if parsing was successful, or …\nCreates a new parser from the output of the first parser, …\nReturns the argument unchanged.\nautomatically converts the child parser’s result to …\nCalls <code>U::from(self)</code>.\nCreates an iterator from input data and a parser.\nMaps a function on the result of a parser.\nApplies a function returning an <code>Option</code> over the result of …\nApplies a parser over the result of another one.\nApplies a function returning a <code>Result</code> over the result of a …\nSucceeds if the child parser returns an error.\nOptional parser: Will return <code>None</code> if not successful.\nTries to apply its parser without consuming the input.\nIf the child parser was successful, return the consumed …\nReturn the remaining input.\nReturn the length of the remaining input.\na parser which always succeeds with given value without …\nReturns the provided value if the child parser succeeds.\nReturns the result of the child parser if it satisfies a …\nIndicates which character was expected by the <code>char</code> function\nStatic string added by the <code>context</code> function\nThis trait is required by the <code>context</code> combinator to add a …\ndefault error type, only contains the error’ location …\nIndicates which parser returned an error\nThis trait is required by the [map_res] combinator to …\nError kind given by various nom parsers\nThis trait must be implemented by the error type of a nom …\nThis error type accumulates errors and their position when …\nError context for <code>VerboseError</code>\nCreates a new error from an input position, a static …\nCombines an existing error with a new one created from the …\nCombines an existing error with a new one created from the …\nnom error code\nCreate a new error from an input position, a static string …\nTransforms a <code>VerboseError</code> into a trace with input position …\nConverts an ErrorKind to a text description\nConverts an ErrorKind to a number\nList of errors accumulated by <code>VerboseError</code>, containing the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates an error from an input position and an expected …\nCreates an error from the input position and an ErrorKind\nCreates a new error from an input position, an ErrorKind …\nCreate a new error from an input position and an external …\nCreate a new error from an input position and an external …\nposition of the error in the input data\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates an error from the input position and an ErrorKind\ncreates a new basic error\nCombines two existing errors. This function is used to …\ninternal std exports for no_std compatibility\nRuns the embedded parser a specified number of times. …\nRuns the embedded parser repeatedly, filling the given …\nApplies a parser until it fails and accumulates the …\nApplies a parser until it fails and accumulates the …\nApplies a parser <code>n</code> times or until it fails and accumulates …\nGets a number from the first parser, then applies the …\nGets a number from the parser and returns a subslice of …\nGets a number from the first parser, takes a subslice of …\nRepeats the embedded parser until it fails and returns the …\nRepeats the embedded parser until it fails and returns the …\nRuns the embedded parser until it fails and returns the …\nRepeats the embedded parser until it fails and returns the …\nRepeats the embedded parser <code>n</code> times or until it fails and …\nApplies the parser <code>f</code> until the parser <code>g</code> produces a result. …\nAlternates between two parsers to produce a list of …\nAlternates between two parsers to produce a list of …\nBig endian\nConfigurable endianness\nLittle endian\nWill match the host’s endianness\nParsers recognizing numbers, complete input version\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nParsers recognizing numbers, streaming version\nRecognizes a big endian 4 bytes floating point number.\nRecognizes a big endian 8 bytes floating point number.\nRecognizes a big endian signed 16 bytes integer.\nRecognizes a big endian signed 2 bytes integer.\nRecognizes a big endian signed 3 bytes integer.\nRecognizes a big endian signed 4 bytes integer.\nRecognizes a big endian signed 8 bytes integer.\nRecognizes a signed 1 byte integer.\nRecognizes a big endian unsigned 16 bytes integer.\nRecognizes a big endian unsigned 2 bytes integer.\nRecognizes a big endian unsigned 3 byte integer.\nRecognizes a big endian unsigned 4 bytes integer.\nRecognizes a big endian unsigned 8 bytes integer.\nRecognizes an unsigned 1 byte integer.\nRecognizes floating point number in a byte string and …\nRecognizes a 4 byte floating point number\nRecognizes an 8 byte floating point number\nRecognizes floating point number in a byte string and …\nRecognizes a hex-encoded integer.\nRecognizes a signed 16 byte integer\nRecognizes a signed 2 byte integer\nRecognizes a signed 3 byte integer\nRecognizes a signed 4 byte integer\nRecognizes a signed 8 byte integer\nRecognizes a signed 1 byte integer\nRecognizes a little endian 4 bytes floating point number.\nRecognizes a little endian 8 bytes floating point number.\nRecognizes a little endian signed 16 bytes integer.\nRecognizes a little endian signed 2 bytes integer.\nRecognizes a little endian signed 3 bytes integer.\nRecognizes a little endian signed 4 bytes integer.\nRecognizes a little endian signed 8 bytes integer.\nRecognizes a signed 1 byte integer.\nRecognizes a little endian unsigned 16 bytes integer.\nRecognizes a little endian unsigned 2 bytes integer.\nRecognizes a little endian unsigned 3 byte integer.\nRecognizes a little endian unsigned 4 bytes integer.\nRecognizes a little endian unsigned 8 bytes integer.\nRecognizes an unsigned 1 byte integer.\nRecognizes floating point number in a byte string and …\nRecognizes an unsigned 16 byte integer\nRecognizes an unsigned 2 bytes integer\nRecognizes an unsigned 3 byte integer\nRecognizes an unsigned 4 byte integer\nRecognizes an unsigned 8 byte integer\nRecognizes an unsigned 1 byte integer\nRecognizes a big endian 4 bytes floating point number.\nRecognizes a big endian 8 bytes floating point number.\nRecognizes a big endian signed 16 bytes integer.\nRecognizes a big endian signed 2 bytes integer.\nRecognizes a big endian signed 3 bytes integer.\nRecognizes a big endian signed 4 bytes integer.\nRecognizes a big endian signed 8 bytes integer.\nRecognizes a signed 1 byte integer.\nRecognizes a big endian unsigned 16 bytes integer.\nRecognizes a big endian unsigned 2 bytes integer.\nRecognizes a big endian unsigned 3 byte integer.\nRecognizes a big endian unsigned 4 bytes integer.\nRecognizes a big endian unsigned 8 bytes integer.\nRecognizes an unsigned 1 byte integer.\nRecognizes floating point number in a byte string and …\nRecognizes a 4 byte floating point number\nRecognizes an 8 byte floating point number\nRecognizes floating point number in a byte string and …\nRecognizes a hex-encoded integer.\nRecognizes a signed 16 byte integer\nRecognizes a signed 2 byte integer\nRecognizes a signed 3 byte integer\nRecognizes a signed 4 byte integer\nRecognizes a signed 8 byte integer\nRecognizes a signed 1 byte integer\nRecognizes a little endian 4 bytes floating point number.\nRecognizes a little endian 8 bytes floating point number.\nRecognizes a little endian signed 16 bytes integer.\nRecognizes a little endian signed 2 bytes integer.\nRecognizes a little endian signed 3 bytes integer.\nRecognizes a little endian signed 4 bytes integer.\nRecognizes a little endian signed 8 bytes integer.\nRecognizes a signed 1 byte integer.\nRecognizes a little endian unsigned 16 bytes integer.\nRecognizes a little endian unsigned 2 bytes integer.\nRecognizes a little endian unsigned 3 bytes integer.\nRecognizes a little endian unsigned 4 bytes integer.\nRecognizes a little endian unsigned 8 bytes integer.\nRecognizes an unsigned 1 byte integer.\nRecognizes a floating point number in text format and …\nRecognizes an unsigned 16 byte integer\nRecognizes an unsigned 2 bytes integer\nRecognizes an unsigned 3 byte integer\nRecognizes an unsigned 4 byte integer\nRecognizes an unsigned 8 byte integer\nRecognizes an unsigned 1 byte integer\nHelper trait for the tuple combinator.\nMatches an object from the first parser and discards it, …\nGets an object from the first parser, then gets another …\nParses the input and returns a tuple of results of each …\nMatches an object from the first parser and discards it, …\nGets an object from the first parser, then matches an …\nGets an object from the first parser, then matches an …\nApplies a tuple of parsers one by one and returns their …")