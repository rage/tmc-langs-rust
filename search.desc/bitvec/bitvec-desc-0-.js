searchState.loadedDescShard("bitvec", 0, "Addressable Bits\nA fixed-size region viewed as individual bits, …\nConstructs a <code>BitArray</code> wrapper out of a literal array in …\nConstructs a <code>BitBox</code> out of a literal array in source code, …\nConstructs a <code>BitSlice</code> handle out of a literal array in …\nConstructs a <code>BitVec</code> out of a literal array in source code, …\nA dynamically-allocated, fixed-size, buffer containing a …\nRepresentation of the <code>BitSlice</code> region memory model\nParallel bitfield access.\nTyped metadata of registers.\nConstructor macros for the crate’s collection types.\nDescriptions of integer types\nOrdering of bits within register elements.\n<code>bitvec</code> symbol export\nA dynamically-sized view into individual bits of a memory …\nMemory modeling.\nA dynamically-allocated buffer containing a <code>BitSlice&lt;O, T&gt;</code> …\nView constructors for memory regions.\nAn array of individual bits, able to be held by value on …\nViews the array as a bit-slice.\nViews the array as a mutable bit-slice.\nViews the array as a mutable slice of its underlying …\nViews the array as a mutable slice of its raw underlying …\nViews the array as a slice of its raw underlying memory …\nViews the array as a slice of its underlying elements.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConstructs a new <code>BitArray</code> from a data store.\nRemoves the bit-array wrapper, returning the contained …\nConstructs a new <code>BitArray</code> with zeroed memory.\nA frozen heap-allocated buffer of individual bits.\nViews the buffer’s contents as a <code>BitSlice</code>.\nExtracts a mutable bit-slice of the entire vector.\nExtracts a mutable slice of the entire box.\nExtracts an element slice containing the entire box.\nReturns the argument unchanged.\nClones a <code>&amp;BitSlice</code> into a <code>BitVec</code>.\nConverts a <code>Box&lt;[T]&gt;</code> into a <code>BitBox</code>&lt;O, T&gt;` without copying …\nConstructs a box from a raw pointer.\nCalls <code>U::from(self)</code>.\nConverts <code>self</code> into a vector without clones or allocation.\nConverts the slice back into an ordinary slice of memory …\nConsumes the <code>BitBox</code>, returning a wrapped raw pointer.\nConsumes and leaks the <code>BitBox</code>, returning a mutable …\nAllocates memory on the heap and copies <code>x</code> into it.\nConstructs a new <code>Pin&lt;BitBox&lt;O, T&gt;&gt;</code>.\nSets the uninitialized bits of the vector to a fixed value.\nConverts a <code>Box&lt;[T]&gt;</code> into a <code>BitBox&lt;O, T&gt;</code> without copying …\nGranular representation of the memory region containing a …\nGranular representation of the memory region containing a …\nGranular representation of the memory region containing a …\nGranular representation of the memory region containing a …\nIndicates that a <code>BitSlice</code> is contained entirely in the …\nIndicates that a <code>BitSlice</code> is contained entirely in the …\nIndicates that a <code>BitSlice</code> is contained entirely in the …\nIndicates that a <code>BitSlice</code> is contained entirely in the …\nIndicates that a <code>BitSlice</code> region touches at least one edge …\nIndicates that a <code>BitSlice</code> region touches at least one edge …\nIndicates that a <code>BitSlice</code> region touches at least one edge …\nIndicates that a <code>BitSlice</code> region touches at least one edge …\nAttempts to view the domain as an enclave variant.\nAttempts to view the domain as an enclave variant.\nAttempts to view the domain as an enclave variant.\nAttempts to view the domain as an enclave variant.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAttempts to view the domain as a region variant.\nAttempts to view the domain as a region variant.\nAttempts to view the domain as the region variant.\nAttempts to view the domain as the region variant.\nThe original <code>BitSlice</code> used to create this bit-domain view.\nAny bits inside elements that the source bitslice …\nThe start index of the <code>BitSlice</code>.\nAny bits that partially-fill the base element of the slice …\nThe end index of the <code>BitSlice</code>.\nAny bits that partially fill the last element of the slice …\nThe original <code>BitSlice</code> used to create this bit-domain view.\nAny bits inside elements that the source bitslice …\nThe start index of the <code>BitSlice</code>.\nAny bits that partially-fill the base element of the slice …\nThe end index of the <code>BitSlice</code>.\nAny bits that partially fill the last element of the slice …\nAll fully-spanned, unaliased, elements.\nAn aliased view of the element containing the <code>BitSlice</code>.\nThe start index of the <code>BitSlice</code>.\nIf the <code>BitSlice</code> started in the interior of its first …\nThe end index of the <code>BitSlice</code>.\nIf the <code>BitSlice</code> ended in the interior of its last element, …\nAll fully-spanned, unaliased, elements.\nAn aliased view of the element containing the <code>BitSlice</code>.\nThe start index of the <code>BitSlice</code>.\nIf the <code>BitSlice</code> started in the interior of its first …\nThe end index of the <code>BitSlice</code>.\nIf the <code>BitSlice</code> ended in the interior of its last element, …\nPerforms C-style bitfield access through a <code>BitSlice</code>.\nLoads the bits in the <code>self</code> region into a local value.\nLoads from <code>self</code>, using big-endian element <code>T</code> ordering.\nLoads from <code>self</code>, using little-endian element <code>T</code> ordering.\nStores a sequence of bits from the user into the domain of …\nStores into <code>self</code>, using big-endian element ordering.\nStores into <code>self</code>, using little-endian element ordering.\nA full mask.\nA semantic index of a single bit within a register <code>R</code>.\nA multi-bit selection mask.\nAn electrical position of a single bit within a register <code>R</code>.\nMarks that an integer can be used in a processor register.\nA one-hot selection mask, to be applied to a register <code>R</code>.\nSemantic index of a dead bit <em>after</em> a live region.\nAn empty mask.\nCreates a new mask with a selector bit activated.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInserts a selector into an existing mask.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nComputes the bit selector for <code>self</code> as an accessor mask.\nConstructs an untyped bitmask from the position counter.\nConverts the selector into a bit mask.\nWraps a value as a known-good position within an <code>R</code> …\nWraps a selector value as a known-good selection of an <code>R</code> …\nWraps any <code>R</code> value as a bit-mask.\nWraps a value as an assumed-good position within an <code>R</code> …\nWraps a selector value as an assumed-good selection of an <code>R</code>…\nComputes the bit position corresponding to <code>self</code> under some …\nConstructs a range over all indices between a start and …\nRanges over all possible selector values.\nComputes the bit selector corresponding to <code>self</code> under an …\nConstructs a one-hot selection mask from the position …\nTests whether a mask contains a given selector bit.\nViews the internal index value.\nViews the internal tail value.\nViews the internal position value.\nViews the internal selector value.\nViews the internal mask value.\nThe value with all of its bits set to <code>1</code>.\nThe bit width of the integer.\nDescription of an integer type.\nThe number of bits required to store an index in the range …\nA mask over all bits that can be used as an index within …\nThe value with only its least significant bit set to <code>1</code>.\nAn ordering over a register.\nA default bit ordering.\nTraverses a register from <code>LSbit</code> to <code>MSbit</code>.\nTraverses a register from <code>MSbit</code> to <code>LSbit</code>.\nConverts a semantic bit index into an electrical bit …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs a multi-bit selector mask for batch operations …\nConverts a semantic bit index into a one-hot selector mask.\nThe base symbols, containing only the minimum needed to …\nMacros available for default export.\nImports trait methods without importing the traits …\nTraits available for default export.\nDatatypes available for default export.\nConstructs a <code>BitArray</code> wrapper out of a literal array in …\nConstructs a <code>BitBox</code> out of a literal array in source code, …\nConstructs a <code>BitSlice</code> handle out of a literal array in …\nConstructs a <code>BitVec</code> out of a literal array in source code, …\nProxy reference type, equivalent to <code>&amp;mut bool</code>.\nA slice of individual bits, anywhere in memory.\nA helper trait used for indexing operations.\nAn iterator over a bit slice in (non-overlapping) chunks (…\nAn iterator over a bit slice in (non-overlapping) chunks (…\nAn iterator over a bit slice in (non-overlapping) mutable …\nAn iterator over a bit slice in (non-overlapping) mutable …\nThe output type for immutable functions.\nImmutable slice iterator\nMutable bit slice iterator.\nThe inclusive maximum length of a <code>BitSlice&lt;_, T&gt;</code>.\nThe inclusive maximum length that a slice <code>[T]</code> can be for …\nThe output type for mutable functions.\nAn iterator over a bit slice in (non-overlapping) chunks (…\nAn iterator over a bit slice in (non-overlapping) chunks (…\nAn iterator over a bit slice in (non-overlapping) mutable …\nAn iterator over a slice in (non-overlapping) mutable …\nAn iterator over subslices separated by bits that match a …\nAn iterator over subslices separated by bits that match a …\nAn iterator over subslices separated by bits that match a …\nAn iterator over subslices separated by bits that match a …\nAn iterator over subslices separated by bits that match a …\nAn iterator over the mutable subslices of the slice which …\nAn iterator over subslices separated by bits that match a …\nAn iterator over subslices separated by bits that match a …\nAn iterator over overlapping subslices of length <code>size</code>.\nTransmute the bitslice to a bitslice of another type, …\nTransmute the bitslice to a bitslice of another type, …\nTests if <em>all</em> bits in the slice domain are set (logical <code>∧</code>…\nTests if <em>any</em> bit in the slice is set (logical <code>∨</code>).\nViews the underlying data as a subslice of the original …\nReturns an unsafe mutable bit-slice pointer to the region.\nReturns a raw bit-slice pointer to the region.\nViews the wholly-filled elements of the <code>BitSlice</code>.\nViews the wholly-filled elements of the <code>BitSlice</code>.\nAccesses the total backing storage of the <code>BitSlice</code>, as a …\nSplits the slice into the logical components of its memory …\nSplits the slice into the logical components of its memory …\nConstructs a <code>&amp;BitSlice</code> reference from its component data.\nConstructs a <code>&amp;mut BitSlice</code> reference from its component …\nReturns an iterator over <code>chunk_size</code> bits of the slice at a …\nReturns an iterator over <code>chunk_size</code> bits of the slice at a …\nReturns an iterator over <code>chunk_size</code> bits of the slice at a …\nReturns an iterator over <code>chunk_size</code> bits of the slice at a …\nCopies the bits from <code>src</code> into <code>self</code>.\nReturns <code>true</code> if the slice contains a subslice that matches …\nCopies all bits from <code>src</code> into <code>self</code>.\nCopies a bit from one index to another without checking …\nCopies bits from one part of the slice to another part of …\nCopies bits from one part of the slice to another part of …\nReturns the number of ones in the memory region backing …\nReturns the number of zeros in the memory region backing …\nSplits the slice into immutable references to its …\nSplits the slice into mutable references to its underlying …\nComputes the electrical distance between the heads of two …\nProduces the empty slice. This is equivalent to <code>&amp;[]</code> for …\nProduces the empty mutable slice. This is equivalent to …\nReturns <code>true</code> if <code>needle</code> is a suffix of the slice.\nReturns the first bit of the slice, or <code>None</code> if it is empty.\nReturns a mutable pointer to the first bit of the slice, …\nApplies a function to each bit in the slice.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs a shared <code>&amp;BitSlice</code> reference over a shared …\nConstructs an exclusive <code>&amp;mut BitSlice</code> reference over an …\nConverts a reference to <code>T</code> into a bitslice over one element.\nForms a bitslice from a pointer and a length.\nPerforms the same functionality as <code>from_raw_parts</code>, except …\nConverts a reference to <code>T</code> into a bitslice over one element.\nConstructs a shared <code>&amp;BitSlice</code> reference over a shared …\nConstructs an exclusive <code>&amp;mut BitSlice</code> reference over a …\nConverts a slice reference into a <code>BitSlice</code> reference …\nConverts a slice reference into a <code>BitSlice</code> reference …\nReturns a shared reference to the output at this location, …\nReturns a reference to an element or subslice depending on …\nReturns a mutable reference to the output at this …\nReturns a mutable reference to an element or subslice …\nReturns a shared reference to the output at this location, …\nReturns a reference to an element or subslice, without …\nReturns a mutable reference to the output at this …\nReturns a mutable reference to the output at this …\nReturns a shared reference to the output at this location, …\nLooks up a single bit by semantic index.\nReturns a mutable reference to the output at this …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nViews the underlying data as a subslice of the original …\nReturns the remainder of the original slice that is not …\nReturns the remainder of the original slice that is not …\nReturns <code>true</code> if the slice has a length of 0.\nReturns an iterator over the slice.\nReturns an iterator that allows modifying each bit.\nReturns the last bit of the slice, or <code>None</code> if it is empty.\nReturns a mutable pointer to the last bit of the slice, or …\nReturns the number of bits in the slice.\nTests if <em>any</em> bit in the slice is unset (logical <code>¬∧</code>).\nTests if <em>all</em> bits in the slice are unset (logical <code>¬∨</code>).\nProduces the absolute offset in bits between two slice …\nReturns an iterator over <code>chunk_size</code> bits of the slice at a …\nReturns an iterator over <code>chunk_size</code> bits of the slice at a …\nReturns an iterator over <code>chunk_size</code> bits of the slice at a …\nReturns an iterator over <code>chunk_size</code> bits of the slice at a …\nReturns the remainder of the original bit slice that is …\nReturns the remainder of the original slice that is not …\nCreates a vector by repeating a slice <code>n</code> times.\nReverses the order of bits in the slice, in place.\nRotates the slice in-place such that the first <code>by</code> bits of …\nRotates the slice in-place such that the first …\nReturns an iterator over subslices separated by bits that …\nReturns an iterator over mutable subslices separated by …\nReturns an iterator over subslices separated by bits that …\nReturns an iterator over subslices separated by bits that …\nSets the bit value at the given position.\nWrites a bit into the proxied location without an …\nSets all bits in the slice to a value.\nSets a bit at an index, without checking boundary …\nTests whether the slice has some, but not all, bits set …\nReturns an iterator over subslices separated by bits that …\nDivides one slice into two at an index.\nSplits a mutable slice at some mid-point.\nDivides one mutable slice into two at an index.\nSplits a slice at some mid-point, without checking …\nSplits a mutable slice at some mid-point, without checking …\nReturns the first and all the rest of the bits of the …\nReturns the first and all the rest of the bits of the …\nReturns the last and all the rest of the bits of the …\nReturns the last and all the rest of the bits of the …\nReturns an iterator over mutable subslices separated by …\nReturns an iterator over subslices separated by bits that …\nReturns an iterator over subslices separated by bits that …\nReturns <code>true</code> if <code>needle</code> is a prefix of the slice.\nSwaps two bits in the slice.\nSwaps the bits at two indices without checking boundary …\nSwaps all bits in <code>self</code> with those in <code>other</code>.\nCopies <code>self</code> into a new <code>BitVec</code>.\nReturns an iterator over all contiguous windows of length …\nThe modifier type over <code>Self::Mem</code> used to perform memory …\nA sibling <code>BitStore</code> implementor that performs alias-aware …\nCommon interface for memory regions.\nThe register type that the implementor describes.\nFetches the value of one bit in a memory element.\nFetches any number of bits from a memory element.\nCopies a memory element into the caller’s local context.\nA vector of individual bits, allocated on the heap.\nA draining iterator for <code>BitVec&lt;O, T&gt;</code>.\nAn iterator that moves out of a vector.\nA splicing iterator for <code>BitVec</code>.\nMoves all the bits of <code>other</code> into <code>self</code>, leaving <code>other</code> empty.\nReturns a raw pointer to the vector’s region.\nViews the buffer’s contents as a <code>BitSlice</code>.\nReturns the remaining bits of this iterator as a bit-slice.\nReturns the remaining bits of this iterator as a bitslice.\nReturns an unsafe mutable pointer to the vector’s region.\nExtracts a mutable bit-slice of the entire vector.\nReturns the remaining bits of this iterator as a mutable …\nReturns an unsafe mutable pointer to the vector’s buffer.\nExtracts a mutable slice of the entire vector.\nReturns a raw pointer to the vector’s buffer.\nExtracts an element slice containing the entire vector.\nReturns the number of bits the vector can hold without …\nClears the vector, removing all values.\nCreates a draining iterator that removes the specified …\nGets the number of elements <code>T</code> that contain live bits of …\nCopies all bits in a <code>BitSlice</code> into the <code>BitVec</code>.\nClones and appends all <code>bool</code>s in a slice to the <code>BitVec</code>.\nEnsures that the live region of the vector’s contents …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nClones a <code>&amp;BitSlice</code> into a <code>BitVec</code>.\nCreates a <code>BitVec&lt;O, T&gt;</code> directly from the raw components of …\nConverts a <code>Vec&lt;T&gt;</code> into a <code>BitVec&lt;O, T&gt;</code> without copying its …\nInserts a bit at position <code>index</code> within the vector, …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the vector into <code>BitBox&lt;O, T&gt;</code>.\nConverts the vector into [<code>Box&lt;[T]&gt;</code>].\nConverts the vector back into an ordinary vector of memory …\nConstructs a new, empty <code>BitVec&lt;O, T&gt;</code>.\nRemoves the last bit from a vector and returns it, or <code>None</code> …\nAppends a bit to the back of a collection.\nRemoves and returns the bit at position <code>index</code> within the …\nConstructs a <code>BitVec</code> from a value repeated many times.\nReserves capacity for at least <code>additional</code> more bits to be …\nReserves the minimum capacity for exactly <code>additional</code> more …\nResizes the <code>BitVec</code> in-place so that <code>len</code> is equal to <code>new_len</code>…\nResizes the <code>BitVec</code> in-place so that <code>len</code> is equal to <code>new_len</code>…\nRetains only the bits specified by the predicate.\nWrites a value into every element that the vector …\nForces the length of the vector to <code>new_len</code>.\nSets the uninitialized bits of the vector to a fixed value.\nShrinks the capacity of the vector as much as possible.\nCreates a splicing iterator that replaces the specified …\nSplits the collection into two at the given index.\nRemoves a bit from the vector and returns it.\nShortens the vector, keeping the first <code>len</code> bits and …\nConverts a <code>Vec&lt;T&gt;</code> into a <code>BitVec&lt;O, T&gt;</code> without copying its …\nConstructs a new, empty <code>BitVec&lt;O, T&gt;</code> with the specified …\nViews a region as an immutable bit-slice only.\nViews a region as a mutable bit-slice.\nViews a type that can store bits as a bit-slice.\nThe underlying register type of the storage region.\nThe access-control type of the storage region.\nViews memory as a slice of immutable bits.\nViews memory as a slice of mutable bits.\nViews a memory region as a <code>BitSlice</code>.\nViews a memory region as a mutable <code>BitSlice</code>.")