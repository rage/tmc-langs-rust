<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate allows cleanly exiting a program using a custom exit code, without the drawbacks of `process::exit`. Destructors will be called as usual, and the stack will be unwound to the main function."><title>quit - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="quit" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../quit/index.html">quit</a><span class="version">1.2.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#functions">Functions</a></li><li><a href="#attributes">Attribute Macros</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">quit</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/quit/lib.rs.html#1-111">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate allows cleanly exiting a program using a custom exit code,
without the drawbacks of <a href="https://doc.rust-lang.org/1.81.0/std/process/fn.exit.html" title="fn std::process::exit"><code>process::exit</code></a>. Destructors will be called as
usual, and the stack will be unwound to the main function.</p>
<p>It is always required to attach <a href="attr.main.html" title="attr quit::main"><code>#[main]</code></a> to the main
function. Then, <a href="fn.with_code.html" title="fn quit::with_code"><code>with_code</code></a> can be called from almost anywhere in the
program. Restrictions are noted in the documentation for that function.</p>
<h2 id="implementation"><a class="doc-anchor" href="#implementation">§</a>Implementation</h2>
<p>Internally, this crate uses panicking to unwind the stack. Thus, if
panicking were set to “abort” instead of the default “unwind”, setting the
exit status would not work correctly. This crate will cause a compile error
in that case, to avoid silent incorrect behavior. Further information can
be found in the <a href="https://rustc-dev-guide.rust-lang.org/panic-implementation.html#step-2-the-panic-runtime">Rustc Development Guide</a>.</p>
<p>Additionally, the program will not exit if <a href="fn.with_code.html" title="fn quit::with_code"><code>with_code</code></a> is called from a
spawned thread, unless panics are propagated from that thread. However,
propagating panics is usually recommended regardless.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::env;

<span class="kw">fn </span>read_args() {
    <span class="kw">if </span>env::args_os().nth(<span class="number">1</span>).is_some() {
        <span class="macro">eprintln!</span>(<span class="string">"too many arguments"</span>);
        quit::with_code(<span class="number">1</span>);
    }
}

<span class="attr">#[quit::main]
</span><span class="kw">fn </span>main() {
    read_args();
}</code></pre></div>
</div></details><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.with_code.html" title="fn quit::with_code">with_code</a></div><div class="desc docblock-short">Cleanly exits the program with an exit code.</div></li></ul><h2 id="attributes" class="section-header">Attribute Macros<a href="#attributes" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="attr" href="attr.main.html" title="attr quit::main">main</a></div><div class="desc docblock-short">Modifies the main function to exit with the code passed to <a href="fn.with_code.html" title="fn quit::with_code"><code>with_code</code></a>.</div></li></ul></section></div></main></body></html>