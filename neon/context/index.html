<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Provides runtime access to the JavaScript engine."><title>neon::context - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="neon" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0 (17067e9ac 2025-05-09)" data-channel="1.87.0" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js" ><script src="../../static.files/storage-82c7156e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../neon/index.html">neon</a><span class="version">1.1.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module context</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#writing-generic-helpers" title="Writing Generic Helpers">Writing Generic Helpers</a></li><li><a href="#memory-management" title="Memory Management">Memory Management</a><ul><li><a href="#temporary-scopes" title="Temporary Scopes">Temporary Scopes</a></li></ul></li><li><a href="#throwing-exceptions" title="Throwing Exceptions">Throwing Exceptions</a></li><li><a href="#see-also" title="See also">See also</a></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate neon</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">neon</a></div><h1>Module <span>context</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/neon/context/mod.rs.html#1-902">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Provides runtime access to the JavaScript engine.</p>
<p>An <em>execution context</em> represents the current state of a thread of execution in the
JavaScript engine. Internally, it tracks things like the set of pending function calls,
whether the engine is currently throwing an exception or not, and whether the engine is
in the process of shutting down. The context uses this internal state to manage what
operations are safely available and when.</p>
<p>The <a href="trait.Context.html" title="trait neon::context::Context"><code>Context</code></a> trait provides an abstract interface to the JavaScript
execution context. All interaction with the JavaScript engine in Neon code is mediated
through instances of this trait.</p>
<p>One particularly useful context type is <a href="struct.FunctionContext.html" title="struct neon::context::FunctionContext"><code>FunctionContext</code></a>, which is passed
to all Neon functions as their initial execution context.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>hello(<span class="kw-2">mut </span>cx: FunctionContext) -&gt; JsResult&lt;JsString&gt; {
    <span class="prelude-val">Ok</span>(cx.string(<span class="string">"hello Neon"</span>))
}</code></pre></div>
<p>Another important context type is <a href="struct.ModuleContext.html" title="struct neon::context::ModuleContext"><code>ModuleContext</code></a>, which is provided
to a Neon module’s <a href="../attr.main.html" title="attr neon::main"><code>main</code></a> function to enable sharing Neon functions back
with JavaScript:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[neon::main]
</span><span class="kw">fn </span>lib(<span class="kw-2">mut </span>cx: ModuleContext) -&gt; NeonResult&lt;()&gt; {
    cx.export_function(<span class="string">"hello"</span>, hello)<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h3 id="writing-generic-helpers"><a class="doc-anchor" href="#writing-generic-helpers">§</a>Writing Generic Helpers</h3>
<p>Depending on the entrypoint, a user may have a <a href="struct.FunctionContext.html" title="struct neon::context::FunctionContext"><code>FunctionContext</code></a>, <a href="struct.ModuleContext.html" title="struct neon::context::ModuleContext"><code>ModuleContext</code></a>, or
generic <a href="struct.Cx.html" title="struct neon::context::Cx"><code>Cx</code></a>. While it is possible to write a helper that is generic over the <a href="trait.Context.html" title="trait neon::context::Context"><code>Context</code></a>
trait, it is often simpler to accept a <a href="struct.Cx.html" title="struct neon::context::Cx"><code>Cx</code></a> argument. Due to deref coercion, other contexts
may be passed into a function that accepts a reference to <a href="struct.Cx.html" title="struct neon::context::Cx"><code>Cx</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>log(cx: <span class="kw-2">&amp;mut </span>Cx, msg: <span class="kw-2">&amp;</span>str) -&gt; NeonResult&lt;()&gt; {
    cx.global::&lt;JsObject&gt;(<span class="string">"console"</span>)<span class="question-mark">?
        </span>.method(cx, <span class="string">"log"</span>)<span class="question-mark">?
        </span>.arg(msg)<span class="question-mark">?
        </span>.exec()<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}

<span class="kw">fn </span>print(<span class="kw-2">mut </span>cx: FunctionContext) -&gt; JsResult&lt;JsUndefined&gt; {
    <span class="kw">let </span>msg = cx.argument::&lt;JsString&gt;(<span class="number">0</span>)<span class="question-mark">?</span>.value(<span class="kw-2">&amp;mut </span>cx);
    log(<span class="kw-2">&amp;mut </span>cx, <span class="kw-2">&amp;</span>msg)<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(cx.undefined())
}</code></pre></div>
<h3 id="memory-management"><a class="doc-anchor" href="#memory-management">§</a>Memory Management</h3>
<p>Because contexts represent the engine at a point in time, they are associated with a
<a href="https://doc.rust-lang.org/book/ch10-00-generics.html"><em>lifetime</em></a>, which limits how long Rust code is allowed to access them. This
is also used to determine the lifetime of <a href="../handle/struct.Handle.html" title="struct neon::handle::Handle"><code>Handle</code></a>s, which
provide safe references to JavaScript memory managed by the engine’s garbage collector.</p>
<p>For example, we can
write a simple string scanner that counts whitespace in a JavaScript string and
returns a <a href="../types/struct.JsNumber.html" title="struct neon::types::JsNumber"><code>JsNumber</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>count_whitespace(<span class="kw-2">mut </span>cx: FunctionContext) -&gt; JsResult&lt;JsNumber&gt; {
    <span class="kw">let </span>s: Handle&lt;JsString&gt; = cx.argument(<span class="number">0</span>)<span class="question-mark">?</span>;
    <span class="kw">let </span>contents = s.value(<span class="kw-2">&amp;mut </span>cx);
    <span class="kw">let </span>count = contents
        .chars()                       <span class="comment">// iterate over the characters
        </span>.filter(|c| c.is_whitespace()) <span class="comment">// select the whitespace chars
        </span>.count();                      <span class="comment">// count the resulting chars
    </span><span class="prelude-val">Ok</span>(cx.number(count <span class="kw">as </span>f64))
}</code></pre></div>
<p>In this example, <code>s</code> is assigned a handle to a string, which ensures that the string
is <em>kept alive</em> (i.e., prevented from having its storage reclaimed by the JavaScript
engine’s garbage collector) for the duration of the <code>count_whitespace</code> function. This
is how Neon takes advantage of Rust’s type system to allow your Rust code to safely
interact with JavaScript values.</p>
<h4 id="temporary-scopes"><a class="doc-anchor" href="#temporary-scopes">§</a>Temporary Scopes</h4>
<p>Sometimes it can be useful to limit the scope of a handle’s lifetime, to allow the
engine to reclaim memory sooner. This can be important when, for example, an expensive inner loop generates
temporary JavaScript values that are only needed inside the loop. In these cases,
the <a href="trait.Context.html#method.execute_scoped" title="method neon::context::Context::execute_scoped"><code>execute_scoped</code></a> and <a href="trait.Context.html#method.compute_scoped" title="method neon::context::Context::compute_scoped"><code>compute_scoped</code></a>
methods allow you to create temporary contexts in order to allocate temporary
handles.</p>
<p>For example, to extract the elements of a JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators">iterator</a> from Rust,
a Neon function has to work with several temporary handles on each pass through
the loop:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="kw">let </span>iterator = cx.argument::&lt;JsObject&gt;(<span class="number">0</span>)<span class="question-mark">?</span>;         <span class="comment">// iterator object
    </span><span class="kw">let </span>next: Handle&lt;JsFunction&gt; =                      <span class="comment">// iterator's `next` method
        </span>iterator.prop(<span class="kw-2">&amp;mut </span>cx, <span class="string">"next"</span>).get()<span class="question-mark">?</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>numbers = <span class="macro">vec!</span>[];                           <span class="comment">// results vector
    </span><span class="kw">let </span><span class="kw-2">mut </span>done = <span class="bool-val">false</span>;                               <span class="comment">// loop controller

    </span><span class="kw">while </span>!done {
        done = cx.execute_scoped(|<span class="kw-2">mut </span>cx| {                   <span class="comment">// temporary scope
            </span><span class="kw">let </span>obj: Handle&lt;JsObject&gt; = next                  <span class="comment">// temporary object
                </span>.bind(<span class="kw-2">&amp;mut </span>cx)
                .this(iterator)<span class="question-mark">?
                </span>.call()<span class="question-mark">?</span>;
            numbers.push(obj.prop(<span class="kw-2">&amp;mut </span>cx, <span class="string">"value"</span>).get()<span class="question-mark">?</span>);  <span class="comment">// temporary number
            </span>obj.prop(<span class="kw-2">&amp;mut </span>cx, <span class="string">"done"</span>).get()                   <span class="comment">// temporary boolean
        </span>})<span class="question-mark">?</span>;
    }</code></pre></div>
<p>The temporary scope ensures that the temporary values are only kept alive
during a single pass through the loop, since the temporary context is
discarded (and all of its handles released) on the inside of the loop.</p>
<h3 id="throwing-exceptions"><a class="doc-anchor" href="#throwing-exceptions">§</a>Throwing Exceptions</h3>
<p>When a Neon API causes a JavaScript exception to be thrown, it returns an
<a href="https://doc.rust-lang.org/1.87.0/core/result/enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a> result, indicating that the thread associated
with the context is now throwing. This allows Rust code to perform any
cleanup before returning, but with an important restriction:</p>
<blockquote>
<p><strong>While a JavaScript thread is throwing, its context cannot be used.</strong></p>
</blockquote>
<p>Unless otherwise documented, any Neon API that uses a context (as <code>self</code> or as
a parameter) immediately panics if called while the context’s thread is throwing.</p>
<p>Typically, Neon code can manage JavaScript exceptions correctly and conveniently
by using Rust’s <a href="https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html">question mark (<code>?</code>)</a> operator. This ensures that
Rust code “short-circuits” when an exception is thrown and returns back to
JavaScript without calling any throwing APIs.</p>
<p>Alternatively, to invoke a Neon API and catch any JavaScript exceptions, use the
<a href="trait.Context.html#method.try_catch" title="method neon::context::Context::try_catch"><code>Context::try_catch</code></a> method, which catches any thrown
exception and restores the context to non-throwing state.</p>
<h3 id="see-also"><a class="doc-anchor" href="#see-also">§</a>See also</h3>
<ol>
<li>Ecma International. <a href="https://tc39.es/ecma262/#sec-execution-contexts">Execution contexts</a>, <em>ECMAScript Language Specification</em>.</li>
<li>Madhavan Nagarajan. <a href="https://medium.com/@itIsMadhavan/what-is-the-execution-context-stack-in-javascript-e169812e851a">What is the Execution Context and Stack in JavaScript?</a></li>
<li>Rupesh Mishra. <a href="https://medium.com/@happymishra66/execution-context-in-javascript-319dd72e8e2c">Execution context, Scope chain and JavaScript internals</a>.</li>
</ol>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Cx.html" title="struct neon::context::Cx">Cx</a></dt><dd>Context representing access to the JavaScript runtime</dd><dt><a class="struct" href="struct.FunctionContext.html" title="struct neon::context::FunctionContext">Function<wbr>Context</a></dt><dd>An execution context of a function call.</dd><dt><a class="struct" href="struct.Lock.html" title="struct neon::context::Lock">Lock</a></dt><dd>A temporary lock of an execution context.</dd><dt><a class="struct" href="struct.ModuleContext.html" title="struct neon::context::ModuleContext">Module<wbr>Context</a></dt><dd>An execution context of module initialization.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.CallKind.html" title="enum neon::context::CallKind">Call<wbr>Kind</a></dt><dd>Indicates whether a function was called with <code>new</code>.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Context.html" title="trait neon::context::Context">Context</a></dt><dd>An <em>execution context</em>, which represents the current state of a thread of execution in the JavaScript engine.</dd></dl></section></div></main></body></html>