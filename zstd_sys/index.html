<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Low-level bindings to the zstd library."><title>zstd_sys - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="zstd_sys" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../zstd_sys/index.html">zstd_sys</a><span class="version">1.4.20+zstd.1.4.9</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#statics">Statics</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Aliases</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">zstd_sys</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/zstd_sys/lib.rs.html#1-48">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Low-level bindings to the <a href="https://facebook.github.io/zstd/">zstd</a> library.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.POOL_ctx_s.html" title="struct zstd_sys::POOL_ctx_s">POOL_ctx_s</a></div></li><li><div class="item-name"><a class="struct" href="struct.ZDICT_cover_params_t.html" title="struct zstd_sys::ZDICT_cover_params_t">ZDICT_cover_params_t</a></div><div class="desc docblock-short">ZDICT_cover_params_t:
k and d are the only required parameters.
For others, value 0 means default.</div></li><li><div class="item-name"><a class="struct" href="struct.ZDICT_fastCover_params_t.html" title="struct zstd_sys::ZDICT_fastCover_params_t">ZDICT_fastCover_params_t</a></div></li><li><div class="item-name"><a class="struct" href="struct.ZDICT_legacy_params_t.html" title="struct zstd_sys::ZDICT_legacy_params_t">ZDICT_legacy_params_t</a></div></li><li><div class="item-name"><a class="struct" href="struct.ZDICT_params_t.html" title="struct zstd_sys::ZDICT_params_t">ZDICT_params_t</a></div></li><li><div class="item-name"><a class="struct" href="struct.ZSTDMT_CCtx_s.html" title="struct zstd_sys::ZSTDMT_CCtx_s">ZSTDMT_CCtx_s</a></div></li><li><div class="item-name"><a class="struct" href="struct.ZSTD_CCtx_params_s.html" title="struct zstd_sys::ZSTD_CCtx_params_s">ZSTD_CCtx_params_s</a></div></li><li><div class="item-name"><a class="struct" href="struct.ZSTD_CCtx_s.html" title="struct zstd_sys::ZSTD_CCtx_s">ZSTD_CCtx_s</a></div></li><li><div class="item-name"><a class="struct" href="struct.ZSTD_CDict_s.html" title="struct zstd_sys::ZSTD_CDict_s">ZSTD_CDict_s</a></div></li><li><div class="item-name"><a class="struct" href="struct.ZSTD_DCtx_s.html" title="struct zstd_sys::ZSTD_DCtx_s">ZSTD_DCtx_s</a></div></li><li><div class="item-name"><a class="struct" href="struct.ZSTD_DDict_s.html" title="struct zstd_sys::ZSTD_DDict_s">ZSTD_DDict_s</a></div></li><li><div class="item-name"><a class="struct" href="struct.ZSTD_Sequence.html" title="struct zstd_sys::ZSTD_Sequence">ZSTD_Sequence</a></div></li><li><div class="item-name"><a class="struct" href="struct.ZSTD_bounds.html" title="struct zstd_sys::ZSTD_bounds">ZSTD_bounds</a></div></li><li><div class="item-name"><a class="struct" href="struct.ZSTD_compressionParameters.html" title="struct zstd_sys::ZSTD_compressionParameters">ZSTD_compressionParameters</a></div></li><li><div class="item-name"><a class="struct" href="struct.ZSTD_customMem.html" title="struct zstd_sys::ZSTD_customMem">ZSTD_customMem</a></div></li><li><div class="item-name"><a class="struct" href="struct.ZSTD_frameHeader.html" title="struct zstd_sys::ZSTD_frameHeader">ZSTD_frameHeader</a></div></li><li><div class="item-name"><a class="struct" href="struct.ZSTD_frameParameters.html" title="struct zstd_sys::ZSTD_frameParameters">ZSTD_frameParameters</a></div></li><li><div class="item-name"><a class="struct" href="struct.ZSTD_frameProgression.html" title="struct zstd_sys::ZSTD_frameProgression">ZSTD_frameProgression</a></div></li><li><div class="item-name"><a class="struct" href="struct.ZSTD_inBuffer_s.html" title="struct zstd_sys::ZSTD_inBuffer_s">ZSTD_inBuffer_s</a></div><div class="desc docblock-short">Streaming</div></li><li><div class="item-name"><a class="struct" href="struct.ZSTD_outBuffer_s.html" title="struct zstd_sys::ZSTD_outBuffer_s">ZSTD_outBuffer_s</a></div></li><li><div class="item-name"><a class="struct" href="struct.ZSTD_parameters.html" title="struct zstd_sys::ZSTD_parameters">ZSTD_parameters</a></div></li><li><div class="item-name"><a class="struct" href="struct.__locale_data.html" title="struct zstd_sys::__locale_data">__locale_data</a></div></li><li><div class="item-name"><a class="struct" href="struct.__locale_struct.html" title="struct zstd_sys::__locale_struct">__locale_struct</a></div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.ZSTD_EndDirective.html" title="enum zstd_sys::ZSTD_EndDirective">ZSTD_EndDirective</a></div></li><li><div class="item-name"><a class="enum" href="enum.ZSTD_ResetDirective.html" title="enum zstd_sys::ZSTD_ResetDirective">ZSTD_ResetDirective</a></div></li><li><div class="item-name"><a class="enum" href="enum.ZSTD_cParameter.html" title="enum zstd_sys::ZSTD_cParameter">ZSTD_cParameter</a></div></li><li><div class="item-name"><a class="enum" href="enum.ZSTD_dParameter.html" title="enum zstd_sys::ZSTD_dParameter">ZSTD_dParameter</a></div><div class="desc docblock-short">Advanced decompression API</div></li><li><div class="item-name"><a class="enum" href="enum.ZSTD_dictAttachPref_e.html" title="enum zstd_sys::ZSTD_dictAttachPref_e">ZSTD_dictAttachPref_e</a></div></li><li><div class="item-name"><a class="enum" href="enum.ZSTD_dictContentType_e.html" title="enum zstd_sys::ZSTD_dictContentType_e">ZSTD_dictContentType_e</a></div></li><li><div class="item-name"><a class="enum" href="enum.ZSTD_dictLoadMethod_e.html" title="enum zstd_sys::ZSTD_dictLoadMethod_e">ZSTD_dictLoadMethod_e</a></div></li><li><div class="item-name"><a class="enum" href="enum.ZSTD_forceIgnoreChecksum_e.html" title="enum zstd_sys::ZSTD_forceIgnoreChecksum_e">ZSTD_forceIgnoreChecksum_e</a></div></li><li><div class="item-name"><a class="enum" href="enum.ZSTD_format_e.html" title="enum zstd_sys::ZSTD_format_e">ZSTD_format_e</a></div></li><li><div class="item-name"><a class="enum" href="enum.ZSTD_frameType_e.html" title="enum zstd_sys::ZSTD_frameType_e">ZSTD_frameType_e</a></div><div class="desc docblock-short">Buffer-less streaming decompression (synchronous mode)</div></li><li><div class="item-name"><a class="enum" href="enum.ZSTD_literalCompressionMode_e.html" title="enum zstd_sys::ZSTD_literalCompressionMode_e">ZSTD_literalCompressionMode_e</a></div></li><li><div class="item-name"><a class="enum" href="enum.ZSTD_nextInputType_e.html" title="enum zstd_sys::ZSTD_nextInputType_e">ZSTD_nextInputType_e</a></div></li><li><div class="item-name"><a class="enum" href="enum.ZSTD_refMultipleDDicts_e.html" title="enum zstd_sys::ZSTD_refMultipleDDicts_e">ZSTD_refMultipleDDicts_e</a></div></li><li><div class="item-name"><a class="enum" href="enum.ZSTD_sequenceFormat_e.html" title="enum zstd_sys::ZSTD_sequenceFormat_e">ZSTD_sequenceFormat_e</a></div></li><li><div class="item-name"><a class="enum" href="enum.ZSTD_strategy.html" title="enum zstd_sys::ZSTD_strategy">ZSTD_strategy</a></div><div class="desc docblock-short">Advanced compression API</div></li></ul><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.AIO_PRIO_DELTA_MAX.html" title="constant zstd_sys::AIO_PRIO_DELTA_MAX">AIO_PRIO_DELTA_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.ARG_MAX.html" title="constant zstd_sys::ARG_MAX">ARG_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.BC_BASE_MAX.html" title="constant zstd_sys::BC_BASE_MAX">BC_BASE_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.BC_DIM_MAX.html" title="constant zstd_sys::BC_DIM_MAX">BC_DIM_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.BC_SCALE_MAX.html" title="constant zstd_sys::BC_SCALE_MAX">BC_SCALE_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.BC_STRING_MAX.html" title="constant zstd_sys::BC_STRING_MAX">BC_STRING_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.CHARCLASS_NAME_MAX.html" title="constant zstd_sys::CHARCLASS_NAME_MAX">CHARCLASS_NAME_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.COLL_WEIGHTS_MAX.html" title="constant zstd_sys::COLL_WEIGHTS_MAX">COLL_WEIGHTS_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.DELAYTIMER_MAX.html" title="constant zstd_sys::DELAYTIMER_MAX">DELAYTIMER_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.EXPR_NEST_MAX.html" title="constant zstd_sys::EXPR_NEST_MAX">EXPR_NEST_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.HOST_NAME_MAX.html" title="constant zstd_sys::HOST_NAME_MAX">HOST_NAME_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.LINE_MAX.html" title="constant zstd_sys::LINE_MAX">LINE_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.LINK_MAX.html" title="constant zstd_sys::LINK_MAX">LINK_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.LOGIN_NAME_MAX.html" title="constant zstd_sys::LOGIN_NAME_MAX">LOGIN_NAME_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.MAX_CANON.html" title="constant zstd_sys::MAX_CANON">MAX_CANON</a></div></li><li><div class="item-name"><a class="constant" href="constant.MAX_INPUT.html" title="constant zstd_sys::MAX_INPUT">MAX_INPUT</a></div></li><li><div class="item-name"><a class="constant" href="constant.MB_LEN_MAX.html" title="constant zstd_sys::MB_LEN_MAX">MB_LEN_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.MQ_PRIO_MAX.html" title="constant zstd_sys::MQ_PRIO_MAX">MQ_PRIO_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.NAME_MAX.html" title="constant zstd_sys::NAME_MAX">NAME_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.NGROUPS_MAX.html" title="constant zstd_sys::NGROUPS_MAX">NGROUPS_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.NR_OPEN.html" title="constant zstd_sys::NR_OPEN">NR_OPEN</a></div></li><li><div class="item-name"><a class="constant" href="constant.PATH_MAX.html" title="constant zstd_sys::PATH_MAX">PATH_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.PIPE_BUF.html" title="constant zstd_sys::PIPE_BUF">PIPE_BUF</a></div></li><li><div class="item-name"><a class="constant" href="constant.PTHREAD_DESTRUCTOR_ITERATIONS.html" title="constant zstd_sys::PTHREAD_DESTRUCTOR_ITERATIONS">PTHREAD_DESTRUCTOR_ITERATIONS</a></div></li><li><div class="item-name"><a class="constant" href="constant.PTHREAD_KEYS_MAX.html" title="constant zstd_sys::PTHREAD_KEYS_MAX">PTHREAD_KEYS_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.PTHREAD_STACK_MIN.html" title="constant zstd_sys::PTHREAD_STACK_MIN">PTHREAD_STACK_MIN</a></div></li><li><div class="item-name"><a class="constant" href="constant.RE_DUP_MAX.html" title="constant zstd_sys::RE_DUP_MAX">RE_DUP_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.RTSIG_MAX.html" title="constant zstd_sys::RTSIG_MAX">RTSIG_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.SEM_VALUE_MAX.html" title="constant zstd_sys::SEM_VALUE_MAX">SEM_VALUE_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.TTY_NAME_MAX.html" title="constant zstd_sys::TTY_NAME_MAX">TTY_NAME_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.XATTR_LIST_MAX.html" title="constant zstd_sys::XATTR_LIST_MAX">XATTR_LIST_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.XATTR_NAME_MAX.html" title="constant zstd_sys::XATTR_NAME_MAX">XATTR_NAME_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.XATTR_SIZE_MAX.html" title="constant zstd_sys::XATTR_SIZE_MAX">XATTR_SIZE_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZDICT_CONTENTSIZE_MIN.html" title="constant zstd_sys::ZDICT_CONTENTSIZE_MIN">ZDICT_CONTENTSIZE_MIN</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZDICT_DICTSIZE_MIN.html" title="constant zstd_sys::ZDICT_DICTSIZE_MIN">ZDICT_DICTSIZE_MIN</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTDMT_NBWORKERS_MAX.html" title="constant zstd_sys::ZSTDMT_NBWORKERS_MAX">ZSTDMT_NBWORKERS_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_BLOCKSIZELOG_MAX.html" title="constant zstd_sys::ZSTD_BLOCKSIZELOG_MAX">ZSTD_BLOCKSIZELOG_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_BLOCKSIZE_MAX.html" title="constant zstd_sys::ZSTD_BLOCKSIZE_MAX">ZSTD_BLOCKSIZE_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_CHAINLOG_MAX_32.html" title="constant zstd_sys::ZSTD_CHAINLOG_MAX_32">ZSTD_CHAINLOG_MAX_32</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_CHAINLOG_MAX_64.html" title="constant zstd_sys::ZSTD_CHAINLOG_MAX_64">ZSTD_CHAINLOG_MAX_64</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_CHAINLOG_MIN.html" title="constant zstd_sys::ZSTD_CHAINLOG_MIN">ZSTD_CHAINLOG_MIN</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_CLEVEL_DEFAULT.html" title="constant zstd_sys::ZSTD_CLEVEL_DEFAULT">ZSTD_CLEVEL_DEFAULT</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_CONTENTSIZE_ERROR.html" title="constant zstd_sys::ZSTD_CONTENTSIZE_ERROR">ZSTD_CONTENTSIZE_ERROR</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_CONTENTSIZE_UNKNOWN.html" title="constant zstd_sys::ZSTD_CONTENTSIZE_UNKNOWN">ZSTD_CONTENTSIZE_UNKNOWN</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_FRAMEHEADERSIZE_MAX.html" title="constant zstd_sys::ZSTD_FRAMEHEADERSIZE_MAX">ZSTD_FRAMEHEADERSIZE_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_HASHLOG3_MAX.html" title="constant zstd_sys::ZSTD_HASHLOG3_MAX">ZSTD_HASHLOG3_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_HASHLOG_MIN.html" title="constant zstd_sys::ZSTD_HASHLOG_MIN">ZSTD_HASHLOG_MIN</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_LDM_BUCKETSIZELOG_MAX.html" title="constant zstd_sys::ZSTD_LDM_BUCKETSIZELOG_MAX">ZSTD_LDM_BUCKETSIZELOG_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_LDM_BUCKETSIZELOG_MIN.html" title="constant zstd_sys::ZSTD_LDM_BUCKETSIZELOG_MIN">ZSTD_LDM_BUCKETSIZELOG_MIN</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_LDM_HASHLOG_MIN.html" title="constant zstd_sys::ZSTD_LDM_HASHLOG_MIN">ZSTD_LDM_HASHLOG_MIN</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_LDM_HASHRATELOG_MIN.html" title="constant zstd_sys::ZSTD_LDM_HASHRATELOG_MIN">ZSTD_LDM_HASHRATELOG_MIN</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_LDM_MINMATCH_MAX.html" title="constant zstd_sys::ZSTD_LDM_MINMATCH_MAX">ZSTD_LDM_MINMATCH_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_LDM_MINMATCH_MIN.html" title="constant zstd_sys::ZSTD_LDM_MINMATCH_MIN">ZSTD_LDM_MINMATCH_MIN</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_MAGICNUMBER.html" title="constant zstd_sys::ZSTD_MAGICNUMBER">ZSTD_MAGICNUMBER</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_MAGIC_DICTIONARY.html" title="constant zstd_sys::ZSTD_MAGIC_DICTIONARY">ZSTD_MAGIC_DICTIONARY</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_MAGIC_SKIPPABLE_MASK.html" title="constant zstd_sys::ZSTD_MAGIC_SKIPPABLE_MASK">ZSTD_MAGIC_SKIPPABLE_MASK</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_MAGIC_SKIPPABLE_START.html" title="constant zstd_sys::ZSTD_MAGIC_SKIPPABLE_START">ZSTD_MAGIC_SKIPPABLE_START</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_MINMATCH_MAX.html" title="constant zstd_sys::ZSTD_MINMATCH_MAX">ZSTD_MINMATCH_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_MINMATCH_MIN.html" title="constant zstd_sys::ZSTD_MINMATCH_MIN">ZSTD_MINMATCH_MIN</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_OVERLAPLOG_MAX.html" title="constant zstd_sys::ZSTD_OVERLAPLOG_MAX">ZSTD_OVERLAPLOG_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_OVERLAPLOG_MIN.html" title="constant zstd_sys::ZSTD_OVERLAPLOG_MIN">ZSTD_OVERLAPLOG_MIN</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_SEARCHLOG_MIN.html" title="constant zstd_sys::ZSTD_SEARCHLOG_MIN">ZSTD_SEARCHLOG_MIN</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_SKIPPABLEHEADERSIZE.html" title="constant zstd_sys::ZSTD_SKIPPABLEHEADERSIZE">ZSTD_SKIPPABLEHEADERSIZE</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_SRCSIZEHINT_MIN.html" title="constant zstd_sys::ZSTD_SRCSIZEHINT_MIN">ZSTD_SRCSIZEHINT_MIN</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_TARGETCBLOCKSIZE_MAX.html" title="constant zstd_sys::ZSTD_TARGETCBLOCKSIZE_MAX">ZSTD_TARGETCBLOCKSIZE_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_TARGETCBLOCKSIZE_MIN.html" title="constant zstd_sys::ZSTD_TARGETCBLOCKSIZE_MIN">ZSTD_TARGETCBLOCKSIZE_MIN</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_TARGETLENGTH_MAX.html" title="constant zstd_sys::ZSTD_TARGETLENGTH_MAX">ZSTD_TARGETLENGTH_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_TARGETLENGTH_MIN.html" title="constant zstd_sys::ZSTD_TARGETLENGTH_MIN">ZSTD_TARGETLENGTH_MIN</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_VERSION_MAJOR.html" title="constant zstd_sys::ZSTD_VERSION_MAJOR">ZSTD_VERSION_MAJOR</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_VERSION_MINOR.html" title="constant zstd_sys::ZSTD_VERSION_MINOR">ZSTD_VERSION_MINOR</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_VERSION_NUMBER.html" title="constant zstd_sys::ZSTD_VERSION_NUMBER">ZSTD_VERSION_NUMBER</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_VERSION_RELEASE.html" title="constant zstd_sys::ZSTD_VERSION_RELEASE">ZSTD_VERSION_RELEASE</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_WINDOWLOG_LIMIT_DEFAULT.html" title="constant zstd_sys::ZSTD_WINDOWLOG_LIMIT_DEFAULT">ZSTD_WINDOWLOG_LIMIT_DEFAULT</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_WINDOWLOG_MAX_32.html" title="constant zstd_sys::ZSTD_WINDOWLOG_MAX_32">ZSTD_WINDOWLOG_MAX_32</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_WINDOWLOG_MAX_64.html" title="constant zstd_sys::ZSTD_WINDOWLOG_MAX_64">ZSTD_WINDOWLOG_MAX_64</a></div></li><li><div class="item-name"><a class="constant" href="constant.ZSTD_WINDOWLOG_MIN.html" title="constant zstd_sys::ZSTD_WINDOWLOG_MIN">ZSTD_WINDOWLOG_MIN</a></div></li><li><div class="item-name"><a class="constant" href="constant._ATFILE_SOURCE.html" title="constant zstd_sys::_ATFILE_SOURCE">_ATFILE_SOURCE</a></div></li><li><div class="item-name"><a class="constant" href="constant._BITS_POSIX1_LIM_H.html" title="constant zstd_sys::_BITS_POSIX1_LIM_H">_BITS_POSIX1_LIM_H</a></div></li><li><div class="item-name"><a class="constant" href="constant._BITS_POSIX2_LIM_H.html" title="constant zstd_sys::_BITS_POSIX2_LIM_H">_BITS_POSIX2_LIM_H</a></div></li><li><div class="item-name"><a class="constant" href="constant._BITS_TYPES_LOCALE_T_H.html" title="constant zstd_sys::_BITS_TYPES_LOCALE_T_H">_BITS_TYPES_LOCALE_T_H</a></div></li><li><div class="item-name"><a class="constant" href="constant._BITS_TYPES___LOCALE_T_H.html" title="constant zstd_sys::_BITS_TYPES___LOCALE_T_H">_BITS_TYPES___LOCALE_T_H</a></div></li><li><div class="item-name"><a class="constant" href="constant._DEFAULT_SOURCE.html" title="constant zstd_sys::_DEFAULT_SOURCE">_DEFAULT_SOURCE</a></div></li><li><div class="item-name"><a class="constant" href="constant._FEATURES_H.html" title="constant zstd_sys::_FEATURES_H">_FEATURES_H</a></div></li><li><div class="item-name"><a class="constant" href="constant._LIBC_LIMITS_H_.html" title="constant zstd_sys::_LIBC_LIMITS_H_">_LIBC_LIMITS_H_</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX2_BC_BASE_MAX.html" title="constant zstd_sys::_POSIX2_BC_BASE_MAX">_POSIX2_BC_BASE_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX2_BC_DIM_MAX.html" title="constant zstd_sys::_POSIX2_BC_DIM_MAX">_POSIX2_BC_DIM_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX2_BC_SCALE_MAX.html" title="constant zstd_sys::_POSIX2_BC_SCALE_MAX">_POSIX2_BC_SCALE_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX2_BC_STRING_MAX.html" title="constant zstd_sys::_POSIX2_BC_STRING_MAX">_POSIX2_BC_STRING_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX2_CHARCLASS_NAME_MAX.html" title="constant zstd_sys::_POSIX2_CHARCLASS_NAME_MAX">_POSIX2_CHARCLASS_NAME_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX2_COLL_WEIGHTS_MAX.html" title="constant zstd_sys::_POSIX2_COLL_WEIGHTS_MAX">_POSIX2_COLL_WEIGHTS_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX2_EXPR_NEST_MAX.html" title="constant zstd_sys::_POSIX2_EXPR_NEST_MAX">_POSIX2_EXPR_NEST_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX2_LINE_MAX.html" title="constant zstd_sys::_POSIX2_LINE_MAX">_POSIX2_LINE_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX2_RE_DUP_MAX.html" title="constant zstd_sys::_POSIX2_RE_DUP_MAX">_POSIX2_RE_DUP_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_AIO_LISTIO_MAX.html" title="constant zstd_sys::_POSIX_AIO_LISTIO_MAX">_POSIX_AIO_LISTIO_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_AIO_MAX.html" title="constant zstd_sys::_POSIX_AIO_MAX">_POSIX_AIO_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_ARG_MAX.html" title="constant zstd_sys::_POSIX_ARG_MAX">_POSIX_ARG_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_CHILD_MAX.html" title="constant zstd_sys::_POSIX_CHILD_MAX">_POSIX_CHILD_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_CLOCKRES_MIN.html" title="constant zstd_sys::_POSIX_CLOCKRES_MIN">_POSIX_CLOCKRES_MIN</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_C_SOURCE.html" title="constant zstd_sys::_POSIX_C_SOURCE">_POSIX_C_SOURCE</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_DELAYTIMER_MAX.html" title="constant zstd_sys::_POSIX_DELAYTIMER_MAX">_POSIX_DELAYTIMER_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_HOST_NAME_MAX.html" title="constant zstd_sys::_POSIX_HOST_NAME_MAX">_POSIX_HOST_NAME_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_LINK_MAX.html" title="constant zstd_sys::_POSIX_LINK_MAX">_POSIX_LINK_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_LOGIN_NAME_MAX.html" title="constant zstd_sys::_POSIX_LOGIN_NAME_MAX">_POSIX_LOGIN_NAME_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_MAX_CANON.html" title="constant zstd_sys::_POSIX_MAX_CANON">_POSIX_MAX_CANON</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_MAX_INPUT.html" title="constant zstd_sys::_POSIX_MAX_INPUT">_POSIX_MAX_INPUT</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_MQ_OPEN_MAX.html" title="constant zstd_sys::_POSIX_MQ_OPEN_MAX">_POSIX_MQ_OPEN_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_MQ_PRIO_MAX.html" title="constant zstd_sys::_POSIX_MQ_PRIO_MAX">_POSIX_MQ_PRIO_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_NAME_MAX.html" title="constant zstd_sys::_POSIX_NAME_MAX">_POSIX_NAME_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_NGROUPS_MAX.html" title="constant zstd_sys::_POSIX_NGROUPS_MAX">_POSIX_NGROUPS_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_OPEN_MAX.html" title="constant zstd_sys::_POSIX_OPEN_MAX">_POSIX_OPEN_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_PATH_MAX.html" title="constant zstd_sys::_POSIX_PATH_MAX">_POSIX_PATH_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_PIPE_BUF.html" title="constant zstd_sys::_POSIX_PIPE_BUF">_POSIX_PIPE_BUF</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_RE_DUP_MAX.html" title="constant zstd_sys::_POSIX_RE_DUP_MAX">_POSIX_RE_DUP_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_RTSIG_MAX.html" title="constant zstd_sys::_POSIX_RTSIG_MAX">_POSIX_RTSIG_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_SEM_NSEMS_MAX.html" title="constant zstd_sys::_POSIX_SEM_NSEMS_MAX">_POSIX_SEM_NSEMS_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_SEM_VALUE_MAX.html" title="constant zstd_sys::_POSIX_SEM_VALUE_MAX">_POSIX_SEM_VALUE_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_SIGQUEUE_MAX.html" title="constant zstd_sys::_POSIX_SIGQUEUE_MAX">_POSIX_SIGQUEUE_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_SOURCE.html" title="constant zstd_sys::_POSIX_SOURCE">_POSIX_SOURCE</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_SSIZE_MAX.html" title="constant zstd_sys::_POSIX_SSIZE_MAX">_POSIX_SSIZE_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_STREAM_MAX.html" title="constant zstd_sys::_POSIX_STREAM_MAX">_POSIX_STREAM_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_SYMLINK_MAX.html" title="constant zstd_sys::_POSIX_SYMLINK_MAX">_POSIX_SYMLINK_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_SYMLOOP_MAX.html" title="constant zstd_sys::_POSIX_SYMLOOP_MAX">_POSIX_SYMLOOP_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_THREAD_DESTRUCTOR_ITERATIONS.html" title="constant zstd_sys::_POSIX_THREAD_DESTRUCTOR_ITERATIONS">_POSIX_THREAD_DESTRUCTOR_ITERATIONS</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_THREAD_KEYS_MAX.html" title="constant zstd_sys::_POSIX_THREAD_KEYS_MAX">_POSIX_THREAD_KEYS_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_THREAD_THREADS_MAX.html" title="constant zstd_sys::_POSIX_THREAD_THREADS_MAX">_POSIX_THREAD_THREADS_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_TIMER_MAX.html" title="constant zstd_sys::_POSIX_TIMER_MAX">_POSIX_TIMER_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_TTY_NAME_MAX.html" title="constant zstd_sys::_POSIX_TTY_NAME_MAX">_POSIX_TTY_NAME_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._POSIX_TZNAME_MAX.html" title="constant zstd_sys::_POSIX_TZNAME_MAX">_POSIX_TZNAME_MAX</a></div></li><li><div class="item-name"><a class="constant" href="constant._STDC_PREDEF_H.html" title="constant zstd_sys::_STDC_PREDEF_H">_STDC_PREDEF_H</a></div></li><li><div class="item-name"><a class="constant" href="constant._STRINGS_H.html" title="constant zstd_sys::_STRINGS_H">_STRINGS_H</a></div></li><li><div class="item-name"><a class="constant" href="constant._STRING_H.html" title="constant zstd_sys::_STRING_H">_STRING_H</a></div></li><li><div class="item-name"><a class="constant" href="constant._SYS_CDEFS_H.html" title="constant zstd_sys::_SYS_CDEFS_H">_SYS_CDEFS_H</a></div></li><li><div class="item-name"><a class="constant" href="constant.__GLIBC_MINOR__.html" title="constant zstd_sys::__GLIBC_MINOR__">__GLIBC_MINOR__</a></div></li><li><div class="item-name"><a class="constant" href="constant.__GLIBC_USE_DEPRECATED_GETS.html" title="constant zstd_sys::__GLIBC_USE_DEPRECATED_GETS">__GLIBC_USE_DEPRECATED_GETS</a></div></li><li><div class="item-name"><a class="constant" href="constant.__GLIBC_USE_DEPRECATED_SCANF.html" title="constant zstd_sys::__GLIBC_USE_DEPRECATED_SCANF">__GLIBC_USE_DEPRECATED_SCANF</a></div></li><li><div class="item-name"><a class="constant" href="constant.__GLIBC_USE_IEC_60559_BFP_EXT.html" title="constant zstd_sys::__GLIBC_USE_IEC_60559_BFP_EXT">__GLIBC_USE_IEC_60559_BFP_EXT</a></div></li><li><div class="item-name"><a class="constant" href="constant.__GLIBC_USE_IEC_60559_BFP_EXT_C2X.html" title="constant zstd_sys::__GLIBC_USE_IEC_60559_BFP_EXT_C2X">__GLIBC_USE_IEC_60559_BFP_EXT_C2X</a></div></li><li><div class="item-name"><a class="constant" href="constant.__GLIBC_USE_IEC_60559_FUNCS_EXT.html" title="constant zstd_sys::__GLIBC_USE_IEC_60559_FUNCS_EXT">__GLIBC_USE_IEC_60559_FUNCS_EXT</a></div></li><li><div class="item-name"><a class="constant" href="constant.__GLIBC_USE_IEC_60559_FUNCS_EXT_C2X.html" title="constant zstd_sys::__GLIBC_USE_IEC_60559_FUNCS_EXT_C2X">__GLIBC_USE_IEC_60559_FUNCS_EXT_C2X</a></div></li><li><div class="item-name"><a class="constant" href="constant.__GLIBC_USE_IEC_60559_TYPES_EXT.html" title="constant zstd_sys::__GLIBC_USE_IEC_60559_TYPES_EXT">__GLIBC_USE_IEC_60559_TYPES_EXT</a></div></li><li><div class="item-name"><a class="constant" href="constant.__GLIBC_USE_ISOC2X.html" title="constant zstd_sys::__GLIBC_USE_ISOC2X">__GLIBC_USE_ISOC2X</a></div></li><li><div class="item-name"><a class="constant" href="constant.__GLIBC_USE_LIB_EXT2.html" title="constant zstd_sys::__GLIBC_USE_LIB_EXT2">__GLIBC_USE_LIB_EXT2</a></div></li><li><div class="item-name"><a class="constant" href="constant.__GLIBC__.html" title="constant zstd_sys::__GLIBC__">__GLIBC__</a></div></li><li><div class="item-name"><a class="constant" href="constant.__GNU_LIBRARY__.html" title="constant zstd_sys::__GNU_LIBRARY__">__GNU_LIBRARY__</a></div></li><li><div class="item-name"><a class="constant" href="constant.__HAVE_GENERIC_SELECTION.html" title="constant zstd_sys::__HAVE_GENERIC_SELECTION">__HAVE_GENERIC_SELECTION</a></div></li><li><div class="item-name"><a class="constant" href="constant.__LDOUBLE_REDIRECTS_TO_FLOAT128_ABI.html" title="constant zstd_sys::__LDOUBLE_REDIRECTS_TO_FLOAT128_ABI">__LDOUBLE_REDIRECTS_TO_FLOAT128_ABI</a></div></li><li><div class="item-name"><a class="constant" href="constant.__STDC_IEC_559_COMPLEX__.html" title="constant zstd_sys::__STDC_IEC_559_COMPLEX__">__STDC_IEC_559_COMPLEX__</a></div></li><li><div class="item-name"><a class="constant" href="constant.__STDC_IEC_559__.html" title="constant zstd_sys::__STDC_IEC_559__">__STDC_IEC_559__</a></div></li><li><div class="item-name"><a class="constant" href="constant.__STDC_ISO_10646__.html" title="constant zstd_sys::__STDC_ISO_10646__">__STDC_ISO_10646__</a></div></li><li><div class="item-name"><a class="constant" href="constant.__SYSCALL_WORDSIZE.html" title="constant zstd_sys::__SYSCALL_WORDSIZE">__SYSCALL_WORDSIZE</a></div></li><li><div class="item-name"><a class="constant" href="constant.__USE_ATFILE.html" title="constant zstd_sys::__USE_ATFILE">__USE_ATFILE</a></div></li><li><div class="item-name"><a class="constant" href="constant.__USE_FORTIFY_LEVEL.html" title="constant zstd_sys::__USE_FORTIFY_LEVEL">__USE_FORTIFY_LEVEL</a></div></li><li><div class="item-name"><a class="constant" href="constant.__USE_ISOC11.html" title="constant zstd_sys::__USE_ISOC11">__USE_ISOC11</a></div></li><li><div class="item-name"><a class="constant" href="constant.__USE_ISOC95.html" title="constant zstd_sys::__USE_ISOC95">__USE_ISOC95</a></div></li><li><div class="item-name"><a class="constant" href="constant.__USE_ISOC99.html" title="constant zstd_sys::__USE_ISOC99">__USE_ISOC99</a></div></li><li><div class="item-name"><a class="constant" href="constant.__USE_MISC.html" title="constant zstd_sys::__USE_MISC">__USE_MISC</a></div></li><li><div class="item-name"><a class="constant" href="constant.__USE_POSIX.html" title="constant zstd_sys::__USE_POSIX">__USE_POSIX</a></div></li><li><div class="item-name"><a class="constant" href="constant.__USE_POSIX2.html" title="constant zstd_sys::__USE_POSIX2">__USE_POSIX2</a></div></li><li><div class="item-name"><a class="constant" href="constant.__USE_POSIX199309.html" title="constant zstd_sys::__USE_POSIX199309">__USE_POSIX199309</a></div></li><li><div class="item-name"><a class="constant" href="constant.__USE_POSIX199506.html" title="constant zstd_sys::__USE_POSIX199506">__USE_POSIX199506</a></div></li><li><div class="item-name"><a class="constant" href="constant.__USE_POSIX_IMPLICITLY.html" title="constant zstd_sys::__USE_POSIX_IMPLICITLY">__USE_POSIX_IMPLICITLY</a></div></li><li><div class="item-name"><a class="constant" href="constant.__USE_XOPEN2K.html" title="constant zstd_sys::__USE_XOPEN2K">__USE_XOPEN2K</a></div></li><li><div class="item-name"><a class="constant" href="constant.__USE_XOPEN2K8.html" title="constant zstd_sys::__USE_XOPEN2K8">__USE_XOPEN2K8</a></div></li><li><div class="item-name"><a class="constant" href="constant.__WORDSIZE.html" title="constant zstd_sys::__WORDSIZE">__WORDSIZE</a></div></li><li><div class="item-name"><a class="constant" href="constant.__WORDSIZE_TIME64_COMPAT32.html" title="constant zstd_sys::__WORDSIZE_TIME64_COMPAT32">__WORDSIZE_TIME64_COMPAT32</a></div></li><li><div class="item-name"><a class="constant" href="constant.__glibc_c99_flexarr_available.html" title="constant zstd_sys::__glibc_c99_flexarr_available">__glibc_c99_flexarr_available</a></div></li></ul><h2 id="statics" class="section-header">Statics<a href="#statics" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="static" href="static.ZSTD_defaultCMem.html" title="static zstd_sys::ZSTD_defaultCMem">ZSTD_defaultCMem</a><sup title="unsafe static">⚠</sup></div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.ZDICT_addEntropyTablesFromBuffer.html" title="fn zstd_sys::ZDICT_addEntropyTablesFromBuffer">ZDICT_addEntropyTablesFromBuffer</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZDICT_finalizeDictionary.html" title="fn zstd_sys::ZDICT_finalizeDictionary">ZDICT_finalizeDictionary</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZDICT_finalizeDictionary():
Given a custom content as a basis for dictionary, and a set of samples,
finalize dictionary by adding headers and statistics according to the zstd
dictionary format.</div></li><li><div class="item-name"><a class="fn" href="fn.ZDICT_getDictHeaderSize.html" title="fn zstd_sys::ZDICT_getDictHeaderSize">ZDICT_getDictHeaderSize</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZDICT_getDictID.html" title="fn zstd_sys::ZDICT_getDictID">ZDICT_getDictID</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZDICT_getErrorName.html" title="fn zstd_sys::ZDICT_getErrorName">ZDICT_getErrorName</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZDICT_isError.html" title="fn zstd_sys::ZDICT_isError">ZDICT_isError</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZDICT_optimizeTrainFromBuffer_cover.html" title="fn zstd_sys::ZDICT_optimizeTrainFromBuffer_cover">ZDICT_optimizeTrainFromBuffer_cover</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZDICT_optimizeTrainFromBuffer_cover():
The same requirements as above hold for all the parameters except <code>parameters</code>.
This function tries many parameter combinations and picks the best parameters.
<code>*parameters</code> is filled with the best parameters found,
dictionary constructed with those parameters is stored in <code>dictBuffer</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.ZDICT_optimizeTrainFromBuffer_fastCover.html" title="fn zstd_sys::ZDICT_optimizeTrainFromBuffer_fastCover">ZDICT_optimizeTrainFromBuffer_fastCover</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZDICT_optimizeTrainFromBuffer_fastCover():
The same requirements as above hold for all the parameters except <code>parameters</code>.
This function tries many parameter combinations (specifically, k and d combinations)
and picks the best parameters. <code>*parameters</code> is filled with the best parameters found,
dictionary constructed with those parameters is stored in <code>dictBuffer</code>.
All of the parameters d, k, steps, f, and accel are optional.
If d is non-zero then we don’t check multiple values of d, otherwise we check d = {6, 8}.
if steps is zero it defaults to its default value.
If k is non-zero then we don’t check multiple values of k, otherwise we check steps values in [50, 2000].
If f is zero, default value of 20 is used.
If accel is zero, default value of 1 is used.</div></li><li><div class="item-name"><a class="fn" href="fn.ZDICT_trainFromBuffer.html" title="fn zstd_sys::ZDICT_trainFromBuffer">ZDICT_trainFromBuffer</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZDICT_trainFromBuffer():
Train a dictionary from an array of samples.
Redirect towards ZDICT_optimizeTrainFromBuffer_fastCover() single-threaded, with d=8, steps=4,
f=20, and accel=1.
Samples must be stored concatenated in a single flat buffer <code>samplesBuffer</code>,
supplied with an array of sizes <code>samplesSizes</code>, providing the size of each sample, in order.
The resulting dictionary will be saved into <code>dictBuffer</code>.
@return: size of dictionary stored into <code>dictBuffer</code> (&lt;= <code>dictBufferCapacity</code>)
or an error code, which can be tested with ZDICT_isError().
Note:  Dictionary training will fail if there are not enough samples to construct a
dictionary, or if most of the samples are too small (&lt; 8 bytes being the lower limit).
If dictionary training fails, you should use zstd without a dictionary, as the dictionary
would’ve been ineffective anyways. If you believe your samples would benefit from a dictionary
please open an issue with details, and we can look into it.
Note: ZDICT_trainFromBuffer()’s memory usage is about 6 MB.
Tips: In general, a reasonable dictionary has a size of ~ 100 KB.
It’s possible to select smaller or larger size, just by specifying <code>dictBufferCapacity</code>.
In general, it’s recommended to provide a few thousands samples, though this can vary a lot.
It’s recommended that total size of all samples be about ~x100 times the target size of dictionary.</div></li><li><div class="item-name"><a class="fn" href="fn.ZDICT_trainFromBuffer_cover.html" title="fn zstd_sys::ZDICT_trainFromBuffer_cover">ZDICT_trainFromBuffer_cover</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZDICT_trainFromBuffer_cover():
Train a dictionary from an array of samples using the COVER algorithm.
Samples must be stored concatenated in a single flat buffer <code>samplesBuffer</code>,
supplied with an array of sizes <code>samplesSizes</code>, providing the size of each sample, in order.
The resulting dictionary will be saved into <code>dictBuffer</code>.
@return: size of dictionary stored into <code>dictBuffer</code> (&lt;= <code>dictBufferCapacity</code>)
or an error code, which can be tested with ZDICT_isError().
See ZDICT_trainFromBuffer() for details on failure modes.
Note: ZDICT_trainFromBuffer_cover() requires about 9 bytes of memory for each input byte.
Tips: In general, a reasonable dictionary has a size of ~ 100 KB.
It’s possible to select smaller or larger size, just by specifying <code>dictBufferCapacity</code>.
In general, it’s recommended to provide a few thousands samples, though this can vary a lot.
It’s recommended that total size of all samples be about ~x100 times the target size of dictionary.</div></li><li><div class="item-name"><a class="fn" href="fn.ZDICT_trainFromBuffer_fastCover.html" title="fn zstd_sys::ZDICT_trainFromBuffer_fastCover">ZDICT_trainFromBuffer_fastCover</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZDICT_trainFromBuffer_fastCover():
Train a dictionary from an array of samples using a modified version of COVER algorithm.
Samples must be stored concatenated in a single flat buffer <code>samplesBuffer</code>,
supplied with an array of sizes <code>samplesSizes</code>, providing the size of each sample, in order.
d and k are required.
All other parameters are optional, will use default values if not provided
The resulting dictionary will be saved into <code>dictBuffer</code>.
@return: size of dictionary stored into <code>dictBuffer</code> (&lt;= <code>dictBufferCapacity</code>)
or an error code, which can be tested with ZDICT_isError().
See ZDICT_trainFromBuffer() for details on failure modes.
Note: ZDICT_trainFromBuffer_fastCover() requires 6 * 2^f bytes of memory.
Tips: In general, a reasonable dictionary has a size of ~ 100 KB.
It’s possible to select smaller or larger size, just by specifying <code>dictBufferCapacity</code>.
In general, it’s recommended to provide a few thousands samples, though this can vary a lot.
It’s recommended that total size of all samples be about ~x100 times the target size of dictionary.</div></li><li><div class="item-name"><a class="fn" href="fn.ZDICT_trainFromBuffer_legacy.html" title="fn zstd_sys::ZDICT_trainFromBuffer_legacy">ZDICT_trainFromBuffer_legacy</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZDICT_trainFromBuffer_legacy():
Train a dictionary from an array of samples.
Samples must be stored concatenated in a single flat buffer <code>samplesBuffer</code>,
supplied with an array of sizes <code>samplesSizes</code>, providing the size of each sample, in order.
The resulting dictionary will be saved into <code>dictBuffer</code>.
<code>parameters</code> is optional and can be provided with values set to 0 to mean “default”.
@return: size of dictionary stored into <code>dictBuffer</code> (&lt;= <code>dictBufferCapacity</code>)
or an error code, which can be tested with ZDICT_isError().
See ZDICT_trainFromBuffer() for details on failure modes.
Tips: In general, a reasonable dictionary has a size of ~ 100 KB.
It’s possible to select smaller or larger size, just by specifying <code>dictBufferCapacity</code>.
In general, it’s recommended to provide a few thousands samples, though this can vary a lot.
It’s recommended that total size of all samples be about ~x100 times the target size of dictionary.
Note: ZDICT_trainFromBuffer_legacy() will send notifications into stderr if instructed to, using notificationLevel&gt;0.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTDMT_compressStream_generic.html" title="fn zstd_sys::ZSTDMT_compressStream_generic">ZSTDMT_compressStream_generic</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTDMT_compressStream_generic() :
Combines ZSTDMT_compressStream() with optional ZSTDMT_flushStream() or ZSTDMT_endStream()
depending on flush directive.
@return : minimum amount of data still to be flushed
0 if fully flushed
or an error code
note : needs to be init using any ZSTD_initCStream*() variant</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTDMT_createCCtx_advanced.html" title="fn zstd_sys::ZSTDMT_createCCtx_advanced">ZSTDMT_createCCtx_advanced</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTDMT_freeCCtx.html" title="fn zstd_sys::ZSTDMT_freeCCtx">ZSTDMT_freeCCtx</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTDMT_getFrameProgression.html" title="fn zstd_sys::ZSTDMT_getFrameProgression">ZSTDMT_getFrameProgression</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTDMT_getFrameProgression():
tells how much data has been consumed (input) and produced (output) for current frame.
able to count progression inside worker threads.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTDMT_initCStream_internal.html" title="fn zstd_sys::ZSTDMT_initCStream_internal">ZSTDMT_initCStream_internal</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTDMT_initCStream_internal() :
Private use only. Init streaming operation.
expects params to be valid.
must receive dict, or cdict, or none, but not both.
@return : 0, or an error code</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTDMT_nextInputSizeHint.html" title="fn zstd_sys::ZSTDMT_nextInputSizeHint">ZSTDMT_nextInputSizeHint</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTDMT_sizeof_CCtx.html" title="fn zstd_sys::ZSTDMT_sizeof_CCtx">ZSTDMT_sizeof_CCtx</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTDMT_toFlushNow.html" title="fn zstd_sys::ZSTDMT_toFlushNow">ZSTDMT_toFlushNow</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTDMT_toFlushNow()
Tell how many bytes are ready to be flushed immediately.
Probe the oldest active job (not yet entirely flushed) and check its output buffer.
If return 0, it means there is no active job,
or, it means oldest job is still active, but everything produced has been flushed so far,
therefore flushing is limited by speed of oldest job.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTDMT_updateCParams_whileCompressing.html" title="fn zstd_sys::ZSTDMT_updateCParams_whileCompressing">ZSTDMT_updateCParams_whileCompressing</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTDMT_updateCParams_whileCompressing() :
Updates only a selected set of compression parameters, to remain compatible with current frame.
New parameters will be applied to next compression job.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_CCtxParams_getParameter.html" title="fn zstd_sys::ZSTD_CCtxParams_getParameter">ZSTD_CCtxParams_getParameter</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_CCtxParams_getParameter() :
Similar to ZSTD_CCtx_getParameter.
Get the requested value of one compression parameter, selected by enum ZSTD_cParameter.
@result : 0, or an error code (which can be tested with ZSTD_isError()).</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_CCtxParams_init.html" title="fn zstd_sys::ZSTD_CCtxParams_init">ZSTD_CCtxParams_init</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_CCtxParams_init() :
Initializes the compression parameters of cctxParams according to
compression level. All other parameters are reset to their default values.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_CCtxParams_init_advanced.html" title="fn zstd_sys::ZSTD_CCtxParams_init_advanced">ZSTD_CCtxParams_init_advanced</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_CCtxParams_init_advanced() :
Initializes the compression and frame parameters of cctxParams according to
params. All other parameters are reset to their default values.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_CCtxParams_reset.html" title="fn zstd_sys::ZSTD_CCtxParams_reset">ZSTD_CCtxParams_reset</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_CCtxParams_reset() :
Reset params to default values.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_CCtxParams_setParameter.html" title="fn zstd_sys::ZSTD_CCtxParams_setParameter">ZSTD_CCtxParams_setParameter</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_CCtxParams_setParameter() :
Similar to ZSTD_CCtx_setParameter.
Set one compression parameter, selected by enum ZSTD_cParameter.
Parameters must be applied to a ZSTD_CCtx using
ZSTD_CCtx_setParametersUsingCCtxParams().
@result : a code representing success or failure (which can be tested with
ZSTD_isError()).</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_CCtx_getParameter.html" title="fn zstd_sys::ZSTD_CCtx_getParameter">ZSTD_CCtx_getParameter</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_CCtx_getParameter() :
Get the requested compression parameter value, selected by enum ZSTD_cParameter,
and store it into int* value.
@return : 0, or an error code (which can be tested with ZSTD_isError()).</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_CCtx_loadDictionary.html" title="fn zstd_sys::ZSTD_CCtx_loadDictionary">ZSTD_CCtx_loadDictionary</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_CCtx_loadDictionary() :
Create an internal CDict from <code>dict</code> buffer.
Decompression will have to use same dictionary.
@result : 0, or an error code (which can be tested with ZSTD_isError()).
Special: Loading a NULL (or 0-size) dictionary invalidates previous dictionary,
meaning “return to no-dictionary mode”.
Note 1 : Dictionary is sticky, it will be used for all future compressed frames.
To return to “no-dictionary” situation, load a NULL dictionary (or reset parameters).
Note 2 : Loading a dictionary involves building tables.
It’s also a CPU consuming operation, with non-negligible impact on latency.
Tables are dependent on compression parameters, and for this reason,
compression parameters can no longer be changed after loading a dictionary.
Note 3 :<code>dict</code> content will be copied internally.
Use experimental ZSTD_CCtx_loadDictionary_byReference() to reference content instead.
In such a case, dictionary buffer must outlive its users.
Note 4 : Use ZSTD_CCtx_loadDictionary_advanced()
to precisely select how dictionary content must be interpreted.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_CCtx_loadDictionary_advanced.html" title="fn zstd_sys::ZSTD_CCtx_loadDictionary_advanced">ZSTD_CCtx_loadDictionary_advanced</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_CCtx_loadDictionary_advanced() :
Same as ZSTD_CCtx_loadDictionary(), but gives finer control over
how to load the dictionary (by copy ? by reference ?)
and how to interpret it (automatic ? force raw mode ? full mode only ?)</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_CCtx_loadDictionary_byReference.html" title="fn zstd_sys::ZSTD_CCtx_loadDictionary_byReference">ZSTD_CCtx_loadDictionary_byReference</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_CCtx_loadDictionary_byReference() :
Same as ZSTD_CCtx_loadDictionary(), but dictionary content is referenced, instead of being copied into CCtx.
It saves some memory, but also requires that <code>dict</code> outlives its usage within <code>cctx</code></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_CCtx_refCDict.html" title="fn zstd_sys::ZSTD_CCtx_refCDict">ZSTD_CCtx_refCDict</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_CCtx_refCDict() :
Reference a prepared dictionary, to be used for all next compressed frames.
Note that compression parameters are enforced from within CDict,
and supersede any compression parameter previously set within CCtx.
The parameters ignored are labelled as “superseded-by-cdict” in the ZSTD_cParameter enum docs.
The ignored parameters will be used again if the CCtx is returned to no-dictionary mode.
The dictionary will remain valid for future compressed frames using same CCtx.
@result : 0, or an error code (which can be tested with ZSTD_isError()).
Special : Referencing a NULL CDict means “return to no-dictionary mode”.
Note 1 : Currently, only one dictionary can be managed.
Referencing a new dictionary effectively “discards” any previous one.
Note 2 : CDict is just referenced, its lifetime must outlive its usage within CCtx.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_CCtx_refPrefix.html" title="fn zstd_sys::ZSTD_CCtx_refPrefix">ZSTD_CCtx_refPrefix</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_CCtx_refPrefix() :
Reference a prefix (single-usage dictionary) for next compressed frame.
A prefix is <strong>only used once</strong>. Tables are discarded at end of frame (ZSTD_e_end).
Decompression will need same prefix to properly regenerate data.
Compressing with a prefix is similar in outcome as performing a diff and compressing it,
but performs much faster, especially during decompression (compression speed is tunable with compression level).
@result : 0, or an error code (which can be tested with ZSTD_isError()).
Special: Adding any prefix (including NULL) invalidates any previous prefix or dictionary
Note 1 : Prefix buffer is referenced. It <strong>must</strong> outlive compression.
Its content must remain unmodified during compression.
Note 2 : If the intention is to diff some large src data blob with some prior version of itself,
ensure that the window size is large enough to contain the entire source.
See ZSTD_c_windowLog.
Note 3 : Referencing a prefix involves building tables, which are dependent on compression parameters.
It’s a CPU consuming operation, with non-negligible impact on latency.
If there is a need to use the same prefix multiple times, consider loadDictionary instead.
Note 4 : By default, the prefix is interpreted as raw content (ZSTD_dct_rawContent).
Use experimental ZSTD_CCtx_refPrefix_advanced() to alter dictionary interpretation.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_CCtx_refPrefix_advanced.html" title="fn zstd_sys::ZSTD_CCtx_refPrefix_advanced">ZSTD_CCtx_refPrefix_advanced</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_CCtx_refPrefix_advanced() :
Same as ZSTD_CCtx_refPrefix(), but gives finer control over
how to interpret prefix content (automatic ? force raw mode (default) ? full mode only ?)</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_CCtx_refThreadPool.html" title="fn zstd_sys::ZSTD_CCtx_refThreadPool">ZSTD_CCtx_refThreadPool</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_CCtx_reset.html" title="fn zstd_sys::ZSTD_CCtx_reset">ZSTD_CCtx_reset</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_CCtx_reset() :
There are 2 different things that can be reset, independently or jointly :</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_CCtx_setParameter.html" title="fn zstd_sys::ZSTD_CCtx_setParameter">ZSTD_CCtx_setParameter</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_CCtx_setParameter() :
Set one compression parameter, selected by enum ZSTD_cParameter.
All parameters have valid bounds. Bounds can be queried using ZSTD_cParam_getBounds().
Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter).
Setting a parameter is generally only possible during frame initialization (before starting compression).
Exception : when using multi-threading mode (nbWorkers &gt;= 1),
the following parameters can be updated <em>during</em> compression (within same frame):
=&gt; compressionLevel, hashLog, chainLog, searchLog, minMatch, targetLength and strategy.
new parameters will be active for next job only (after a flush()).
@return : an error code (which can be tested using ZSTD_isError()).</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_CCtx_setParametersUsingCCtxParams.html" title="fn zstd_sys::ZSTD_CCtx_setParametersUsingCCtxParams">ZSTD_CCtx_setParametersUsingCCtxParams</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_CCtx_setParametersUsingCCtxParams() :
Apply a set of ZSTD_CCtx_params to the compression context.
This can be done even after compression is started,
if nbWorkers==0, this will have no impact until a new compression is started.
if nbWorkers&gt;=1, new parameters will be picked up at next job,
with a few restrictions (windowLog, pledgedSrcSize, nbWorkers, jobSize, and overlapLog are not updated).</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_CCtx_setPledgedSrcSize.html" title="fn zstd_sys::ZSTD_CCtx_setPledgedSrcSize">ZSTD_CCtx_setPledgedSrcSize</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_CCtx_setPledgedSrcSize() :
Total input data size to be compressed as a single frame.
Value will be written in frame header, unless if explicitly forbidden using ZSTD_c_contentSizeFlag.
This value will also be controlled at end of frame, and trigger an error if not respected.
@result : 0, or an error code (which can be tested with ZSTD_isError()).
Note 1 : pledgedSrcSize==0 actually means zero, aka an empty frame.
In order to mean “unknown content size”, pass constant ZSTD_CONTENTSIZE_UNKNOWN.
ZSTD_CONTENTSIZE_UNKNOWN is default value for any new frame.
Note 2 : pledgedSrcSize is only valid once, for the next frame.
It’s discarded at the end of the frame, and replaced by ZSTD_CONTENTSIZE_UNKNOWN.
Note 3 : Whenever all input data is provided and consumed in a single round,
for example with ZSTD_compress2(),
or invoking immediately ZSTD_compressStream2(,,,ZSTD_e_end),
this value is automatically overridden by srcSize instead.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_CStreamInSize.html" title="fn zstd_sys::ZSTD_CStreamInSize">ZSTD_CStreamInSize</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_CStreamOutSize.html" title="fn zstd_sys::ZSTD_CStreamOutSize">ZSTD_CStreamOutSize</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_DCtx_getParameter.html" title="fn zstd_sys::ZSTD_DCtx_getParameter">ZSTD_DCtx_getParameter</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_DCtx_getParameter() :
Get the requested decompression parameter value, selected by enum ZSTD_dParameter,
and store it into int* value.
@return : 0, or an error code (which can be tested with ZSTD_isError()).</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_DCtx_loadDictionary.html" title="fn zstd_sys::ZSTD_DCtx_loadDictionary">ZSTD_DCtx_loadDictionary</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_DCtx_loadDictionary() :
Create an internal DDict from dict buffer,
to be used to decompress next frames.
The dictionary remains valid for all future frames, until explicitly invalidated.
@result : 0, or an error code (which can be tested with ZSTD_isError()).
Special : Adding a NULL (or 0-size) dictionary invalidates any previous dictionary,
meaning “return to no-dictionary mode”.
Note 1 : Loading a dictionary involves building tables,
which has a non-negligible impact on CPU usage and latency.
It’s recommended to “load once, use many times”, to amortize the cost
Note 2 :<code>dict</code> content will be copied internally, so <code>dict</code> can be released after loading.
Use ZSTD_DCtx_loadDictionary_byReference() to reference dictionary content instead.
Note 3 : Use ZSTD_DCtx_loadDictionary_advanced() to take control of
how dictionary content is loaded and interpreted.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_DCtx_loadDictionary_advanced.html" title="fn zstd_sys::ZSTD_DCtx_loadDictionary_advanced">ZSTD_DCtx_loadDictionary_advanced</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_DCtx_loadDictionary_advanced() :
Same as ZSTD_DCtx_loadDictionary(),
but gives direct control over
how to load the dictionary (by copy ? by reference ?)
and how to interpret it (automatic ? force raw mode ? full mode only ?).</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_DCtx_loadDictionary_byReference.html" title="fn zstd_sys::ZSTD_DCtx_loadDictionary_byReference">ZSTD_DCtx_loadDictionary_byReference</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_DCtx_loadDictionary_byReference() :
Same as ZSTD_DCtx_loadDictionary(),
but references <code>dict</code> content instead of copying it into <code>dctx</code>.
This saves memory if <code>dict</code> remains around.,
However, it’s imperative that <code>dict</code> remains accessible (and unmodified) while being used, so it must outlive decompression.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_DCtx_refDDict.html" title="fn zstd_sys::ZSTD_DCtx_refDDict">ZSTD_DCtx_refDDict</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_DCtx_refDDict() :
Reference a prepared dictionary, to be used to decompress next frames.
The dictionary remains active for decompression of future frames using same DCtx.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_DCtx_refPrefix.html" title="fn zstd_sys::ZSTD_DCtx_refPrefix">ZSTD_DCtx_refPrefix</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_DCtx_refPrefix() :
Reference a prefix (single-usage dictionary) to decompress next frame.
This is the reverse operation of ZSTD_CCtx_refPrefix(),
and must use the same prefix as the one used during compression.
Prefix is <strong>only used once</strong>. Reference is discarded at end of frame.
End of frame is reached when ZSTD_decompressStream() returns 0.
@result : 0, or an error code (which can be tested with ZSTD_isError()).
Note 1 : Adding any prefix (including NULL) invalidates any previously set prefix or dictionary
Note 2 : Prefix buffer is referenced. It <strong>must</strong> outlive decompression.
Prefix buffer must remain unmodified up to the end of frame,
reached when ZSTD_decompressStream() returns 0.
Note 3 : By default, the prefix is treated as raw content (ZSTD_dct_rawContent).
Use ZSTD_CCtx_refPrefix_advanced() to alter dictMode (Experimental section)
Note 4 : Referencing a raw content prefix has almost no cpu nor memory cost.
A full dictionary is more costly, as it requires building tables.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_DCtx_refPrefix_advanced.html" title="fn zstd_sys::ZSTD_DCtx_refPrefix_advanced">ZSTD_DCtx_refPrefix_advanced</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_DCtx_refPrefix_advanced() :
Same as ZSTD_DCtx_refPrefix(), but gives finer control over
how to interpret prefix content (automatic ? force raw mode (default) ? full mode only ?)</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_DCtx_reset.html" title="fn zstd_sys::ZSTD_DCtx_reset">ZSTD_DCtx_reset</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_DCtx_reset() :
Return a DCtx to clean state.
Session and parameters can be reset jointly or separately.
Parameters can only be reset when no active frame is being decompressed.
@return : 0, or an error code, which can be tested with ZSTD_isError()</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_DCtx_setFormat.html" title="fn zstd_sys::ZSTD_DCtx_setFormat">ZSTD_DCtx_setFormat</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_DCtx_setFormat() :
Instruct the decoder context about what kind of data to decode next.
This instruction is mandatory to decode data without a fully-formed header,
such ZSTD_f_zstd1_magicless for example.
@return : 0, or an error code (which can be tested using ZSTD_isError()).</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_DCtx_setMaxWindowSize.html" title="fn zstd_sys::ZSTD_DCtx_setMaxWindowSize">ZSTD_DCtx_setMaxWindowSize</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_DCtx_setMaxWindowSize() :
Refuses allocating internal buffers for frames requiring a window size larger than provided limit.
This protects a decoder context from reserving too much memory for itself (potential attack scenario).
This parameter is only useful in streaming mode, since no internal buffer is allocated in single-pass mode.
By default, a decompression context accepts all window sizes &lt;= (1 &lt;&lt; ZSTD_WINDOWLOG_LIMIT_DEFAULT)
@return : 0, or an error code (which can be tested using ZSTD_isError()).</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_DCtx_setParameter.html" title="fn zstd_sys::ZSTD_DCtx_setParameter">ZSTD_DCtx_setParameter</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_DCtx_setParameter() :
Set one compression parameter, selected by enum ZSTD_dParameter.
All parameters have valid bounds. Bounds can be queried using ZSTD_dParam_getBounds().
Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter).
Setting a parameter is only possible during frame initialization (before starting decompression).
@return : 0, or an error code (which can be tested using ZSTD_isError()).</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_DStreamInSize.html" title="fn zstd_sys::ZSTD_DStreamInSize">ZSTD_DStreamInSize</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_DStreamOutSize.html" title="fn zstd_sys::ZSTD_DStreamOutSize">ZSTD_DStreamOutSize</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_adjustCParams.html" title="fn zstd_sys::ZSTD_adjustCParams">ZSTD_adjustCParams</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_adjustCParams() :
optimize params for a given <code>srcSize</code> and <code>dictSize</code>.
<code>srcSize</code> can be unknown, in which case use ZSTD_CONTENTSIZE_UNKNOWN.
<code>dictSize</code> must be <code>0</code> when there is no dictionary.
cPar can be invalid : all parameters will be clamped within valid range in the @return struct.
This function never fails (wide contract)</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_cParam_getBounds.html" title="fn zstd_sys::ZSTD_cParam_getBounds">ZSTD_cParam_getBounds</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_cParam_getBounds() :
All parameters must belong to an interval with lower and upper bounds,
otherwise they will either trigger an error or be automatically clamped.
@return : a structure, ZSTD_bounds, which contains
- an error status field, which must be tested using ZSTD_isError()
- lower and upper bounds, both inclusive</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_checkCParams.html" title="fn zstd_sys::ZSTD_checkCParams">ZSTD_checkCParams</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_checkCParams() :
Ensure param values remain within authorized range.
@return 0 on success, or an error code (can be checked with ZSTD_isError())</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_compress.html" title="fn zstd_sys::ZSTD_compress">ZSTD_compress</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Simple API
Compresses <code>src</code> content as a single zstd compressed frame into already allocated <code>dst</code>.
Hint : compression runs faster if <code>dstCapacity</code> &gt;=  <code>ZSTD_compressBound(srcSize)</code>.
@return : compressed size written into <code>dst</code> (&lt;= `dstCapacity),
or an error code if it fails (which can be tested using ZSTD_isError()).</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_compress2.html" title="fn zstd_sys::ZSTD_compress2">ZSTD_compress2</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_compress2() :
Behave the same as ZSTD_compressCCtx(), but compression parameters are set using the advanced API.
ZSTD_compress2() always starts a new frame.
Should cctx hold data from a previously unfinished frame, everything about it is forgotten.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_compressBegin.html" title="fn zstd_sys::ZSTD_compressBegin">ZSTD_compressBegin</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Buffer-less streaming compression (synchronous mode)</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_compressBegin_advanced.html" title="fn zstd_sys::ZSTD_compressBegin_advanced">ZSTD_compressBegin_advanced</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_compressBegin_usingCDict.html" title="fn zstd_sys::ZSTD_compressBegin_usingCDict">ZSTD_compressBegin_usingCDict</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_compressBegin_usingCDict_advanced.html" title="fn zstd_sys::ZSTD_compressBegin_usingCDict_advanced">ZSTD_compressBegin_usingCDict_advanced</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_compressBegin_usingDict.html" title="fn zstd_sys::ZSTD_compressBegin_usingDict">ZSTD_compressBegin_usingDict</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_compressBlock.html" title="fn zstd_sys::ZSTD_compressBlock">ZSTD_compressBlock</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_compressBound.html" title="fn zstd_sys::ZSTD_compressBound">ZSTD_compressBound</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_compressCCtx.html" title="fn zstd_sys::ZSTD_compressCCtx">ZSTD_compressCCtx</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_compressCCtx() :
Same as ZSTD_compress(), using an explicit ZSTD_CCtx.
Important : in order to behave similarly to <code>ZSTD_compress()</code>,
this function compresses at requested compression level,
<strong>ignoring any other parameter</strong> .
If any advanced parameter was set using the advanced API,
they will all be reset. Only <code>compressionLevel</code> remains.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_compressContinue.html" title="fn zstd_sys::ZSTD_compressContinue">ZSTD_compressContinue</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_compressEnd.html" title="fn zstd_sys::ZSTD_compressEnd">ZSTD_compressEnd</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_compressSequences.html" title="fn zstd_sys::ZSTD_compressSequences">ZSTD_compressSequences</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_compressSequences() :
Compress an array of ZSTD_Sequence, generated from the original source buffer, into dst.
If a dictionary is included, then the cctx should reference the dict. (see: ZSTD_CCtx_refCDict(), ZSTD_CCtx_loadDictionary(), etc.)
The entire source is compressed into a single frame.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_compressStream.html" title="fn zstd_sys::ZSTD_compressStream">ZSTD_compressStream</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Alternative for ZSTD_compressStream2(zcs, output, input, ZSTD_e_continue).
NOTE: The return value is different. ZSTD_compressStream() returns a hint for
the next read size (if non-zero and not an error). ZSTD_compressStream2()
returns the minimum nb of bytes left to flush (if non-zero and not an error).</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_compressStream2.html" title="fn zstd_sys::ZSTD_compressStream2">ZSTD_compressStream2</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_compressStream2() :
Behaves about the same as ZSTD_compressStream, with additional control on end directive.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_compressStream2_simpleArgs.html" title="fn zstd_sys::ZSTD_compressStream2_simpleArgs">ZSTD_compressStream2_simpleArgs</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_compressStream2_simpleArgs() :
Same as ZSTD_compressStream2(),
but using only integral types as arguments.
This variant might be helpful for binders from dynamic languages
which have troubles handling structures containing memory pointers.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_compress_advanced.html" title="fn zstd_sys::ZSTD_compress_advanced">ZSTD_compress_advanced</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_compress_advanced() :
Note : this function is now DEPRECATED.
It can be replaced by ZSTD_compress2(), in combination with ZSTD_CCtx_setParameter() and other parameter setters.
This prototype will be marked as deprecated and generate compilation warning on reaching v1.5.x</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_compress_usingCDict.html" title="fn zstd_sys::ZSTD_compress_usingCDict">ZSTD_compress_usingCDict</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_compress_usingCDict() :
Compression using a digested Dictionary.
Recommended when same dictionary is used multiple times.
Note : compression level is <em>decided at dictionary creation time</em>,
and frame parameters are hardcoded (dictID=yes, contentSize=yes, checksum=no)</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_compress_usingCDict_advanced.html" title="fn zstd_sys::ZSTD_compress_usingCDict_advanced">ZSTD_compress_usingCDict_advanced</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_compress_usingCDict_advanced() :
Note : this function is now REDUNDANT.
It can be replaced by ZSTD_compress2(), in combination with ZSTD_CCtx_loadDictionary() and other parameter setters.
This prototype will be marked as deprecated and generate compilation warning in some future version</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_compress_usingDict.html" title="fn zstd_sys::ZSTD_compress_usingDict">ZSTD_compress_usingDict</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Simple dictionary API
Compression at an explicit compression level using a Dictionary.
A dictionary can be any arbitrary data segment (also called a prefix),
or a buffer with specified information (see dictBuilder/zdict.h).
Note : This function loads the dictionary, resulting in significant startup delay.
It’s intended for a dictionary used only once.
Note 2 : When <code>dict == NULL || dictSize &lt; 8</code> no dictionary is used.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_copyCCtx.html" title="fn zstd_sys::ZSTD_copyCCtx">ZSTD_copyCCtx</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_copyDCtx.html" title="fn zstd_sys::ZSTD_copyDCtx">ZSTD_copyDCtx</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_createCCtx.html" title="fn zstd_sys::ZSTD_createCCtx">ZSTD_createCCtx</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_createCCtxParams.html" title="fn zstd_sys::ZSTD_createCCtxParams">ZSTD_createCCtxParams</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_CCtx_params :
Quick howto :</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_createCCtx_advanced.html" title="fn zstd_sys::ZSTD_createCCtx_advanced">ZSTD_createCCtx_advanced</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_createCDict.html" title="fn zstd_sys::ZSTD_createCDict">ZSTD_createCDict</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_createCDict() :
When compressing multiple messages or blocks using the same dictionary,
it’s recommended to digest the dictionary only once, since it’s a costly operation.
ZSTD_createCDict() will create a state from digesting a dictionary.
The resulting state can be used for future compression operations with very limited startup cost.
ZSTD_CDict can be created once and shared by multiple threads concurrently, since its usage is read-only.
@dictBuffer can be released after ZSTD_CDict creation, because its content is copied within CDict.
Note 1 : Consider experimental function <code>ZSTD_createCDict_byReference()</code> if you prefer to not duplicate @dictBuffer content.
Note 2 : A ZSTD_CDict can be created from an empty @dictBuffer,
in which case the only thing that it transports is the @compressionLevel.
This can be useful in a pipeline featuring ZSTD_compress_usingCDict() exclusively,
expecting a ZSTD_CDict parameter with any data, including those without a known dictionary.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_createCDict_advanced.html" title="fn zstd_sys::ZSTD_createCDict_advanced">ZSTD_createCDict_advanced</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_createCDict_advanced2.html" title="fn zstd_sys::ZSTD_createCDict_advanced2">ZSTD_createCDict_advanced2</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_createCDict_byReference.html" title="fn zstd_sys::ZSTD_createCDict_byReference">ZSTD_createCDict_byReference</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_createCDict_byReference() :
Create a digested dictionary for compression
Dictionary content is just referenced, not duplicated.
As a consequence, <code>dictBuffer</code> <strong>must</strong> outlive CDict,
and its content must remain unmodified throughout the lifetime of CDict.
note: equivalent to ZSTD_createCDict_advanced(), with dictLoadMethod==ZSTD_dlm_byRef</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_createCStream.html" title="fn zstd_sys::ZSTD_createCStream">ZSTD_createCStream</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_createCStream_advanced.html" title="fn zstd_sys::ZSTD_createCStream_advanced">ZSTD_createCStream_advanced</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_createDCtx.html" title="fn zstd_sys::ZSTD_createDCtx">ZSTD_createDCtx</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_createDCtx_advanced.html" title="fn zstd_sys::ZSTD_createDCtx_advanced">ZSTD_createDCtx_advanced</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_createDDict.html" title="fn zstd_sys::ZSTD_createDDict">ZSTD_createDDict</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_createDDict() :
Create a digested dictionary, ready to start decompression operation without startup delay.
dictBuffer can be released after DDict creation, as its content is copied inside DDict.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_createDDict_advanced.html" title="fn zstd_sys::ZSTD_createDDict_advanced">ZSTD_createDDict_advanced</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_createDDict_byReference.html" title="fn zstd_sys::ZSTD_createDDict_byReference">ZSTD_createDDict_byReference</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_createDDict_byReference() :
Create a digested dictionary, ready to start decompression operation without startup delay.
Dictionary content is referenced, and therefore stays in dictBuffer.
It is important that dictBuffer outlives DDict,
it must remain read accessible throughout the lifetime of DDict</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_createDStream.html" title="fn zstd_sys::ZSTD_createDStream">ZSTD_createDStream</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_createDStream_advanced.html" title="fn zstd_sys::ZSTD_createDStream_advanced">ZSTD_createDStream_advanced</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_createThreadPool.html" title="fn zstd_sys::ZSTD_createThreadPool">ZSTD_createThreadPool</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_dParam_getBounds.html" title="fn zstd_sys::ZSTD_dParam_getBounds">ZSTD_dParam_getBounds</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_dParam_getBounds() :
All parameters must belong to an interval with lower and upper bounds,
otherwise they will either trigger an error or be automatically clamped.
@return : a structure, ZSTD_bounds, which contains
- an error status field, which must be tested using ZSTD_isError()
- both lower and upper bounds, inclusive</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_decodingBufferSize_min.html" title="fn zstd_sys::ZSTD_decodingBufferSize_min">ZSTD_decodingBufferSize_min</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_decompress.html" title="fn zstd_sys::ZSTD_decompress">ZSTD_decompress</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_decompress() :
<code>compressedSize</code> : must be the <em>exact</em> size of some number of compressed and/or skippable frames.
<code>dstCapacity</code> is an upper bound of originalSize to regenerate.
If user cannot imply a maximum upper bound, it’s better to use streaming mode to decompress data.
@return : the number of bytes decompressed into <code>dst</code> (&lt;= <code>dstCapacity</code>),
or an errorCode if it fails (which can be tested using ZSTD_isError()).</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_decompressBegin.html" title="fn zstd_sys::ZSTD_decompressBegin">ZSTD_decompressBegin</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_decompressBegin_usingDDict.html" title="fn zstd_sys::ZSTD_decompressBegin_usingDDict">ZSTD_decompressBegin_usingDDict</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_decompressBegin_usingDict.html" title="fn zstd_sys::ZSTD_decompressBegin_usingDict">ZSTD_decompressBegin_usingDict</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_decompressBlock.html" title="fn zstd_sys::ZSTD_decompressBlock">ZSTD_decompressBlock</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_decompressBound.html" title="fn zstd_sys::ZSTD_decompressBound">ZSTD_decompressBound</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_decompressBound() :
<code>src</code> should point to the start of a series of ZSTD encoded and/or skippable frames
<code>srcSize</code> must be the <em>exact</em> size of this series
(i.e. there should be a frame boundary at <code>src + srcSize</code>)
@return : - upper-bound for the decompressed size of all data in all successive frames
- if an error occurred: ZSTD_CONTENTSIZE_ERROR</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_decompressContinue.html" title="fn zstd_sys::ZSTD_decompressContinue">ZSTD_decompressContinue</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_decompressDCtx.html" title="fn zstd_sys::ZSTD_decompressDCtx">ZSTD_decompressDCtx</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_decompressDCtx() :
Same as ZSTD_decompress(),
requires an allocated ZSTD_DCtx.
Compatible with sticky parameters.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_decompressStream.html" title="fn zstd_sys::ZSTD_decompressStream">ZSTD_decompressStream</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_decompressStream_simpleArgs.html" title="fn zstd_sys::ZSTD_decompressStream_simpleArgs">ZSTD_decompressStream_simpleArgs</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_decompressStream_simpleArgs() :
Same as ZSTD_decompressStream(),
but using only integral types as arguments.
This can be helpful for binders from dynamic languages
which have troubles handling structures containing memory pointers.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_decompress_usingDDict.html" title="fn zstd_sys::ZSTD_decompress_usingDDict">ZSTD_decompress_usingDDict</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_decompress_usingDDict() :
Decompression using a digested Dictionary.
Recommended when same dictionary is used multiple times.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_decompress_usingDict.html" title="fn zstd_sys::ZSTD_decompress_usingDict">ZSTD_decompress_usingDict</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_decompress_usingDict() :
Decompression using a known Dictionary.
Dictionary must be identical to the one used during compression.
Note : This function loads the dictionary, resulting in significant startup delay.
It’s intended for a dictionary used only once.
Note : When <code>dict == NULL || dictSize &lt; 8</code> no dictionary is used.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_endStream.html" title="fn zstd_sys::ZSTD_endStream">ZSTD_endStream</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Equivalent to ZSTD_compressStream2(zcs, output, &amp;emptyInput, ZSTD_e_end).</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_estimateCCtxSize.html" title="fn zstd_sys::ZSTD_estimateCCtxSize">ZSTD_estimateCCtxSize</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_estimate*() :
These functions make it possible to estimate memory usage
of a future {D,C}Ctx, before its creation.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_estimateCCtxSize_usingCCtxParams.html" title="fn zstd_sys::ZSTD_estimateCCtxSize_usingCCtxParams">ZSTD_estimateCCtxSize_usingCCtxParams</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_estimateCCtxSize_usingCParams.html" title="fn zstd_sys::ZSTD_estimateCCtxSize_usingCParams">ZSTD_estimateCCtxSize_usingCParams</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_estimateCDictSize.html" title="fn zstd_sys::ZSTD_estimateCDictSize">ZSTD_estimateCDictSize</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_estimate?DictSize() :
ZSTD_estimateCDictSize() will bet that src size is relatively “small”, and content is copied, like ZSTD_createCDict().
ZSTD_estimateCDictSize_advanced() makes it possible to control compression parameters precisely, like ZSTD_createCDict_advanced().
Note : dictionaries created by reference (<code>ZSTD_dlm_byRef</code>) are logically smaller.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_estimateCDictSize_advanced.html" title="fn zstd_sys::ZSTD_estimateCDictSize_advanced">ZSTD_estimateCDictSize_advanced</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_estimateCStreamSize.html" title="fn zstd_sys::ZSTD_estimateCStreamSize">ZSTD_estimateCStreamSize</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_estimateCStreamSize() :
ZSTD_estimateCStreamSize() will provide a budget large enough for any compression level up to selected one.
It will also consider src size to be arbitrarily “large”, which is worst case.
If srcSize is known to always be small, ZSTD_estimateCStreamSize_usingCParams() can provide a tighter estimation.
ZSTD_estimateCStreamSize_usingCParams() can be used in tandem with ZSTD_getCParams() to create cParams from compressionLevel.
ZSTD_estimateCStreamSize_usingCCtxParams() can be used in tandem with ZSTD_CCtxParams_setParameter(). Only single-threaded compression is supported. This function will return an error code if ZSTD_c_nbWorkers is &gt;= 1.
Note : CStream size estimation is only correct for single-threaded compression.
ZSTD_DStream memory budget depends on window Size.
This information can be passed manually, using ZSTD_estimateDStreamSize,
or deducted from a valid frame Header, using ZSTD_estimateDStreamSize_fromFrame();
Note : if streaming is init with function ZSTD_init?Stream_usingDict(),
an internal ?Dict will be created, which additional size is not estimated here.
In this case, get total size by adding ZSTD_estimate?DictSize</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_estimateCStreamSize_usingCCtxParams.html" title="fn zstd_sys::ZSTD_estimateCStreamSize_usingCCtxParams">ZSTD_estimateCStreamSize_usingCCtxParams</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_estimateCStreamSize_usingCParams.html" title="fn zstd_sys::ZSTD_estimateCStreamSize_usingCParams">ZSTD_estimateCStreamSize_usingCParams</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_estimateDCtxSize.html" title="fn zstd_sys::ZSTD_estimateDCtxSize">ZSTD_estimateDCtxSize</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_estimateDDictSize.html" title="fn zstd_sys::ZSTD_estimateDDictSize">ZSTD_estimateDDictSize</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_estimateDStreamSize.html" title="fn zstd_sys::ZSTD_estimateDStreamSize">ZSTD_estimateDStreamSize</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_estimateDStreamSize_fromFrame.html" title="fn zstd_sys::ZSTD_estimateDStreamSize_fromFrame">ZSTD_estimateDStreamSize_fromFrame</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_findDecompressedSize.html" title="fn zstd_sys::ZSTD_findDecompressedSize">ZSTD_findDecompressedSize</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_findDecompressedSize() :
<code>src</code> should point to the start of a series of ZSTD encoded and/or skippable frames
<code>srcSize</code> must be the <em>exact</em> size of this series
(i.e. there should be a frame boundary at <code>src + srcSize</code>)
@return : - decompressed size of all data in all successive frames
- if the decompressed size cannot be determined: ZSTD_CONTENTSIZE_UNKNOWN
- if an error occurred: ZSTD_CONTENTSIZE_ERROR</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_findFrameCompressedSize.html" title="fn zstd_sys::ZSTD_findFrameCompressedSize">ZSTD_findFrameCompressedSize</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_findFrameCompressedSize() :
<code>src</code> should point to the start of a ZSTD frame or skippable frame.
<code>srcSize</code> must be &gt;= first frame size
@return : the compressed size of the first frame starting at <code>src</code>,
suitable to pass as <code>srcSize</code> to <code>ZSTD_decompress</code> or similar,
or an error code if input is invalid</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_flushStream.html" title="fn zstd_sys::ZSTD_flushStream">ZSTD_flushStream</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Equivalent to ZSTD_compressStream2(zcs, output, &amp;emptyInput, ZSTD_e_flush).</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_frameHeaderSize.html" title="fn zstd_sys::ZSTD_frameHeaderSize">ZSTD_frameHeaderSize</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_frameHeaderSize() :
srcSize must be &gt;= ZSTD_FRAMEHEADERSIZE_PREFIX.
@return : size of the Frame Header,
or an error code (if srcSize is too small)</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_freeCCtx.html" title="fn zstd_sys::ZSTD_freeCCtx">ZSTD_freeCCtx</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_freeCCtxParams.html" title="fn zstd_sys::ZSTD_freeCCtxParams">ZSTD_freeCCtxParams</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_freeCDict.html" title="fn zstd_sys::ZSTD_freeCDict">ZSTD_freeCDict</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_freeCDict() :
Function frees memory allocated by ZSTD_createCDict().</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_freeCStream.html" title="fn zstd_sys::ZSTD_freeCStream">ZSTD_freeCStream</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_freeDCtx.html" title="fn zstd_sys::ZSTD_freeDCtx">ZSTD_freeDCtx</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_freeDDict.html" title="fn zstd_sys::ZSTD_freeDDict">ZSTD_freeDDict</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_freeDDict() :
Function frees memory allocated with ZSTD_createDDict()</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_freeDStream.html" title="fn zstd_sys::ZSTD_freeDStream">ZSTD_freeDStream</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_freeThreadPool.html" title="fn zstd_sys::ZSTD_freeThreadPool">ZSTD_freeThreadPool</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_generateSequences.html" title="fn zstd_sys::ZSTD_generateSequences">ZSTD_generateSequences</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_generateSequences() :
Generate sequences using ZSTD_compress2, given a source buffer.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_getBlockSize.html" title="fn zstd_sys::ZSTD_getBlockSize">ZSTD_getBlockSize</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Block functions produce and decode raw zstd blocks, without frame metadata.
Frame metadata cost is typically ~12 bytes, which can be non-negligible for very small blocks (&lt; 100 bytes).
But users will have to take in charge needed metadata to regenerate data, such as compressed and content sizes.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_getCParams.html" title="fn zstd_sys::ZSTD_getCParams">ZSTD_getCParams</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_getCParams() :
@return ZSTD_compressionParameters structure for a selected compression level and estimated srcSize.
<code>estimatedSrcSize</code> value is optional, select 0 if not known</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_getDecompressedSize.html" title="fn zstd_sys::ZSTD_getDecompressedSize">ZSTD_getDecompressedSize</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_getDecompressedSize() :
NOTE: This function is now obsolete, in favor of ZSTD_getFrameContentSize().
Both functions work the same way, but ZSTD_getDecompressedSize() blends
“empty”, “unknown” and “error” results to the same return value (0),
while ZSTD_getFrameContentSize() gives them separate return values.
@return : decompressed size of <code>src</code> frame content <em>if known and not empty</em>, 0 otherwise.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_getDictID_fromCDict.html" title="fn zstd_sys::ZSTD_getDictID_fromCDict">ZSTD_getDictID_fromCDict</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_getDictID_fromCDict() :
Provides the dictID of the dictionary loaded into <code>cdict</code>.
If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.
Non-conformant dictionaries can still be loaded, but as content-only dictionaries.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_getDictID_fromDDict.html" title="fn zstd_sys::ZSTD_getDictID_fromDDict">ZSTD_getDictID_fromDDict</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_getDictID_fromDDict() :
Provides the dictID of the dictionary loaded into <code>ddict</code>.
If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.
Non-conformant dictionaries can still be loaded, but as content-only dictionaries.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_getDictID_fromDict.html" title="fn zstd_sys::ZSTD_getDictID_fromDict">ZSTD_getDictID_fromDict</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_getDictID_fromDict() :
Provides the dictID stored within dictionary.
if @return == 0, the dictionary is not conformant with Zstandard specification.
It can still be loaded, but as a content-only dictionary.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_getDictID_fromFrame.html" title="fn zstd_sys::ZSTD_getDictID_fromFrame">ZSTD_getDictID_fromFrame</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_getDictID_fromFrame() :
Provides the dictID required to decompressed the frame stored within <code>src</code>.
If @return == 0, the dictID could not be decoded.
This could for one of the following reasons :</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_getErrorName.html" title="fn zstd_sys::ZSTD_getErrorName">ZSTD_getErrorName</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_getFrameContentSize.html" title="fn zstd_sys::ZSTD_getFrameContentSize">ZSTD_getFrameContentSize</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_getFrameHeader.html" title="fn zstd_sys::ZSTD_getFrameHeader">ZSTD_getFrameHeader</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_getFrameHeader() :
decode Frame Header, or requires larger <code>srcSize</code>.
@return : 0, <code>zfhPtr</code> is correctly filled,
&gt;0, <code>srcSize</code> is too small, value is wanted <code>srcSize</code> amount,
or an error code, which can be tested using ZSTD_isError()</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_getFrameHeader_advanced.html" title="fn zstd_sys::ZSTD_getFrameHeader_advanced">ZSTD_getFrameHeader_advanced</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_getFrameHeader_advanced() :
same as ZSTD_getFrameHeader(),
with added capability to select a format (like ZSTD_f_zstd1_magicless)</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_getFrameProgression.html" title="fn zstd_sys::ZSTD_getFrameProgression">ZSTD_getFrameProgression</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_getParams.html" title="fn zstd_sys::ZSTD_getParams">ZSTD_getParams</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_getParams() :
same as ZSTD_getCParams(), but @return a full <code>ZSTD_parameters</code> object instead of sub-component <code>ZSTD_compressionParameters</code>.
All fields of <code>ZSTD_frameParameters</code> are set to default : contentSize=1, checksum=0, noDictID=0</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_initCStream.html" title="fn zstd_sys::ZSTD_initCStream">ZSTD_initCStream</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Equivalent to:</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_initCStream_advanced.html" title="fn zstd_sys::ZSTD_initCStream_advanced">ZSTD_initCStream_advanced</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_initCStream_advanced() :
This function is deprecated, and is approximately equivalent to:
ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
// Pseudocode: Set each zstd parameter and leave the rest as-is.
for ((param, value) : params) {
ZSTD_CCtx_setParameter(zcs, param, value);
}
ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);
ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_initCStream_srcSize.html" title="fn zstd_sys::ZSTD_initCStream_srcSize">ZSTD_initCStream_srcSize</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_initCStream_srcSize() :
This function is deprecated, and equivalent to:
ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any)
ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);
ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_initCStream_usingCDict.html" title="fn zstd_sys::ZSTD_initCStream_usingCDict">ZSTD_initCStream_usingCDict</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_initCStream_usingCDict() :
This function is deprecated, and equivalent to:
ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
ZSTD_CCtx_refCDict(zcs, cdict);</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_initCStream_usingCDict_advanced.html" title="fn zstd_sys::ZSTD_initCStream_usingCDict_advanced">ZSTD_initCStream_usingCDict_advanced</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_initCStream_usingCDict_advanced() :
This function is DEPRECATED, and is approximately equivalent to:
ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
// Pseudocode: Set each zstd frame parameter and leave the rest as-is.
for ((fParam, value) : fParams) {
ZSTD_CCtx_setParameter(zcs, fParam, value);
}
ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);
ZSTD_CCtx_refCDict(zcs, cdict);</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_initCStream_usingDict.html" title="fn zstd_sys::ZSTD_initCStream_usingDict">ZSTD_initCStream_usingDict</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_initCStream_usingDict() :
This function is deprecated, and is equivalent to:
ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);
ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_initDStream.html" title="fn zstd_sys::ZSTD_initDStream">ZSTD_initDStream</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_initDStream_usingDDict.html" title="fn zstd_sys::ZSTD_initDStream_usingDDict">ZSTD_initDStream_usingDDict</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">This function is deprecated, and is equivalent to:</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_initDStream_usingDict.html" title="fn zstd_sys::ZSTD_initDStream_usingDict">ZSTD_initDStream_usingDict</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">This function is deprecated, and is equivalent to:</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_initStaticCCtx.html" title="fn zstd_sys::ZSTD_initStaticCCtx">ZSTD_initStaticCCtx</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_initStatic*() :
Initialize an object using a pre-allocated fixed-size buffer.
workspace: The memory area to emplace the object into.
Provided pointer <em>must be 8-bytes aligned</em>.
Buffer must outlive object.
workspaceSize: Use ZSTD_estimate*Size() to determine
how large workspace must be to support target scenario.
@return : pointer to object (same address as workspace, just different type),
or NULL if error (size too small, incorrect alignment, etc.)
Note : zstd will never resize nor malloc() when using a static buffer.
If the object requires more memory than available,
zstd will just error out (typically ZSTD_error_memory_allocation).
Note 2 : there is no corresponding “free” function.
Since workspace is allocated externally, it must be freed externally too.
Note 3 : cParams : use ZSTD_getCParams() to convert a compression level
into its associated cParams.
Limitation 1 : currently not compatible with internal dictionary creation, triggered by
ZSTD_CCtx_loadDictionary(), ZSTD_initCStream_usingDict() or ZSTD_initDStream_usingDict().
Limitation 2 : static cctx currently not compatible with multi-threading.
Limitation 3 : static dctx is incompatible with legacy support.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_initStaticCDict.html" title="fn zstd_sys::ZSTD_initStaticCDict">ZSTD_initStaticCDict</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_initStaticCStream.html" title="fn zstd_sys::ZSTD_initStaticCStream">ZSTD_initStaticCStream</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_initStaticDCtx.html" title="fn zstd_sys::ZSTD_initStaticDCtx">ZSTD_initStaticDCtx</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_initStaticDDict.html" title="fn zstd_sys::ZSTD_initStaticDDict">ZSTD_initStaticDDict</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_initStaticDStream.html" title="fn zstd_sys::ZSTD_initStaticDStream">ZSTD_initStaticDStream</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_insertBlock.html" title="fn zstd_sys::ZSTD_insertBlock">ZSTD_insertBlock</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_isError.html" title="fn zstd_sys::ZSTD_isError">ZSTD_isError</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_isFrame.html" title="fn zstd_sys::ZSTD_isFrame">ZSTD_isFrame</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_isFrame() :
Tells if the content of <code>buffer</code> starts with a valid Frame Identifier.
Note : Frame Identifier is 4 bytes. If <code>size &lt; 4</code>, @return will always be 0.
Note 2 : Legacy Frame Identifiers are considered valid only if Legacy Support is enabled.
Note 3 : Skippable Frame Identifiers are considered valid.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_maxCLevel.html" title="fn zstd_sys::ZSTD_maxCLevel">ZSTD_maxCLevel</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_mergeBlockDelimiters.html" title="fn zstd_sys::ZSTD_mergeBlockDelimiters">ZSTD_mergeBlockDelimiters</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_mergeBlockDelimiters() :
Given an array of ZSTD_Sequence, remove all sequences that represent block delimiters/last literals
by merging them into into the literals of the next sequence.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_minCLevel.html" title="fn zstd_sys::ZSTD_minCLevel">ZSTD_minCLevel</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_nextInputType.html" title="fn zstd_sys::ZSTD_nextInputType">ZSTD_nextInputType</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_nextSrcSizeToDecompress.html" title="fn zstd_sys::ZSTD_nextSrcSizeToDecompress">ZSTD_nextSrcSizeToDecompress</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_resetCStream.html" title="fn zstd_sys::ZSTD_resetCStream">ZSTD_resetCStream</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_resetCStream() :
This function is deprecated, and is equivalent to:
ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_resetDStream.html" title="fn zstd_sys::ZSTD_resetDStream">ZSTD_resetDStream</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">This function is deprecated, and is equivalent to:</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_sizeof_CCtx.html" title="fn zstd_sys::ZSTD_sizeof_CCtx">ZSTD_sizeof_CCtx</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_sizeof_*() :
These functions give the <em>current</em> memory usage of selected object.
Note that object memory usage can evolve (increase or decrease) over time.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_sizeof_CDict.html" title="fn zstd_sys::ZSTD_sizeof_CDict">ZSTD_sizeof_CDict</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_sizeof_CStream.html" title="fn zstd_sys::ZSTD_sizeof_CStream">ZSTD_sizeof_CStream</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_sizeof_DCtx.html" title="fn zstd_sys::ZSTD_sizeof_DCtx">ZSTD_sizeof_DCtx</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_sizeof_DDict.html" title="fn zstd_sys::ZSTD_sizeof_DDict">ZSTD_sizeof_DDict</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_sizeof_DStream.html" title="fn zstd_sys::ZSTD_sizeof_DStream">ZSTD_sizeof_DStream</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_toFlushNow.html" title="fn zstd_sys::ZSTD_toFlushNow">ZSTD_toFlushNow</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_toFlushNow() :
Tell how many bytes are ready to be flushed immediately.
Useful for multithreading scenarios (nbWorkers &gt;= 1).
Probe the oldest active job, defined as oldest job not yet entirely flushed,
and check its output buffer.
@return : amount of data stored in oldest job and ready to be flushed immediately.
if @return == 0, it means either :</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_versionNumber.html" title="fn zstd_sys::ZSTD_versionNumber">ZSTD_versionNumber</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_versionNumber() :
Return runtime library version, the value is (MAJOR<em>100</em>100 + MINOR*100 + RELEASE).</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_versionString.html" title="fn zstd_sys::ZSTD_versionString">ZSTD_versionString</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_versionString() :
Return runtime library version, like “1.4.5”. Requires v1.3.0+.</div></li><li><div class="item-name"><a class="fn" href="fn.ZSTD_writeSkippableFrame.html" title="fn zstd_sys::ZSTD_writeSkippableFrame">ZSTD_writeSkippableFrame</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">ZSTD_writeSkippableFrame() :
Generates a zstd skippable frame containing data given by src, and writes it to dst buffer.</div></li><li><div class="item-name"><a class="fn" href="fn.__stpcpy.html" title="fn zstd_sys::__stpcpy">__stpcpy</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.__stpncpy.html" title="fn zstd_sys::__stpncpy">__stpncpy</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.__strtok_r.html" title="fn zstd_sys::__strtok_r">__strtok_r</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.bcmp.html" title="fn zstd_sys::bcmp">bcmp</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.bcopy.html" title="fn zstd_sys::bcopy">bcopy</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.bzero.html" title="fn zstd_sys::bzero">bzero</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.explicit_bzero.html" title="fn zstd_sys::explicit_bzero">explicit_bzero</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ffs.html" title="fn zstd_sys::ffs">ffs</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ffsl.html" title="fn zstd_sys::ffsl">ffsl</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.ffsll.html" title="fn zstd_sys::ffsll">ffsll</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.index.html" title="fn zstd_sys::index">index</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.memccpy.html" title="fn zstd_sys::memccpy">memccpy</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.memchr.html" title="fn zstd_sys::memchr">memchr</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.memcmp.html" title="fn zstd_sys::memcmp">memcmp</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.memcpy.html" title="fn zstd_sys::memcpy">memcpy</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.memmove.html" title="fn zstd_sys::memmove">memmove</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.memset.html" title="fn zstd_sys::memset">memset</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.rindex.html" title="fn zstd_sys::rindex">rindex</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.stpcpy.html" title="fn zstd_sys::stpcpy">stpcpy</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.stpncpy.html" title="fn zstd_sys::stpncpy">stpncpy</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strcasecmp.html" title="fn zstd_sys::strcasecmp">strcasecmp</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strcasecmp_l.html" title="fn zstd_sys::strcasecmp_l">strcasecmp_l</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strcat.html" title="fn zstd_sys::strcat">strcat</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strchr.html" title="fn zstd_sys::strchr">strchr</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strcmp.html" title="fn zstd_sys::strcmp">strcmp</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strcoll.html" title="fn zstd_sys::strcoll">strcoll</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strcoll_l.html" title="fn zstd_sys::strcoll_l">strcoll_l</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strcpy.html" title="fn zstd_sys::strcpy">strcpy</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strcspn.html" title="fn zstd_sys::strcspn">strcspn</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strdup.html" title="fn zstd_sys::strdup">strdup</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strerror.html" title="fn zstd_sys::strerror">strerror</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strerror_l.html" title="fn zstd_sys::strerror_l">strerror_l</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strerror_r.html" title="fn zstd_sys::strerror_r">strerror_r</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strlen.html" title="fn zstd_sys::strlen">strlen</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strncasecmp.html" title="fn zstd_sys::strncasecmp">strncasecmp</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strncasecmp_l.html" title="fn zstd_sys::strncasecmp_l">strncasecmp_l</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strncat.html" title="fn zstd_sys::strncat">strncat</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strncmp.html" title="fn zstd_sys::strncmp">strncmp</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strncpy.html" title="fn zstd_sys::strncpy">strncpy</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strndup.html" title="fn zstd_sys::strndup">strndup</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strnlen.html" title="fn zstd_sys::strnlen">strnlen</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strpbrk.html" title="fn zstd_sys::strpbrk">strpbrk</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strrchr.html" title="fn zstd_sys::strrchr">strrchr</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strsep.html" title="fn zstd_sys::strsep">strsep</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strsignal.html" title="fn zstd_sys::strsignal">strsignal</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strspn.html" title="fn zstd_sys::strspn">strspn</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strstr.html" title="fn zstd_sys::strstr">strstr</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strtok.html" title="fn zstd_sys::strtok">strtok</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strtok_r.html" title="fn zstd_sys::strtok_r">strtok_r</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strxfrm.html" title="fn zstd_sys::strxfrm">strxfrm</a><sup title="unsafe function">⚠</sup></div></li><li><div class="item-name"><a class="fn" href="fn.strxfrm_l.html" title="fn zstd_sys::strxfrm_l">strxfrm_l</a><sup title="unsafe function">⚠</sup></div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.ZSTDMT_CCtx.html" title="type zstd_sys::ZSTDMT_CCtx">ZSTDMT_CCtx</a></div></li><li><div class="item-name"><a class="type" href="type.ZSTD_CCtx.html" title="type zstd_sys::ZSTD_CCtx">ZSTD_CCtx</a></div><div class="desc docblock-short">Explicit context</div></li><li><div class="item-name"><a class="type" href="type.ZSTD_CCtx_params.html" title="type zstd_sys::ZSTD_CCtx_params">ZSTD_CCtx_params</a></div></li><li><div class="item-name"><a class="type" href="type.ZSTD_CDict.html" title="type zstd_sys::ZSTD_CDict">ZSTD_CDict</a></div><div class="desc docblock-short">Bulk processing dictionary API</div></li><li><div class="item-name"><a class="type" href="type.ZSTD_CStream.html" title="type zstd_sys::ZSTD_CStream">ZSTD_CStream</a></div></li><li><div class="item-name"><a class="type" href="type.ZSTD_DCtx.html" title="type zstd_sys::ZSTD_DCtx">ZSTD_DCtx</a></div></li><li><div class="item-name"><a class="type" href="type.ZSTD_DDict.html" title="type zstd_sys::ZSTD_DDict">ZSTD_DDict</a></div></li><li><div class="item-name"><a class="type" href="type.ZSTD_DStream.html" title="type zstd_sys::ZSTD_DStream">ZSTD_DStream</a></div></li><li><div class="item-name"><a class="type" href="type.ZSTD_allocFunction.html" title="type zstd_sys::ZSTD_allocFunction">ZSTD_allocFunction</a></div><div class="desc docblock-short">Custom memory allocation :
These prototypes make it possible to pass your own allocation/free functions.
ZSTD_customMem is provided at creation time, using ZSTD_create*_advanced() variants listed below.
All allocation/free operations will be completed using these custom variants instead of regular &lt;stdlib.h&gt; ones.</div></li><li><div class="item-name"><a class="type" href="type.ZSTD_freeFunction.html" title="type zstd_sys::ZSTD_freeFunction">ZSTD_freeFunction</a></div></li><li><div class="item-name"><a class="type" href="type.ZSTD_inBuffer.html" title="type zstd_sys::ZSTD_inBuffer">ZSTD_inBuffer</a></div><div class="desc docblock-short">Streaming</div></li><li><div class="item-name"><a class="type" href="type.ZSTD_outBuffer.html" title="type zstd_sys::ZSTD_outBuffer">ZSTD_outBuffer</a></div></li><li><div class="item-name"><a class="type" href="type.ZSTD_threadPool.html" title="type zstd_sys::ZSTD_threadPool">ZSTD_threadPool</a></div></li><li><div class="item-name"><a class="type" href="type.__locale_t.html" title="type zstd_sys::__locale_t">__locale_t</a></div></li><li><div class="item-name"><a class="type" href="type.locale_t.html" title="type zstd_sys::locale_t">locale_t</a></div></li><li><div class="item-name"><a class="type" href="type.wchar_t.html" title="type zstd_sys::wchar_t">wchar_t</a></div></li></ul></section></div></main></body></html>